####################################################################################################################################################################################################################################################################################################################################

### pip install howdoi ile howdoi'yi yükleriz kullanımı ise howdoi write a function to add two numbers in python...böylece istenen bir fonksiyonu bize verecek...  

### pip install jupyterlab  ... bu komut ile jupyter notebook indiririz.  jupyter-lab  bu komut ile ise jupyter notebook'u açarız.  

pandasın altyapısı numpy üzerinedir. dataframe veri çerçevesi dmeektir. python kütüphanesidir. veri analizi makine öğrenmesi veri bilimi derin öğrenme için kullanılır.

import pandas as pd ile pandas'ı import ederiz

pd.read_excel('pokeman.xlsx') ile excel dosyası okuyabiliriz. xlsx ise excel uzantısıdır

csv dosyası ise virgüllerle ayrılmış verilerden oluşur bazen noktalı virgül. pd.read_csv('sampiyon.csv',delimiter = ';') # eğer noktalı virgül ile ayrılmışsa veriler delimiter = ';' yaparız.

pd.read_excel('pokeman.xlsx').head() yaparsak eğer en baştan alırız. 

pokemon = pd.read_csv('pokemon.csv',delimiter = ';')    yaparsak eğer bu dosyaya bağlanırız.
        ates = pokemon['Type1'] == 'Fire' # sadece ateş olan pokemonları getirir. bu şekilde koşul yapabiliriz   hiz = pokemon['hiz'] > 120 ile hızı 120den büyük olanları bulabiliriz.
        pokemon.colums ile ise tüm kolonları görebiliriz.
        pokemon.index ile ise indexleri görebiliriz.
        pokemon.dropna() Nan olanları vs düşürürüz. onlardan kurtuluruz.
        pokemon["Ranking"].astype("float") # bunun ile biz o kolonun veri türünü float yapabiliriz.
        
eğer csv okumak istersek cars = pd.read_csv('cars.csv') ile okuruz.   eğer csv noktalı virgül ile ayrılmışsa o zaman delimiter = ';' yapmamız lazım. default olarak virgul kullanılır csv'de.
          cars.head(5) yaparsak o zaman baştan 5 tane alır. return eder değerleri.   .head() ile de ilk 5i gelir default olarak.
          cars.tail(5) yaparsak o zaman sondan 5 tane alır. return eder değerleri.
          AA = cars['type1'] == 'fire'  ile type1'i fire olan verileri getiririz. 
          cars[AA] ile ise type1'i fire olanları getiririz.
        
          speed = cars['hiz'] > 120
          cars[speed] ile hızı 120den yüksek olanları buluruz.  
          cars['hiz'].unique() ile birbirinden farklı tüm tipleri getirir. birbirinden farklı hizları görürüz mesela iki tane 120 varsa birini kabul eder.
          
          cars['hiz'] = 120 yaparsak hepsi 120 olur. atama yapabiliriz.

          
sampi.set_index('year') ile yılı index haline getiririz. 
sampi.iloc(0) 0. index'i getirir ilk satır demek.
sampi.loc[1959] # 1959'yılındaki şampiyonu getirir. birden fazla ararsak liste içerisinde yollarız  sampi.loc[[1960,1961,1962]] gibi.

 
pandas'ta | veya yerine geçer & bu ise ve yerine.

panel datadan gelmiştir. panel data herhangi bir durum hakkında zamana bağlı olarak elde edilen veriler. mesela yıllık karsa düşen yağış miktarı.
bir makine öğrenmesi algortimasının başarısını sağlamak için ona olabildiğince fazla veri vermek lazım. mesela ne kadar fazla film izlersek netflix bizim nelerden hoşlandığımızı bilir. çünkü hatalı veriler olabilir tam olarak ortalamayı sağlamak için daha fazla veri vermek lazım... 

pandas ile veri analizi ve veri manipülasyonu yapacağız. yani değişim vs yapabileceğiz. temizleme yapabileceğiz.

pandas ve numpy gibi frameworkler c dili ile yazılmıştır. hızlı çalışması için. 

eğer excel üzerinden okuma yapmak istersek ayrı bir kütüphaneye ihtiyacımız olacak pip install xlrd diyerek bunu kütüphanemize eklememiz lazımdır... pip list ile gelmiş mi gelmemiş mi görebiliriz...

pandasın çalışması için numpy'nin yüklü olması lazım.  *****

pandas ile veri analizi ve manipülasyonu yaparız. 

panda serileri sayesinde veri analizi ve manipülasyonu(değişiklikleri) yapabiliriz. numpy tek tür veriler ile çalışır ama pandas heterojen verilerle çalışabilir. numpy numeric olarak numaralandırır bilgisayar numaralandırması yani 0 1 2 ... pandas ile istenen numaralandırma yapılabilir... 

import pandas as pd ile yapısı ile kullanacağız...

makine öğrenmesi, yapay zeka derin öğrenme için hız önemlidir bu yüzden pandas c ile yazılmıştır bilgisayar diline yakın olduğu için hızlıdır...

seriler tek boyutlu dataframe ise çift boyutludur(satır sutun) matris mantığı.

pandas serilerinde de indexleme vardır. isteğe göre bunu ayarlayabiliriz.

terminale pip show pandas dersek eğer pandas hakkındaki bilgileri görebiliriz. 

///PANDAS SERİES 1/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pandas aldığı verileri alır sutun ve satırlardan oluşan nesnelere çevirir. eğer tek boyutlu ise pandas serisi olur birden fazla sutuna sahip olursa ise pandas dataframe olur.

print(pd.__version__) # 2.0.0 bu yapı ile pandasın verisyonunu görürüz. pip install --user --upgrade pandas ile ise güncelleme yapabiliriz.

pandasın iki temek veri yapısı var series ve dataframe.

............................................................................................................................................................................................................................................................

        import pandas as pd
        import numpy as np

        # dataframe ve series nasıl çalışır = aldığı verileri(sql,csv,list,dict,excel) pandas bu verileri alır ve bu verileri sutun ve satırlardan oluşan verileri çevirir.  tek boyutlu olursa eğer pandas series'tir birden fazla boyutlu olursa aslında çift boyutlu olursa dataframe olurlar.
        # pandas yapıları pythonun yapılarından daha hızlıdır. daha seridir. kendine özgü panda series ve pandas dataframe ile vs daha hızlı çalışır.

        student = ['Arin',20,'ce']
        print(student) 
        print(type(student)) #<class 'list'>

        ps_student = pd.Series(student) #içerisine gönderilen yapıyı panda serisi olarak return edece.

        print(ps_student)
        """
        0    Arin
        1      20
        2      ce
        dtype: object

        """ # tek boyutludur seriler. series yapısının verdiği tablodur. bir index yapısıdır.
        # panda seris farklı veri tiplerini alabilir.hem string hem int verileri aynı anda aldı eğer numpy olsa idi hepsini en üst olan veriye çevirirdi homojen bir yapı elde ederdi.
        print(type(ps_student)) # <class 'pandas.core.series.Series'> 

        dict1 = {"name":"emre","surname":"aytas","age":20}
        pd_dict1 = pd.Series(dict1) # dict'i bir panda series'e çevirdik bunu nasıl yaptı. key'leri ilk sutuna valueleri ikinci sutuna koyarak key value yapısını bozmadı. key'leri panda series'te indexleme için kullandı. 
        print(pd_dict1)  
        """
        name        emre
        surname    aytas
        age           20
        dtype: object

        """
        print(type(pd_dict1)) # <class 'pandas.core.series.Series'>    panda series yapısı dictler ilede çalışır.  tek boyutludur. keyler indexleme için kullandıldı. 

        student1 = pd.Series(["arin",23,"ce"]) #verileri bir liste içerisinde veririz. hepsini toplu göndermek lazım.
        # dtype:object olarak verir. nedeni şu hepsini string'e çevirdi ve dtype'ı object haline getirdi.  

        numbers = pd.Series([1,2,3,4,5,6,7,8])
        print(numbers) #  dtype: int64 verir. bunun nedeni şu tamamı int64 sayılardan oluştuğu için ama heterojen olduğu zaman hepsini üst sınıfa çıkarıp object der dtype'a


        booleans = pd.Series([True,False,True])
        print(booleans) # dtype: bool olarak verir.  



        student2 = pd.Series(data=["Arin",23,"CE"],index=["name","age","department"]) # serilere dict'te gönderebiliriz. ve hangsiinin indexleme hangisinin value olacağını belirtebiliriz.    data ve index ile hem index kolonunu hemde verileri kendimiz belirlemiş olduk.
        print(student2)
        """
        name          Arin
        age             23
        department      CE
        dtype: object

        """ 

        print(student2.values) #sadece valueleri görebiliriz.               ['Arin' 23 'CE']
        print(student2.index) # indexleme elemanlarını görebiliriz.         Index(['name', 'age', 'department'], dtype='object')
        print(student2.shape) # şekil bilgisi alabiliriz.                   (3,)  # (3,4) olsa mesela 3 satır 4 sutun...  tek boyut olunca (elemansayisi,) şeklinde oluyor.
        print(student2.ndim) # boyut bilgisi alabiliriz.                    1
        print(student2.size) # bellekte kaplanan alanı görebiliriz.         3 
        print(student2.dtype) # veri tipini görebiliriz.                    object
        print(student2.name) # ismi verecek. None verir
        student2.name = "messi" # series'e isim verdik.
        print(student2.name) # ismi verecek.                                messi   atama yaparak ismi messi olarak belirledik.

        X = "name" in student2 # eğer student içinde name index'i varsa True verir yoksa False verir.
        Y = "job" in student2 # index elemanlarının içinde job var mı yok mu bakar varsa True yoksa False verir.
        Z = "Ahmet" in student2.values # value'lerin içinde Ahmet var mı yok mu kontrol eder bool bir değer return eder.
        T = "Arin" in student2.values # True verir.

        numbers = pd.Series([4,2.5,2])
        print(numbers)
        """
        0    4.0
        1    2.5
        2    2.0
        dtype: float64   # üst sınıf olarak float olduğu için hepsini float'a çevirdi. 

        """ 
        print(numbers.sum()) # toplamı verir üst class float olduğu için float olur dğeer ve hepsi matematiksel işleme uygun olduğu için sorun olmaz. 
        print(numbers.mean()) #ortalamayı verir tüm değerler matematiksel olduğu için soorun olmaz.
        print(numbers.product()) # çarpımım verir.  değeri üst değer olarak verir int ve float var bu yüzden değerler float olur.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///Pandas series 2/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////Pandas series 2////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import pandas as pd
        import numpy as np

        # series içerinde dtype = ile veri tipi belirtebiliriz.
        student = pd.Series(data=["Arin","Software",23,"CE"],index=["name","surname","age","department"]) # index elemanlarını ayrı olarak yazmazsak eğer o zaman 0 1 2 3 şeklinde default olarak ilerler.
        student2 = pd.Series(["Arin","Software",23,"CE"],["name","surname","age","department"]) # default olarak ilki veri ikincisini index olarak algılar...
        print(student)
        print(student["name"]) # indexler ile valuelere ulaşabiliriz. ulaşmak istediğimiz verinin indexi ile ulaşabiliriz.
        print(student[["name","surname"]]) # eğer birden fazla index ile valuelere ulaşmak istersek o zaman liste içerisine liste şeklinde göndereceğiz.  bize series şeklinde döner.
        print(type(student[["name","surname"]])) # <class 'pandas.core.series.Series'> bir seri dönderdi.
        print(student[1]) # birinci indexteki valueyi verir.   0 verse idik ilk value'yi veriridi..
        print(student[[0,2]])
        """
        name    Arin
        age       23
        dtype: object

        """ # bir seri dönderdi bize ve istenen indexlerdeki elemanları aldık.

        print(student[0:2]) # numpy özellikleri ile aynı 0.index dahil 2. index dahil değil o aralıkta olan valueleri getir demek bir seri halinde gelecek. indexleri ile gelecekler.  tek bir eleman olsa idi student[0] o zaman sadece value gelirdi.
        print(student[0]) # Arin seri halinde gelmedi.
        print(type(student[0])) # <class 'str'> valuenin class'ı
        print(student[-1]) # en sondaki value'yi getirir.
        # aslında student[...] yapısı bize value veya series return ediyor.
        print(student[:]) # tüm index ve valueleri al demek. [:]  yapısı hepsini al demek hepsini kapsa demek.
        print(student[-2:]) # son iki elemanı alırız böylece.

        print(student["name":"department"]) # name'den başla departmente kadar git demek.  tek farkı numeric ile olan fark son indexi dahil eğer departmentte dahil yani.

        # loc -> location metotu indexleme kolonlarını keyleri kullanırız. ...  iloc -> index location metotu. numeric index sıralarını kullanırız.
        print(student.loc["name"]) # Arin
        print(student.loc[["name","age"]])   # student.loc[...]  bu yapıda bir değer veya series return eder.
        """
        name    Arin
        age       23
        dtype: object

        """

        # neden loc ve iloc kullanırız.  kesin olarak numeric index veya kesin olarak keyindex kullandığımızı biliriz. 

        print(student.iloc[1]) # ikinci indexteki value'yi getirir.
        # print(student.iloc["name"]) non integer hatası verir  iloc int değerler ile çalışır.




        # pandas serilerinin değerleri değişebilir. pandas serileri oluştuktan sonra değiştirilebilir yapılardır.  mutable bir yapıdır. yani değiştirilebilir.

        student["name"] = "ford" # bir değişim atama yapabiliriz pandas serilerinin üzerinde.
        print(student["name"])
        student.loc["name"] = "mercedes"
        student.iloc[2] = 21
        print(student)
        """
        name          mercedes
        surname       Software
        age                 21
        department          CE
        dtype: object

        """ # loc ve iloc ilede yapılarda değişim yapabiliriz. 

        student3 = student.drop("name") # .drop(...) orjinal veride değişiklik olmaz. student aynıdır ama bu metot bir seri return eder o seride ise drop edilmiş halde return edilir. 
        print(student)
        """
        name          mercedes
        surname       Software
        age                 21
        department          CE
        dtype: object

        """ # .drop orjinal seride bir değişim yapmaz. bir seri return eder droplanmış halini return eder. inplace = True olmazsa olursa direkt olarak siler verilen keyi ve valuesini.

        print(student3)
        """
        surname       Software
        age                 21
        department          CE
        dtype: object

        """ # .drop komutu orjinal serinin değişmiş halini return eder. ikinci parametre olarak inplace = True dersek o zaman veriyi direkt olarak siler.
        # neden .drop orjinal veride değişiklik yapmaz bunun nedeni drop edersek veriyi bozabiliriz.




        # illaki bir seriden veri silmek istersek o zaman .drop(...,inplace = True) # olduğu yerde sil komutudur.
        student.drop("name",inplace=True) # direkt olarak olduğu yerde siler orjinal veride değişiklik olur böylece.
        print(student)
        """
        surname       Software
        age                 21
        department          CE
        dtype: object

        """

        print(len(student)) # 3 studentin uzunluğunu görebiliriz. kaç tane değer var görürüz kaç value var görürüz.
        print(list(student)) # ['Software', 21, 'CE'] bir listeyi seri yapabilirsek seriyide liste yapabiliriz. sadece valueleri getirir bir liste içerisinde
        print(dict(student)) # {'surname': 'Software', 'age': 21, 'department': 'CE'} bir seriyi dict haline getirebiliriz. 
        student.drop("age",inplace=True)
        # eğer tüm veriler homojen ise o zaman .sorted() metotunu kullabiliriz. hepsi string veya sayı ise.
        print(max(student)) # age'yi drop ettik inplace = True diyerek böylece en yüksek stringi görebiliriz.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///Pandas series 3/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import pandas as pd

        # ReviewContent.csv adında bir csv dosyası yükledik ve pandas.py uzantılı dosyamızın yani çalışacak olan .py uzantılı dosyamızın path'ine ekledik.
        # csv demek virgül veya noktalı virgül ile ayrılmış verilerin tutulduğu dosya demektir aslında.

        # dosya okuma...
        # pd.read_csv("ReviewContent.csv") #csv dosyası okuyacağımız için read_csv() metotunu kullanırız. içerisine path'te bulunan dosyanın adını ve uzantısını ekleriz.
        print(pd.read_csv("ReviewContent.csv",encoding="utf-8")) # verileri tablo şeklinde gösterir.  encoding ile karakter seti belirleyebiliriz. engine = "python" engine belirleme yapabiliriz. 
        """
        Review ID  ... Room Availability
        0      4055629  ...               338
        1     25329416  ...                10
        2     21705849  ...               268
        3     41133812  ...               274
        4      7465026  ...               281
        ..         ...  ...               ...
        995   44498863  ...               329
        996   30544438  ...               309
        997   46642535  ...                10
        998   21403195  ...               357
        999   38944752  ...               329

        [1000 rows x 11 columns]    
        """ 

        review_content = pd.read_csv("ReviewContent.csv",encoding="utf-8") # gelen yapıyı return eder ve atama yaparız.
        print(type(review_content)) # <class 'pandas.core.frame.DataFrame'>  bir DataFrame olarak gösterdi DataFrameler çok boyutludur.

        review_content1 = pd.read_csv("ReviewContent.csv",usecols=["Review ID"],encoding="utf-8").squeeze() # .squeeze() olarak kullanırız. ama hala DataFrame bunun önüne geçmek için bir seri oalrak çalışmak için çalışacağımız sutunu seçeriz. usecols =[] ile kullanacağımız kolon seçimi yapmamız lazım...
        print(type(review_content1)) # <class 'pandas.core.series.Series'>    eğer .squeeze(False) dese idik o zaman DataFramee olurdu bu sistem.  default olarak True allır ve True alırsa o zaman series'e çevirir yapıyı.
        print(review_content1)
        """
        0       4055629
        1      25329416
        2      21705849
        3      41133812
        4       7465026
                ...
        995    44498863
        996    30544438
        997    46642535
        998    21403195
        999    38944752
        Name: Review ID, Length: 1000, dtype: int64
        """ # bir seri oldu. ve dtype tüm veriler aynı ve int olduğu için int64 oldu.. indexleme ise 0'dan başladı 999a kadar.

        review_content2 = pd.read_csv('ReviewContent.csv',usecols=["Review ID","Room Availability"],encoding="utf-8").squeeze()
        print(type(review_content2)) # <class 'pandas.core.frame.DataFrame'>   birden fazla kolon olunca o zaman dataframe olarak kaldı. bu normaldir. Series haline gelebilmesi için tek bir sutun olması lazım.

        print(review_content1.head(13)) #eğer default olarak bırakırsak ilk 5 veriyi getirir.  ama içerisine 10 verirsek ilk 10u getirir 13 dersek 13 tanesini getirir en başından.
        print(review_content1.tail()) # eğer default olarak bırakırsak en sonra 5 veriyi getirir. ama istenen sayıya göre ayarlanabilir.    okuma en baştan sona olur ama en sondaki değerler alınır yani   .tail() dersek 995 996 997 998 999 indexlerini sırası ile getirir.  999 998 997 996 995 değil...
        """
        995    44498863
        996    30544438
        997    46642535
        998    21403195
        999    38944752
        Name: Review ID, dtype: int64

        """ 

        print(review_content1.head(10)) 
        print()

        # eğer verileri indexe göre değil verilere göre sıralamak istersek o zaman .sorted() metotunu kullanacağız. # kalıcı bir değişim sağlama bir Series return eder oda sıralanmış haldir.  sort_values(inplace = True) olursa değişim kalıcı olur.
        print(review_content1.sort_values()) # sort_values() bir series return eder. eğer kalıcı değişim olsun istersek o zaman review_content1 = review_content1.sort_values()   veya    review_content1.sort_values(inplace = True) olması lazım o zaman ana Series'te kalıcı değişim olur. 
        print(review_content1) # değişim yok ana content1'de kalıcı değişim olmadı.
        rc = review_content1.copy() # neden copy kullandık bunun nedeni farklı bir yerde birbirinden bağımsız olsun diye seriesler.
        rc.sort_values(inplace = True,ascending = False) #hem kalıcı değişim olacak hemde ascending = False olacağı için büyükten küçüğe bir sıralama olacak.

        # indexe göre de sıralayabiliriz. 

        rb = review_content1.copy() 
        rb.sort_index(ascending =  False,inplace = True) # kalıcı ve büyükten küçüğe bir sıralama oldu.
        print(rb) # 999 998 .... 1 0 olarak ilerledi indexler.
        print(rb.head(10)) # 999 998 997 ... ilk 10 eleman gelir elimize.

        print(rb[4]) # 44498863 
        print(rb.get(4)) # .get() ilede verileri alabiliriz. içerisine index numarası gireriz.

        #  rb[] ile rb.get()  arasında ne fark var...  rb[1004] dersek hata alırız. ama rb.get(1004) dersek None alırız aralarındaki fark budur.
        print(rb.get(1004,default = "eleman yok")) # burada ise önce index sonra eleman yoksa None veri gelecekse neyi return edeceğini default ile belirtiriz.
        print(type(rb[4])) # <class 'numpy.int64'>  tek değer series değil. numpy'e ait int değer.   pandas numpy üzerinne kuruludur. bunun kanıtıdır.
        print(type(rb.get(4))) # <class 'numpy.int64'>   tek değer ile numpy class'ı olduğunu gördük. pandas numpy üzerine kuruludur. 
        print(rb.get([0,4])) # 0. ve 4. indexteki elemanları görebileceğiz.  
        print(type(rb.get([0,4]))) # <class 'pandas.core.series.Series'>   bir seri olduğunu görürüz.
        

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///DataFrame oluşturmak./////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import pandas as pd 

        # boyut demek aslında şudur. = tek boyutlu demek tek ifade ile bir veriyi tanımlayabiliriz ama dataframe olunca iki ifade ile yer belirtebiliriz. 

        students = [ # bir liste ve içerisinde dict veriler var. dictlerden oluşan bir liste. 
        {
                "name":"arin",
                "age":21,
                "gender":"F"
        },
                {
                "name":"Fatih",
                "age":22,
                "gender":"M"
        },
                {
                "name":"elis",
                "age":24,
                "gender":"F"
        }
        
        ]

        print(type(students)) # <class 'list'>

        df_students = pd.DataFrame(students)
        print(df_students)
        """
        name  age gender
        0   arin   21      F
        1  Fatih   22      M
        2   elis   24      F

        """   # indexleme var.  sutunlar ve değerleri var listenin elemanlarını kullanarak bir dataframe oluşturdu.  dict'teki keyleri sutun indexi olarak kullandı valueleri ise değerler olarak kullanır. konum belirtmek için hem satır indexi hemde sutun indexi kullanmamız lazım bunu nedeni bu bir DataFrame'dir.
        print()
        print(type(df_students)) # <class 'pandas.core.frame.DataFrame'>    bir DataFrame ...






        # veriyi iki boyutlu olarak ifade edebilirsek DataFrame olarak kullanabiliriz.

        teachers = {
        "names":[
                "ahmet",
                "cansu",
                "hakan"
        ],
        "ages":[
                41,36,40
                
        ],
        "genders":[
                "M","F","M"
        ]
        
        }

        print(type(teachers)) # <class 'dict'>

        df_teachers = pd.DataFrame(teachers) # bir dict içerisndeki veriler ile dataframe oluşturdk...
        print(df_teachers)
        """
        names  ages genders
        0  ahmet    41       M
        1  cansu    36       F
        2  hakan    40       M

        """
        print(type(teachers)) # <class 'pandas.core.frame.DataFrame'>    bir DataFrame ...





        list_of_list = [
        ["ahmet","mehmet","ayşe"],
        [44,39,51]
        
        ]
        print(list_of_list) # [['ahmet', 'mehmet', 'ayşe'], [44, 39, 51]]
        print(type(list_of_list)) # <class 'list'>

        df_listoflist = pd.DataFrame(list_of_list)
        print(df_listoflist)
        """
        0       1     2
        0  ahmet  mehmet  ayşe
        1     44      39    51

        """ # bir sutun bilgisi olmadığı için sutun ve satiri 0'dan indexledi.  listenin içindeki her bir listeyi bir satır olarak aldı her her veri bir sutuna denk geldi. 2 liste var 2 satir var listelerin içinde 3 eleman var 3 sutun var...
        print(type(df_listoflist)) # # <class 'pandas.core.frame.DataFrame'>    bir DataFrame ...

        # eğer bir yapı ile çift katlı yapı kurabilirsek DataFrame yapabiliriz.



        names = ["ahmet","mahmut","fatih"]
        print(type(names)) # <class 'list'>

        df_names = pd.DataFrame(names)
        print(df_names)
        """
                0
        0   ahmet
        1  mahmut
        2   fatih

        """ # liste tek boyutlu olsa bile biz bir DataFrame kurabiliriz... sonuçta satır ve sutun yapısı var  default olarka sutuna 0.index verildi ve her eleman bir satıra atandı..
        print(type(df_names)) # <class 'pandas.core.frame.DataFrame'>
        print(df_names.ndim) # 2 verdi yani 2 boyutlu o zmaan bir DataFrame yapısı...







        students1 = {"name":"hale","age":24}
        print(type(students1)) # <class 'dict'> 

        #   df_stt = pd.DataFrame(students1)    # hata verir bunun nedeni klasik dict ile biz direkt olarak dataframe kuramayız bir index belirlememiz lazım
        # hata vermesinin sebebi indexlemeyi dict'in keyleri ile yapamayız bunun yüzünden indexleme yapmamız lazım.

        students2 = {"Hale":pd.Series(data=[25,"F","CE"],index=["age","gender","department"]),
                "Ahmet":pd.Series(data=[32,"M","EE"],index=["age","gender","department"])}

        # series ile biz indexleme kurduk data ve index belirterek.
        print(type(students2)) # <class 'dict'>

        df_stt1 = pd.DataFrame(students2)
        print(df_stt1)
        """
                Hale Ahmet
        age          25    32
        gender        F     M
        department   CE    EE

        """ # keyleri sutun olarka kullandık bu yapı ile. indexler ise satırlar oldular indexlendiler her birinin indexe gelen değeri ise satıra yerleşti valueler indexler ile eşlenerek satırlara yerleştiler.
        print(type(df_stt1)) # <class 'pandas.core.frame.DataFrame'>    bir DataFrame ...




        # indexlemede değişim yaparsak.....


        students3 = {"Hale":pd.Series(data=[25,"F","CE",172],index=["age","gender","department","height"]),
                "Ahmet":pd.Series(data=[32,"M","EE",100],index=["age","gender","department","weight"])}

        # series ile biz indexleme kurduk data ve index belirterek.
        print(type(students3)) # <class 'dict'>

        df_stt2 = pd.DataFrame(students3)
        print(df_stt2)
        """
                Hale Ahmet
        age          25    32
        department   CE    EE
        gender        F     M
        height      172   NaN
        weight      NaN   100

        """ # indexlemenin hepsini yaptı ancak sutunlardan birinde eksik değer varsa NaN dedi indexlemeyi ihmal etmedi.  olabildiğince indexleme yaptı eğer sutunlardan birisinde eksik veri varsa NaN dedi. NaN demek veri yok demek pandas'ta.
        print(type(df_stt2)) # <class 'pandas.core.frame.DataFrame'>    bir DataFrame ...

# pandasın en güçlü yapısı budur olmayan verilerle çalıa

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////DataFrame yapısını değiştirmek.../////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        import pandas as pd

        students = {"Hale":pd.Series(data=[25,"F","CE",61],index=["age","gender","department","weight"]),
                        "Ahmet":pd.Series(data=[32,"M","EE",100],index=["age","gender","department","weight"]),"Fatma":pd.Series(data=[32,"M","EE",82],index=["age","gender","department","weight"])
        }
        df_students = pd.DataFrame(students)
        print(df_students)
        """
                Hale Ahmet Fatma
        age          25    32    32
        gender        F     M     M
        department   CE    EE    EE
        weight       61   100    82

        """ # aslında keyler kolon olarak kullanılıyor bu yapıda. value ise bir seri oluyor. seriden satılar oluşuyor indexlemesi ile index ve data sayesinde seri oluşturduk.

        df_students2 = pd.DataFrame(students,columns=["Hale"]) # sadece hale kolonunu alacak... indexlemesi ve valueleri ile...
        print(df_students2)
        """
                Hale
        age          25
        gender        F
        department   CE
        weight       61

        """
        df_students3 = pd.DataFrame(students,columns=["Hale","Ahmet"]) # Hale ve Ahmet kolonunu alacak... indexlemesi ve valueleri ile...
        print(df_students3)
        """
                Hale Ahmet
        age          25    32
        gender        F     M
        department   CE    EE
        weight       61   100
        """

        df_students4 = pd.DataFrame(students,index=["age","gender"]) # sadece istediğimiz satırları alabiliriz bunu index ile belirleriz... eğer biz kolonlara göre bir ayrım yapmak istersek columns = [istenen kolonlar] istenen satırları görmek istersek o zaman index = [] yaparız..
        print(df_students4)
        """
        Hale Ahmet Fatma
        age      25    32    32
        gender    F     M     M

        """

        df_students5 = pd.DataFrame(students,index=["age","gender"],columns=["Hale","Ahmet"]) # sadece istediğimiz satırları alabiliriz bunu index ile belirleriz... eğer biz kolonlara göre bir ayrım yapmak istersek columns = [istenen kolonlar] istenen satırları görmek istersek o zaman index = [] yaparız.. hem satır hemde sutun belirlemesi yaptık...
        print(df_students5)
        """
        Hale Ahmet
        age      25    32
        gender    F     M

        """ # series'in indexlemesini ve valuelerini aldık keyler sutun olarak kullanıldı...   DataFrame içerisinde parçalama yapabildik. index = [] ve columns = [] sayesinde...

        




        students6 = {"Hale":pd.Series(data=[25,"F","CE",61],index=["age","gender","department","weight"]),
                        "Ahmet":pd.Series(data=[32,"M","EE",100],index=["age","gender","department","weight"]),"Fatma":pd.Series(data=[32,"M","EE",82],index=["age","gender","department","weight"])
        }
        df_students6 = pd.DataFrame(students6)

        print(df_students6["Ahmet"]) # notasyon yapacağız. ahmet sutunundaki verileri görebiliriz böylecek.  indexlemeleri ve Ahmet'in verilerini alabiliriz.
        """
        age            32
        gender          M
        department     EE
        weight        100
        Name: Ahmet, dtype: object

        """ # sutun indexi yok bunun nedeni bu bir seri.. tek parça olunca o zaman Series olur...
        print(type(df_students6["Ahmet"])) # <class 'pandas.core.series.Series'>    aslında indexlemeler ve valueler Seriesler sayesinde oluştu bu serileri birleşerek DataFrame oldu. tek bir sutun alarak tek bir Series aldık bu yüzden bu yapı bir Series yapısıdır.

        print(df_students6[["Ahmet","Hale"]]) # birden fazla veri varsa DataFrame olur... Seriler birleşince DataFrame olur..  birden fazla veri ile işlem yapacaksak veya sutun bilgisi ile işlem yapacaksak o zaman sutunları [] içerisinde göndeririz.
        """
                Ahmet Hale
        age           32   25
        gender         M    F
        department    EE   CE
        weight       100   61

        """ 


        print(df_students6[["Ahmet"]])
        """
                Ahmet
        age           32
        gender         M
        department    EE
        weight       100
        """ #bu sefer [   ["Ahmet"]   ]   olarak gönderdik yani sutun bilgisi dahil oldu böylece ndim 2 olarak işlem gördü bu bir DataFrame...

        print(type(df_students6[["Ahmet"]]))  #<class 'pandas.core.frame.DataFrame'>  bu sefer notasyona bir liste gönderdik bu sutun bilgisi ile gel demek böylece sutun indexi dahil olunca iki boyutlu oldu. bir DataFramedir bu bu yüzden.   [ ["Ahmet"] ] olarak gönderince sutun indexi dahil olsun istedik aslında.



        print(df_students6.loc["age"]) # age satırı için bunu kullanırız. yaş satırını alacağımız için sadece o zaman bir series halinde geldi aslında satır veya sutun teklenirse Series olur.
        """
        Hale     25
        Ahmet    32
        Fatma    32
        Name: age, dtype: object

        """

        print(type(df_students6.loc["age"])) # # <class 'pandas.core.series.Series'>   tek satır veya tek sutun olursa o zaman Series olur DataFrame.



        print(df_students6.loc[["age","gender"]]) # birden fazla satır ile işlem yaparsak bir liste içerisinde göndeririz.
        """
        Hale Ahmet Fatma
        age      25    32    32
        gender    F     M     M

        """ # bu bir DataFramedir çünkü iki boyutludur.


        # DF[col][row] yapısı kullanırız. bu şekilde tek elemana ulaşırız.

        print(df_students6["Hale"]["age"]) # 25  # once kolon sonra satır indexi yazılır. 

        print(df_students6["Hale"][2]) # EE Hale sutunun 2.indexteki satırını getirir. 3 satırı getirir.

        df_students6["Fatih"] = [17,"M","ELH",190]  # satır indexlemesine göre sırası ile yerleştirdik... burası önemlidir.  sutun ekleme işlemini böyle yapabiliriz.

        print(df_students6)
        """
                Hale Ahmet Fatma Fatih
        age          25    32    32    17
        gender        F     M     M     M
        department   CE    EE    EE   ELH
        weight       61   100    82   190

        """

        df_students6["Fatih2"] = df_students6["Fatma"] + df_students6["Fatih"] # burada yeni bir sutun indexi ekledik... ama + diyerek aslında değerleri sırası ile topladı.. stringler sırası ile toplanınca  FM gibi bir şey oldu gender.  boylar toplandı yaşlat toplandı vs
        print(df_students6)
        """
                Hale Ahmet Fatma Fatih Fatih2
        age          25    32    32    17     49
        gender        F     M     M     M     MM
        department   CE    EE    EE   ELH  EEELH  # EE ve ELH toplanınca stirng olacağı için yan yana yazılır toplamaya ilk olarak Fatma verdiğimiz için başta onun verileri olur stringlerde vs
        weight       61   100    82   190    272

        """










        students = {"Hale":pd.Series(data=[25,"F","CE",61],index=["age","gender","department","weight"]),
                        "Ahmet":pd.Series(data=[32,"M","EE",100],index=["age","gender","department","weight"]),"Fatma":pd.Series(data=[32,"M","EE",82],index=["age","gender","department","weight"])
        }

        df_students7 = pd.DataFrame(students)

        new_row = pd.DataFrame({"Hale":"kurek","Ahmet":"manav","Fatma":"mercedes"},index=["surname"]) # her sutuna gelecek değerleri yazdık bir dict içerisinmde ve index ile gelecek satırın adını belirttik.

        df_students7 = pd.concat([df_students7,new_row],ignore_index=True) # bu yapı ile yeni satırı ekleriz.
        print(df_students7)
        """
        Hale  Ahmet     Fatma
        0     25     32        32
        1      F      M         M
        2     CE     EE        EE
        3     61    100        82
        4  kurek  manav  mercedes
        """

        # pop ile sadece sutun çıkarabiliriz...   drop metodu ile ise hem sutun hemde sutun çıkarabiliriz...

        df_students7.pop("Ahmet")
        print(df_students7)
        """
        Hale     Fatma
        0     25        32
        1      F         M
        2     CE        EE
        3     61        82
        4  kurek  mercedes

        """ # ahmet sutunu pop metotu sayesinde gitti.


        df_students7.drop("Hale",axis=1,inplace=True)  # drop kalıcı değişim yapmaz kalıcı değişim olan halini return eder. eğer kalıcı olsun istersek o zaman inplace = True dememiz lazım.
        print(df_students7)  # sutun ile işlem yapacağımız için biz axis = 1 deriz yoksa hata alırız... default olarak bir değeri yok yoksa hata alırız...
        """
        Fatma
        0        32
        1         M
        2        EE
        3        82
        4  mercedes
        """


        students = {"Hale":pd.Series(data=[25,"F","CE",61],index=["age","gender","department","weight"]),
                        "Ahmet":pd.Series(data=[32,"M","EE",100],index=["age","gender","department","weight"]),"Fatma":pd.Series(data=[32,"M","EE",82],index=["age","gender","department","weight"])
        }

        df_students8 = pd.DataFrame(students)

        df_students8.drop("Hale",axis=1) # kalıcı bir değişim olmaz ama kalıcı değişim olan halini return eder. bir atama yapmadan kalıcı değişim olsun istersek eğer o zaman inplace = True diyebiliriz.
        df_students8.drop(["Hale","Ahmet"],axis=1,inplace=True) # inplace = True olduğu için df_students8'de değişim kalıcı olacak.  birden fazla sutun olduğun için bir liste halinde gönderdim.  axis = 1 olduğu için sutunlar üzerinde oldu olan işlemler.    df9 = 
        print(df_students8)
        """
                Fatma
        age           32
        gender         M
        department    EE
        weight        82

        """ # bu bir DataFrame hem sutun hemde satır indexi var ndim = 2 yani iki boyutlu demekki bir DataFrame.



        students = {"Hale":pd.Series(data=[25,"F","CE",61],index=["age","gender","department","weight"]),
                        "Ahmet":pd.Series(data=[32,"M","EE",100],index=["age","gender","department","weight"]),"Fatma":pd.Series(data=[32,"M","EE",82],index=["age","gender","department","weight"])
        }

        df_students9 = pd.DataFrame(students)

        df_students9.drop(["age","gender"],axis=0,inplace=True) # satırlardan bu şekilde kurtulabiliriz. verileri yok eder. satırların indexlemesini yok eder. eğer birden fazla satır iptal edeceksek o zaman liste içerisinde yaparız. axis = 0 olmalı bunun nedeni satırlarla işlem yapacağımız için. 
        print(df_students9)
        """
                Hale Ahmet Fatma
        department   CE    EE    EE
        weight       61   100    82

        """

        df_students9.drop("weight",inplace=True,axis=0) # tek satırdan kurtulmak istersek liste içerisinde değil direkt olarak ismini yazarız. axis = 0 olduğu için satırı siler.
        print(df_students9)
        """
                Hale Ahmet Fatma
        department   CE    EE    EE

        """

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//// NaN Eksik Veri, Dökümantasyon Okumak ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import pandas as pd

# pandas NaN veriler ile çok iyi şekilde sorunsuz çalışabilir.

students = {"Hale":pd.Series(data=[25,"Cetin","CE",161],index=["age","surname","department","height"]),
                        "Ahmet":pd.Series(data=[32,"M","EE",100],index=["age","gender","department","weight"]),"Fatma":pd.Series(data=[32,"Gulsen","EE",175],index=["age","surname","department","height"])
        }

df_students = pd.DataFrame(students)
print(df_students)
"""
             Hale Ahmet   Fatma
age            25    32      32
department     CE    EE      EE
gender        NaN     M     NaN
height        161   NaN     175
surname     Cetin   NaN  Gulsen
weight        NaN   100     NaN

""" # var olan tüm satırları indexlemek için kullanır ve olmayan veriler için ise NaN der.  mesela Fatma sutunun weight bilgisi yok bu yüzden NaN verdi hata vermedi.



# isnull()
x = df_students.isnull()
print(x)
"""
             Hale  Ahmet  Fatma
age         False  False  False
department  False  False  False
gender       True  False   True
height      False   True  False
surname     False   True  False
weight       True  False   True

""" # verinin var olup olmamasına göre True False verir tüm değerlere veri yoksa True varsa False NaN olanlara True verdi.
print(type(x)) # <class 'pandas.core.frame.DataFrame'>  bu bir DataFrame çünkü ndim = 2 ...



y = df_students.isnull().sum() # her sutunda kaç tane True var yani boşdeğer var göreceğiz.
print(y)
"""
Hale     2
Ahmet    2
Fatma    2
dtype: int64

""" # her sutunda kaç adet True var yani her suttunda kaç adet satır boşdeğer bunu görebiliriz.  
print(type(y)) # <class 'pandas.core.series.Series'>  bu bir seridir ndim = 1   çünkü sutun boyutu yok tek boyutlu. bir seridir.




z = df_students.isnull().sum().sum() # ikinci .sum() ile komple DataFramede kaç tane boş veri var bunu görebiliriz. Series'in elemanlarını topladı ve numpy.int veri haline geldi.
print(z)  # 6
print(type(z)) # <class 'numpy.int64'>








# notnull()

t = df_students.notnull() # isnull'ın tersidir. değer varsa True yoksa False verir..
print(t)
"""
             Hale  Ahmet  Fatma
age          True   True   True
department   True   True   True
gender      False   True  False
height       True  False   True
surname      True  False   True
weight      False   True  False
"""

f = df_students.notnull().sum() # her sutunda kaç adet dolu değer var görebiliriz.
print(f)
"""
Hale     4
Ahmet    4
Fatma    4
dtype: int64

"""
print(type(f)) # <class 'pandas.core.series.Series'>  bu bir seridir. sutun bilgisi yoktur. tek boyutludur.


g = df_students.notnull().sum().sum() # komple DataFramede kaç tane dolu veri var görebiliriz.
print(g) # 12  
print(type(g)) # <class 'numpy.int64'>





# .count()

h = df_students.count() # .count() = .notnull().sum()
print(h)
"""
Hale     4
Ahmet    4
Fatma    4
dtype: int64
""" 

j = df_students.count().sum()
print(j) # 12
print(type(j)) # <class 'numpy.int64'>





# dropna()  

x = df_students.dropna() # içerisinde NaN veri olan satırları kaldırır.
print(x)
"""
           Hale Ahmet Fatma
age          25    32    32
department   CE    EE    EE

""" # herhangi bir satırda NaN veri varsa o satırı kaldırır. sadece NaN verisi olmayan verileri kalır 
print(type(x)) # <class 'pandas.core.frame.DataFrame'>

df_students1 = df_students2 = df_students

df_students.dropna()  # .dropna() anaDataFramede bir değişim yapmaz ama işlem görmüş DataFrame'yi return eder. ancak içerisinde inplace = True dersek o zaman kalıcı bir değişim sağlar kalıcı olarak eksik verisi olan satırlar yok olur.
print(df_students)
"""
             Hale Ahmet   Fatma
age            25    32      32
department     CE    EE      EE
gender        NaN     M     NaN
height        161   NaN     175
surname     Cetin   NaN  Gulsen
weight        NaN   100     NaN
""" # .dropna() anaDataFramede bir değişim yapmaz ama işlem görmüş DataFrame'yi return eder.


x = df_students1.dropna(how="all")  # bunun mantığı şudur. eğer bir satırda tüm veriler NaN ise o satırı sil demek eğer  bir satırda bir tane bile veri varsa ona dokunmaz...
print(x)
"""
age            25    32      32
department     CE    EE      EE
gender        NaN     M     NaN
height        161   NaN     175
surname     Cetin   NaN  Gulsen
weight        NaN   100     NaN

""" # 
print(type(x)) # <class 'pandas.core.frame.DataFrame'> bu bir DataFrame çünkü iki boyutlu...


df_students1["Ahmet"]["weight"] = None # bu yapı ile atama yapabiliriz. önce sutun sonra satır bilgisi ile direkt olarak kalıcı atama yapabiliriz
u = df_students1.dropna(how="all")  # bunun mantığı şudur. eğer bir satırda tüm veriler NaN ise o satırı sil demek eğer  bir satırda bir tane bile veri varsa ona dokunmaz...
print(u)
"""
             Hale Ahmet   Fatma
age            25    32      32
department     CE    EE      EE
gender        NaN     M     NaN
height        161   NaN     175
surname     Cetin   NaN  Gulsen

""" # tüm verileri NaN olan satıları sildi mesela weight satırını sildi çünkü weight'te ahmete None verdik böylece satır kayboldu.




g = df_students2.dropna(thresh=2) # thresh = 1 olursa 2 Tane Nan veriye izin verir. Ama eğer thresh = 2 olursa o zaman iki tane NaN olanları siler. thresh = 2 olursa max bir tane NaN'a izin verir. eşit ve daha fazla olanlar elenir.
print(g)
"""
age            25    32      32
department     CE    EE      EE
height        161   NaN     175
surname     Cetin   NaN  Gulsen 
""" # bir bir DataFrame   

l = df_students2.dropna(axis=0) # NaN olan satırlar gitti...
print(l)
"""
           Hale Ahmet Fatma
age          25    32    32
department   CE    EE    EE
"""

m = df_students2.dropna(axis=1) # içerisinde NaN olan sutunları silecek komple.. how = "all" dersek o zaman tüm satırları NaN olan sutunu silecek.
print(m)
"""
Empty DataFrame
Columns: [] 
Index: [age, department, gender, height, surname, weight]
""" # boş bir DataFrame oldu... çünkü veri kalmadı bunun nedeni her sutunda NaN veri var...










students = {"Hale":pd.Series(data=[25,"Cetin","CE",161],index=["age","surname","department","height"]),
                        "Ahmet":pd.Series(data=[32,"M","EE",100],index=["age","gender","department","weight"]),"Fatma":pd.Series(data=[32,"Gulsen","EE",175],index=["age","surname","department","height"])
        }

df_students3 = pd.DataFrame(students)

df_students3.dropna(inplace=True) # DataFrame kalıcı olarak değişir...
df_students4 = pd.DataFrame(students)


x = df_students4.fillna(method="ffill")  
print(x)
"""
             Hale Ahmet   Fatma
age            25    32      32
department     CE    EE      EE
gender         CE     M      EE
height        161     M     175
surname     Cetin     M  Gulsen
weight      Cetin   100  Gulsen
""" # NaN verileri o NaN'dan önce gelen verileri verdi...  mesela gender'i NaN olan birisi gender olarak department'in değerini alır...

y = df_students4.fillna(method="ffill",axis=1) # default olarak axis = 0. NaN veri bir önceki satırdan alınırdı ama eğer axis = 1 olursa NaN veri bir önceki sutun ile tamamlanır...
print(y)
"""
             Hale  Ahmet   Fatma
age            25     32      32
department     CE     EE      EE
gender        NaN      M       M
height        161    161     175
surname     Cetin  Cetin  Gulsen
weight        NaN    100     100

""" # bazı veriler NaN olarak kaldı bunun nedeni kendinden önce bir veri olmaması... kendisinden önce verisi olan bir sutun yoksa NaN olarak kalır...

z = df_students4.fillna(method="backfill",axis=1) # kendisinden sonrakine bakarak doldurur backfill...
print(z) # acis = 1 olduğu için alışveriş sutunlar arasında olacak yani değişim aynı satır düzleminde olacak sağdan sola şekilde. axis = 0 olsa idi ki zaten default olara 0 o zaman verileri NaN verileri Altındaki satırlardan alarak dolduracak.
"""

             Hale   Ahmet   Fatma
age            25      32      32
department     CE      EE      EE
gender          M       M     NaN
height        161     175     175
surname     Cetin  Gulsen  Gulsen
weight        100     100     NaN

"""

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////CSV Dosya Analizi////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import pandas as pd

        # ReviewContent.csv adında bir dosya indirmemiz gerekir onuda indirdik.
        # genel olarak işlenecek verileri dışarıdan alırız. csv,excel vs...

        review = pd.read_csv("ReviewContent.csv") # uzantıları unutmamak lazım.
        print(review)
        """
        Review ID  ... Room Availability
        0      4055629  ...               338
        1     25329416  ...                10
        2     21705849  ...               268
        3     41133812  ...               274
        4      7465026  ...               281
        ..         ...  ...               ...
        995   44498863  ...               329
        996   30544438  ...               309
        997   46642535  ...                10
        998   21403195  ...               357
        999   38944752  ...               329

        [1000 rows x 11 columns]

        """ # bu şekilde gösterir. tümünü göstermeye kalkarsak. hepsini göremeyiz. bir kısmını gösterir bize sadece. normalde matplotlip vs ile verileri görselleştiririz.

        review1 = review.copy() # birden fazla oluşturduk...
        review2 = review1.copy()
        print(type(review)) # <class 'pandas.core.frame.DataFrame'>     bir DataFrame...s
        print(review.info()) # bilgileri verir DataFrame hakkında. .info() fonksiyonu.
        """
        <class 'pandas.core.frame.DataFrame'>
        RangeIndex: 1000 entries, 0 to 999
        Data columns (total 11 columns):
        #   Column             Non-Null Count  Dtype
        ---  ------             --------------  -----
        0   Review ID          1000 non-null   int64
        1   Review Date        1000 non-null   object        
        2   Review Content     999 non-null    object   # bir tane boş veri var. bunu doldurursak tabloda komple hiç NaN veri olmaz.     
        3   Listing Title      1000 non-null   object        
        4   Neighbourhood      1000 non-null   object        
        5   City               1000 non-null   object        
        6   State              1000 non-null   object        
        7   Country            1000 non-null   object        
        8   Room Type          1000 non-null   object        
        9   Room Price         1000 non-null   int64
        10  Room Availability  1000 non-null   int64
        dtypes: int64(3), object(8)
        memory usage: 86.1+ KB
        None
        """ # bilgileri aldık df.info() ile bilgileri return etti print ile yazdırdık.
        
        print(review.head()) # ilk 5 değer default olarak ama sayı girersek istenen kadar verir bize.
        print(review.tail()) # son 5 değer default olarak. girdiğimiz değere göre yukarıdan aşağıya istenen eleman sayısı kadar sondaki elemanları getirir.
        print("............")
        print(review.dtypes) # veri türlerini göster deriz kullanılan verilerin türlerini.
        """
        Review ID             int64
        Review Date          object
        Review Content       object
        Listing Title        object
        Neighbourhood        object
        City                 object
        State                object
        Country              object
        Room Type            object
        Room Price            int64
        Room Availability     int64
        dtype: object
        """ # tüm kolonlardaki verilerin yapısını görebiliriz. tek tek.
        print(review.ndim) # 2 boyut bilgisini alırız. bu bir dataframe bu yüzden 2.
        print(review.columns)
        """
        Index(['Review ID', 'Review Date', 'Review Content', 'Listing Title',
        'Neighbourhood', 'City', 'State', 'Country', 'Room Type', 'Room Price',
        'Room Availability'],
        dtype='object')
        """ # columns özelliği sadece DataFrame'de var. Series'lerde yok.
        # columns gibi özellikler nesneni özellikleridir method değildir. method olsa idi () ile olması lazımdı.

        # pandas.pydata.org  ile pandasın nasıl kullanılacağını görebiliriz. dökümantasyon okumak lazım her zaman.

        print(review.memory_usage()) # böylece ne kadar hafıza kullanılır görebiliriz.
        """
        Index                 132
        Review ID            8000
        Review Date          8000
        Review Content       8000
        Listing Title        8000
        Neighbourhood        8000
        City                 8000
        State                8000
        Country              8000
        Room Type            8000
        Room Price           8000
        Room Availability    8000
        dtype: int64
        """ # bu bir seridir. Series olarak geldi sadece satır indexlemesi var sutun indexlemesi yok tek boyutludur. 

        toplam = review["Room Price"].sum() # tüm Room Price bilgilerine ulaştık ve sum dedik.
        print(toplam)

        # print(review.sum()) # her bir satırı toplar. bir seri elde ederiz. DataFrame olduğu için.  seride sum() kullanırsak tek bir değer elde ederiz ama DataFramede toplama kullanırsak o zaman Series elde ederiz.

        print(review["Room Availability"])
        """
        0      338
        1       10
        2      268
        3      274
        4      281
        ...
        995    329
        996    309
        997     10
        998    357
        999    329
        Name: Room Availability, Length: 1000, dtype: int64 

        """
        print(type(review["Room Availability"])) # <class 'pandas.core.series.Series'> DataFrameden tek bir parça aldık bu bu yüzden bir seridir. 

        print(review["Room Availability"].add(10)) # her satıra 10 eklemesi yaptı... değişim kalıcı değil. olsun istersek bu yapıyı başka bir değişkene atamak lazım RTR = review["Room Availability"].add(10)   gibi...
        # eğer review["Room Availability"] + 10 dese idikte aynısı olurdu pandas numpy üzerine kurulu olduğu için buna izin verirdi.

        # sum toplama +, sub çıkarma - , div bölme /, mul çarpma *.   methodlarını veya işaretlerini kullanıncada çalışır bir sorun olmaz.
        print(review["City"]) # bir Seri döner ve şehirleri görebiliriz.


        # value_counts()  ile biz bir sutunda bir veri kaç kere kullanılmış kaç tane satırda var görebiliriz.
        print(review["City"].value_counts("New York City")) # 135 ... City sutunundaki New York City  kaç tane satırda kullanılmış bunu görebiliriz...
        print(review["Room Price"].value_counts()) # default olarak bırakınca her değerden kaç tane var bize gösterir.
        """
        Room Price
        80     32
        120    31
        75     27
        95     27
        55     26
        ..
        360     1
        775     1
        500     1
        265     1
        191     1
        Name: count, Length: 180, dtype: int64
        """

        print(review["Room Price"].sort_values(ascending=False)) # değerleri sırala demek aynı sutunda satırlar sıralanacak. ascending = False olursa azalarak bir sıralama gerçekleşir en yüksekten en düşüğe sıralar.
        # .head(1) ile ise en baştaki en çok para olan odayı görebiliriz.

        print(review["City"].sort_values()) # verileri alfabetik sıralamata göre sıralar.  ascending = False dersek ters Alfabetik sıralama yapar.
        print(type(review["City"].sort_values())) # <class 'pandas.core.series.Series'>   DataFrame'den tek bir sutunu çıkarttık bu bir seri oldu... eğer bu seriyi kullanmak istersek bunu bir değişkene atamamız lazım    TYTY = review["City"].sort_values()  şeklinde....

        print(review.sort_values("Room Price")) # Room Price sütununa göre sıralama yapar böylece.
        """
        Review ID Review Date                                     Review Content  ...        Room Type Room Price Room Availability
        740   37117583  2012-04-20  Alex is a very considerate airbnb host. He mad...  ...      Shared room         16               326
        718   47355526  2012-08-05  Manuel was very sweet and helpful! Very nice a...  ...     Private room         16               112
        306   44838729  2012-06-03  It was easy to find and the room was clean. Ve...  ...     Private room         19               336
        452   11937812  2012-05-28  I just had a wonderfull time in there: good co...  ...     Private room         19               333
        795   37947941  2012-11-02  We only got to stay 12 hours, but this is exac...  ...     Private room         22                25
        ..         ...         ...                                                ...  ...              ...        ...               ...
        555    8381199  2014-10-25  This was my first Airbnb experience.  We were ...  ...  Entire home/apt        650               327
        613   41553198  2014-12-10  Brian and his team were great! We had a group ...  ...  Entire home/apt        725               316
        518   29952932  2013-06-15      Very beautiful apartment in a great location.  ...  Entire home/apt        775               316
        489   25836446  2012-03-05  The reservation was canceled 79 days before ar...  ...  Entire home/apt        800               359
        799    5239947  2013-01-15  The only issue that we had was that the elevat...  ...  Entire home/apt       1500               365

        [1000 rows x 11 columns]

        """  # en küçük Room Priceye göre DataFrame'nin satırlarını sıraladı. eğer ascending = False olsa idi o zaman Room Price sutununa göre  büyükten küçüğe sıralardı...

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

####################################################################################################################################################################################################################################################################################################################################