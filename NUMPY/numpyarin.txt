####################################################################################################################################################################################################################################################################################################################################

en çok kullanılan bilimsel hesaplama kütüphanesidir. açık kaynak kodlu güçlü sayısal işlemler için kullanılan bir python kütüphanesidir. genellikle Matematiksel işlemler için kullanılır. çok yoğun ve hızlı hesaplamalar yapabilir.

import numpy as np # core kodu c dilinde yazılmıştır. numpy çok dilli olarak modellenmiştir.

x = np.array([1,2,3,4,5,6]) # bir array oluşturmak için ([]) yapısı ile koymak lazım direkt olarak verileri koymak hata olur. her birini farklı bir yapı olarak kabul eder o yüzden bir arrayin elemanlarını bir liste içerisinde göndermek ve o listenden bir array elde etmek lazım.

# numpy'in temel veri elemanı çok boyutlu dizinlerdir. vektör ve matris ifadelerini daha kolay modellememizi sağlar. 

nupmy klasik pythondan daha hızlıdır. bu yüzden kullanılır zaten. sayılarla işlem yapmak için kullanılır genel olarak.


///Ders 1 - NDArray Oluşturmak - Upcasting//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
numpy = klasik pythondan daha hızlı çalışır çünkü core olarak c kullanılmıştır. 
   
NDArray = numpy'nin temel veri yapısıdır. çok boyutlu dizin demektir NDArray 
    
        import numpy as np
        import time

        baslangic = time.time()

        A = np.arange(10000000) # 10000000 tane eleman oluşturduk. 0'dan 10000000'a kadar birer birer 
        A ** 2 # tüm değerlerin karesini aldık.

        bitis = time.time()


        baslangic1 = time.time()

        L = range(10000000)
        [i ** 2 for i in L] # i range üzerinde döndü ve her seferinde listeye i'nin karesi eklendi. 

        bitis1 = time.time()

        print(bitis - baslangic) # 0.007336139678955078

        print(bitis1 - baslangic1) # 0.8526325225830078

        print((bitis1 - baslangic1) / (bitis - baslangic)) # 95.46080806942409 kat fark var arada buna dikkat etmek gerekir. her çalıştırmada değişebilir.   

numpy vektörleşmeyi destekler... klasik python listesi ise vektörleşmeyi desteklemez. neden hız farkı var çünkü numpy vektörleşmeyi destekler. listede ise bu vektörleşme yoktur.  

python listesi kullanarak NDArray oluşturmak ->  X = np.array([1,2,3,4,5,6]) # bu metota listeyi gönderince istenen yapıyı elde ederiz. bir array elde ederiz.
                                                   
        import numpy as np

        X = np.array([1,2,3,4,5])
        print(type(X)) # <class 'numpy.ndarray'>

..........................................................................................................................................................................................................


            import numpy as np

            X = np.array([1,2,3,4,5])

            print(X.shape)  # (5,) // boyut olarak bize bilgi verdi shape (5,) demek tek boyutlu 5 elemanlı demektir. bir tuple içerisinde gönderir eksendeki elemanların sayısını gösterir. 
            print(X.size)   # 5 // .size ile kaç adet eleman olduğunu görürüz. toplam eleman sayısını görürüz.
            print(X.ndim)   # 1 // array'in boyutunu bize gösterir. 1 boyutludur bu array. 
            print(X.nbytes) # 20 // veriler ne kadar byte kaplıyor görürüz.  .nbytes ile totalde kaplanan alanı görürüz. veriyi depolamak için gereken byte miktarını verir...
            print(X.dtype)  # int32 // içerisindeki elemanların veri tipini gösterir.  


..........................................................................................................................................................................................................

            import numpy as np

            Y = np.array([[1,2,3],[4,5,6],[7,8,9]]) # listelerin listesi ile bir matris elde ederiz. np.array() metotuna yollarız ve bize bir matris döner bu yapı ile.

            print(Y) 
            """             
            [[1 2 3]
            [4 5 6]
            [7 8 9]]
            
            """
                            
            print(type(Y))  # <class 'numpy.ndarray'>
            print(Y.shape)  # (3, 3) // boyut bilgisini verdi 3e 3lük bir yapısı var demektir. önce kaç adet satır olduğu sonra satırlarda kaçar eleman olduğunu yazar eğer [[1,2,3],[4,5,6]] olsa idi (2,3) verirdi
            print(Y.size)   # 9 // .size ile kaç adet eleman olduğunu görürüz. toplam eleman sayısını görürüz.
            print(Y.ndim)   # 2 // array'in boyutunu bize gösterir. 2 boyutludur bu array. yani matris diyebiliriz.
            print(Y.nbytes) # 36 // veriler ne kadar byte kaplıyor görürüz.  .nbytes ile totalde kaplanan alanı görürüz. veriyi depolamak için gereken byte miktarını verir...
            print(Y.dtype)  # int32 // içerisindeki elemanların veri tipini gösterir.  

..........................................................................................................................................................................................................

import numpy as np
y = [1,2,3,4,5,6,7,8,9]
x = np.array(y) # np.array([1,2,3,4,5,6,7,8,9]) de olur np.array(y) de olur ikiside bir array oluşturmak için gayet yeterli.
print(x)
 
..........................................................................................................................................................................................................

            import numpy as np

            Z = np.array([[[1,2],[3,4]],[[1,2],[3,4]]]) #buda üç boyutlu bir dizi oldu. içerisinde matrisler taşıyan dizi'ye 3 boyutlu dizi denir...

            print(Z)
            """
            [[
            [1 2]
            [3 4]
            
            ]
            [
                
            [1 2]
            [3 4]
            
            ]]  
                """

            print(Z.shape) #(2, 2, 2)
            print(Z.nbytes) # ne kadar byte kullandık bunu gösterir.
            print(Z.ndim) #3 verir 3 boyutlu olduğnu gösterir. 

..........................................................................................................................................................................................................

        import numpy as np

        x = np.arange(12).reshape(3,4) # 3 stır 4 sutun
        print(x)
        x = x.reshape(12) # sonra ise tekrar bu matrisi tek boyutlu bir arraye çevirdik.
        print(x)

..........................................................................................................................................................................................................

ndarray'de elemaların tamamı aynı tip olmalıdır. python listesinde heterojen olabilir ama numpy arraylerinde arrayler homojen olmalıdır.

        import numpy as np

        x = np.array([1,2,'3'])
        print(x.dtype) # <U11    U11 karakterli unicode bir string demek. içerisinde string olduğu için hepsini stringe çevirdi...

içerisine bir tane string girince tüm elemanları stringe çevirdi buna Upcasting denir. çünkü homojen bir yapı olmalıdır.
    eğer int değerler içerisine float bir değer girerse o zaman yine Upcasting olur ve hepsi float olur. bunu .dtype ile görebiliriz. 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





/////Ders 2 - Veri Tipleri - Save(), Load() veri tipi değiştirme , kaydetme ve geri çekme .npy uzantısı ile////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

her veri homojen olmalı eğer verileri içerisinde farklı bir veri tipi varsa numpy ona göre tüm arrayi ayarlar mesela 3 tane int bir tane float var tüm değerler float olur.

        import numpy as np

        x = np.array([1,2,3.0])
        print(x.dtype) # float64 verdi... buna upcasting denir tüm verileri bir üst sınıfa çıkarır.

..........................................................................................................................................................................................................
        import numpy as np

        x = np.array([1,2,3.0,'4'])
        print(x.dtype) #<U32 karakter setini verdi hepsini string galine çevirdi yani. yine bir upcasting söz konusu.

.................. dtype data type demektir. 


biz istersek eğer array'in tipini kendimiz belirleyebiliriz. mesela x = np.array([1,2,3],dtype = np.int) # ikinci parametre olarak biz dtype yolladık ve hangi tipte olacağını belirttik böylece istenen veri tipinde değerler ile array oluşturduk. np.int dememizin sebebi numpy içerisindeki veri tipinden seçeceğiz veriyi.

  python pythondosyasi.py ile istenen python dosyasını çalıştırabiliriz terminalde. 

str > float > int olarak kabul edebiliriz tiple bu sıralama ile dönüşür. 

        import numpy as np

        x = np.array([1,2,3,4],dtype=np.int8) # int 8 dmeek 8 bit yani 1 byte int 32 4 byte dmeek ama mesela int128 olursa eğer 128 bit yani 16 byte demektir... 
        print(x.dtype) # int8 olarak verir. istenen dtype ile verileri oluşturduk.

..........................................................................................................................................................................................................

        import numpy as np

        x = np.array([1,2,3,4],dtype=np.float64) 
        print(x.dtype) # float64 olarak verir tüm değerler float olarak kullanılır böylece.
        
..........................................................................................................................................................................................................


        import numpy as np

        x = np.array([1,2,3,4],dtype=np.float64) 
        print(x.dtype) # float64 olarak verir tüm değerler float olarak kullanılır böylece.
        
..........................................................................................................................................................................................................
 
        import numpy as np

        x = np.array([1,2,3,4],dtype=np.complex_)   
        print(x.dtype) # complex128 verir complex demek sanal ve reel kısmı olan sayı demek aslında. i ve j 'si olan sayılar.


...........................................................................................................................................................................................................

alt + shift + a ile imleçte olan satırları yorum satırı yapabiliriz.
...........................................................................................................................................................................................................

        import numpy as np

        x = np.array([1.5,2.5,3.6,4.3],dtype=np.int32) # veriler int olarak tutulacak. yani noktadan sonrası gidecek upcasting değil downcasting olacak. float veriden int dönüşümü yaptırdık bunu dtype ile yaptık.  
        print(x) #[1 2 3 4]
        print(x.dtype) # int 3

...........................................................................................................................................................................................................
        import numpy as np

        x = np.array([1,2,3,4],dtype=np.float64) # data type'ı dtype = ile float olarak belirledik.

        print(x)       # [1. 2. 3. 4.]
        print(x.dtype) # float64

        x = np.array(x,dtype=np.complex128) # verilerin tipini değiştirdik böylece. elde olan array ile veri tipi farklı bir array oluşturabildik. 

        print(x)       # [1.+0.j 2.+0.j 3.+0.j 4.+0.j]
        print(x.dtype) # complex128
        import numpy as np
   
    ,,,,,

    x = np.array([1,2,3,4],dtype=np.float64) # data type'ı dtype = ile float olarak belirledik.

    x = x.astype(np.complex128) # veri tipini direkt olarak bu metot ile değiştirebiliriz.   .astype(np.tür) yapısı ile istenen tipe çevirebiliriz arrayin veri tipini.

    print(x.dtype) # complex128

................................................................................................................................................................................................

        import numpy as np

        x1 = np.array([1,2,3], dtype=np.int64)
        x2 = np.array([1.4,2.6,3.6], dtype=np.float64)

        print(x1 + x2)       # [2.4 4.6 6.6]    verileri topladı kapsayıcı olan float olduğu için float değerler ile oluştu bu array
        print((x1+x2).dtype) # float64  kapsayıcı olan float olduğu için float oldu dtype... float daha kapsayıcı int'e göre bu yüzden iki arrayin toplamı float veri tipi ile oluştu.

................................................................................................................................................................................................

    import numpy as np

    x = np.sqrt([-1,9,4], dtype=np.float64) # arrayin elemanlarının kökünü alacak np.sqrt()

    print(x) # [nan  3.  2.] neden nan var hata var = bunun sebebi -1 karmaşık sayıdır. kökü alınamaz ama dtype complex olsa idi hata olmazdı.

................................................................................................................................................................................................

            import numpy as np

            x = np.sqrt([-1,9,4,-14],dtype=np.complex128) # verileri complex yaptık böylece kökü alınınca sorun olmayacak.

            print(x.real) # karmaşık sayıların reel kısmını gösterir sadece.
            print(x.imag) # karmaşık sayıların sanal kısımlarını gösterir sadece.

            print(x.real.dtype) # float64 
            print(x.imag.dtype) # float64 karmaşık sayıların değerleri float olarak tutulurmuş demekki.

................................................................................................................................................................................................
        
        import numpy as np

        x = np.array([1,2,3,4,5],dtype=np.int64)
        np.save("fordfocus",x) # np.save ile array kaydederiz. önce kaydedilecek yer sonra ise kaydedilecek değeri gireriz ve .npy uzantılı bir dosyaya değerleri kaydeder fordfocus.npy olarak

        y = np.load("fordfocus.npy") # y = dosya içerisindeki ndarray olacak aslında. np.load() parametre alacak oda arrayin kaydedildiği .npy dosyası.

        print(y) # [1 2 3 4 5]
       
        np.save("dosyaadi",kaydedilecekarray) ile kaydederiz ndarrayi bir .npy dosyasına      y = np.load(.npy dosyasınınadi ve uzantısı) ile ise kaydedilmiş arrayi geri çıkartırız. return ederiz yani.

................................................................................................................................................................................................

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





///////Ders 3 - Gömülü Fonksiyonlar I, ones, zeros, diag, eye...//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

hazır fonksiyonlar ile içeriye bir liste koymadan ndarray oluşturacağız. mesela x = np.arange(100) ile 0'dan 99'a kadar 99 dahil 100 elemanlı bir array oluştururuz...

    import numpy as np

    X = np.zeros(5) # 5 adet 0'dan oluşan bir array elde ederiz. np.zeros() ile oluşan array'in veri tipi float64'tür .dtype bize float64 verir.. 
    Y = np.ones(5) # 5 adet 1'den oluşan bir array elde ederiz. np.ones() ile oluşan array'in veri tipi float64'tür .dtype bize float64 verir.. 

................................................................................................................................................................................................

        import numpy as np

        X = np.zeros((2,3,4),dtype= np.int64) # içerisine bir tuple yollarız zeros metotunun. # 2 adet matris üret 3 satırdan oluşsun her matris ve satırlarda 4 eleman olsun demek (matrissayisi,satirsayisi,sutunsayisi)

        print(X)
        """
        [[[0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]]

        [[0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]]]    
            
            """

................................................................................................................................................................................................

  nedens ones, zeros gibi metotlar kullanırız. numpy için önemli olan gelecek olan verilerdir. yapay zeka, makine öğrenmesi veri bilimi alanlarının temelinde veri manipülasyonu yatar. 

np.full() # bunun ile istenen sabit sayının olduğu bir array oluşturabiliriz.

        import numpy as np

        x = np.full((2,3),10) # 2 satır 3 sutun olsun içerisinde 10 olsun tüm elemanlar 10 olsun demektir.  veri türü ise int32 oldu. nedeni ise 3. parametre olarak gönderilen değerin veri tipi kullanılır 10.0 verse idik o zaman dtype float olacaktı. (2,3) olarak ise bir tuple içerisinde biz ndarrayin yapısını belirledik.

        print(x)

        """
        [[10 10 10]
        [10 10 10]]
            
            """

................................................................................................................................................................................................

        import numpy as np

        x = np.full((2,3),10.0) # (2,3) ile oluşacak arrayin yapısını belirttik. üçüncü parametre ile ise hangi değer ile donatılacak belirttik.
        y = 10.0 * np.ones((2,3)) # 2 satır 3 sutundan oluşan bir matris olacak her eleman 10.0 ile çarpılacak.
        z = 10.0 + np.zeros((2,3)) # 2 satır 3 sutundan oluşan bir matris ve her değer 10.0 ile toplanacak yani her değeer 10.0 olacak
        print(y)
        """
        [[10. 10. 10.]
        [10. 10. 10.]]    
            """

................................................................................................................................................................................................


mesela arrayismi += 10 demek örnek olarak x = np.array([1,2,3,4,5,6]) demek ve sonraki satır x += 10 demek her elemana 10 eklemek demektir. kalıcı bir işlemdir   y = x + 10 demek x'in elemanlarını 10 fazlalaşmış hali demek ama x'de değişim olmaz x += 10 olursa eğer o zaman x kalıcı değişime uğrar.

        import numpy as np

        x = np.array([1,2,3,4,5])
        x += 10
        print(x) # [11 12 13 14 15]

................................................................................................................................................................................................

np.empty() #  bu fonksiyon ile hafızada ndarray oluştururuz hafızada yer ayırırız ama elemanların değerini vermeyiz keyfi değerler bulunur.

    import numpy as np

    x = np.empty((2,3)) # içerisine bir tuple yolladık ve yapısını belirledik. içerisinde bir tuple göndeririz ve bu tuple ile ndarrayin yapısını belirleriz.
    print(x)
    """
    [[9.34577196e-307 9.34598246e-307 1.60218491e-306]
    [1.69119873e-306 1.24611673e-306 1.05699581e-307]]
    """ # görüldüğü gibi bellekte yer ayrıldı ancak değerler rastgele değerler...

    x.fill(10) # bununla birlikte ndarray'in elemanlarının hepsini 10 yaptık... boş olan bir array'i böylece doldurmuş olduk.

................................................................................................................................................................................................

ndarray.fill(sayi) metotu ile bir array'in tüm elemanlarını istenen sayı yapabiliriz. 

................................................................................................................................................................................................

import numpy as np 
x = np.eye(4) # birim matris oluştururuz np.eye() ile diogonal olanlar 1 olmayanlar 0 olan matris oluştururuz.

        import numpy as np

        x = np.eye(4)
        print(x)
        """
        [[1. 0. 0. 0.]
        [0. 1. 0. 0.]
        [0. 0. 1. 0.]
        [0. 0. 0. 1.]]

        """ # np.eye() ile birim matris oluştururuz.

        y = np.eye(4,5) # 4 satır 5 sutunlu bir matris oluşturur. ve olabildiğince birim matris olmayaca çalışır. 

................................................................................................................................................................................................

        import numpy as np

        x = np.eye(4,5)
        print(x)
        """
        [[1. 0. 0. 0. 0.]
        [0. 1. 0. 0. 0.]
        [0. 0. 1. 0. 0.]
        [0. 0. 0. 1. 0.]]
        
        """  # eye ile olabildiğince diogonal matris oluşturur. eğer satır sutun eşit değilse.

................................................................................................................................................................................................
    import numpy as np

    x = np.eye(6)
    print(x)
    print("")
    y = np.eye(6,k = 1) # k = 1 olunca diegonali 1 birim yukarı aldı -2 olsa idi 2 birim aşağı inecekti.
    print(y)
    """
    [[0. 1. 0. 0. 0. 0.]
    [0. 0. 1. 0. 0. 0.]
    [0. 0. 0. 1. 0. 0.]
    [0. 0. 0. 0. 1. 0.]
    [0. 0. 0. 0. 0. 1.]
    [0. 0. 0. 0. 0. 0.]]
    
    """
................................................................................................................................................................................................

            import numpy as np

            x = np.identity(5)
            print(x)
            """
            [[1. 0. 0. 0. 0.]
            [0. 1. 0. 0. 0.]
            [0. 0. 1. 0. 0.]
            [0. 0. 0. 1. 0.]
            [0. 0. 0. 0. 1.]]
            """ # 5 e 5 birim matris oluşturur...

................................................................................................................................................................................................

        import numpy as np

        x = np.diag([4,7,11,3]) # içerisine bir array göndeririz.
        print(x)
        """
        [[ 4  0  0  0]
        [ 0  7  0  0]
        [ 0  0 11  0]
        [ 0  0  0  3]]
            
            """ # np.diag(liste) # listenin elemanlarını diegonale yerleştirir ona göre bir matris oluşturur... o çizgi üzerinde yerleşir elemanlar.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





////Ders 4 - Gömülü Fonksiyonlar II, arange - linspace, reshape, random/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

x = np.arange(5) # 0'dan başlar 5 tane elemandan oluşan bir array oluşturur.. 5 dahil değil. 0 1 2 3 4 gibi.

y = np.arange(0,6,2) # 0dan başlar 5'e kadar oda dahil ikişer ikişer atlar ve bir array oluşturur.

                import numpy as np

                x = np.arange(10) # 0 1 2 3 4 5 6 7 8 9... 10 dahil değil. default olarak artım miktarı ise birdir. yarı açık bir aralık var.
                y = np.arange(5,10) # 5 dahil 10'a kadar 10 dahil değil bir array oluşturur. [5,10)
                z = np.arange(6,19,3) # 3. parametre ise artım miktarı olacak. [6,19) arasında 3er 3er artım olacak. 18 dahil 19 değil o aralıkta kapsayabildiğini alacak.

............................................. arange genellikle tamsayılar için kullanılır.

        import numpy as np

        x = np.linspace(0,15,10) # ilk argüman başlangıc noktası ikincisi bitiş noktası, 3. parametre ise kaça bölüneceği 10 olarak girdik 3. parametreyi 10 tane sayı elde edeceğiz. 
        # linspace fonksiyonunda kapalı fonksiyon vardır yani 0 ve 15 dahil [0,15] olarak geçer başlangıç ve bitiş dahildir.
        # tek boyutlu bir array getirir bize.
        # eğer 3. parametre olarak kaç adet eleman üretileceğini belirtmezsek default olarak 50 kabul edilir.

................................................................................................................................................................................................
  
  import numpy as np
  x = np.linspace(0,15,100,endpoint=False) # eğer endpoint False dersek o zaman bitiş noktası dahil olmaz. böylece son kısım açık aralık olur [0,15) olur. 

................................................................................................................................................................................................

        import numpy as np

        x = np.arange(20) # 20 elemalı tek boyutlu bir array 0'dan başlayacak. çünkü numpy sıfırdan numaraladırma yapar.
        x = np.reshape(x,(4,5)) # 4 satır 5 sutun. Önce hangi arrayi değiştireceğimizi sonra tuple içerisinde satır sutunu verdik. 5'e 5 versek hata verirdi çünük eleman sayısı yetersiz.
                          # np.reshape(x,(2,2,5)) # dese idik. 2 tane matris olacaktı ve her matris 2 satır 5 sutundan oluşacaktı.
        print(x)
        """
        [[ 0  1  2  3  4]
        [ 5  6  7  8  9]
        [10 11 12 13 14]
        [15 16 17 18 19]]
        """

................................................................................................................................................................................................

import numpy as np

x = np.arange(20)
x = np.reshape(x,(4,5)) # önce hangi array shape olacak sonra ise tuple içerisinde hangi yapıda olacak ve bu elde edilen yaoıyı return eder.
# x = np.arange(20).reshape(4,5) de olabilirdi...

................................................................................................................................................................................................

        import numpy as np

        x = np.arange(20).reshape(4,5) # 20 elemalı tek boyutlu bir array 0'dan başlayacak. çünkü numpy sıfırdan numaraladırma yapar. eğer sutun sayısı 5 ise ilk 5 ilk satır sonraki 5'li diğer satır şeklinde sıralı olarak böler.
        print(x) # reshape() ise içerisine tuple ve parçalanacak array gönderilmeden de kullanabiliriz. bu yapıda. içerisinde sayıları göndeririz ve bölme işlemini uygularız.
        """
        [[ 0  1  2  3  4]
        [ 5  6  7  8  9]
        [10 11 12 13 14]
        [15 16 17 18 19]]   
        """
................................................................................................................................................................................................

        import numpy as np

        x = np.random.random(10) # 10 tane sayı üretir. 0 ile 1 arasında 1 dahil değil.
        print(x) #[0.57100026 0.72277628 0.42328953 0.37058981 0.44240555 0.66137003 0.28446727 0.84857043 0.29600169 0.17329597]

...............................................

        import numpy as np

        x = np.random.random((2,3)) # 2 satır 3 sutundan oluşan bir matris elde ederiz sayılar ise 0 ile 1 arasında rastgele sayılar olur. 1' e eşit olmaz. random içerisine biz tuple olarak göndeririz ndarray'in yapısını.
        y = np.random.randint(4,50,size = (2,3))  # 4den başla 50 dahil değil aralıkta rastgele bir array oluştur. size  ile nasıl bir yapıda olacağını belirtiriz. size = 5 desek tek boyutlu bir array oluştururuz. ama mesela shape ile ilgili bir işlem yapacaksak ve tek boyutlu olmayacaksa genellikle () tuple içerisnde gönderilir.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






/////Ders 5 - NDArray Değiştirmek, Insert, Append, Stack, Delete////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   

....................................................

        import numpy as np

        x = np.arange(5) # arraylar normal listeler gibi 0 index ile başlarlar.
        print(x[0]) #  ilk elemanı görebiliriz. 
        print(x[1]) # 2. elemana ulaşabiliriz. 
        print(x[x.size - 1]) # en son elemana ulaşabiliriz. x.size ile kaç tane eleman varsa görürüz ve -1 deriz indexleme 0'dan başlar çünkü.
        print(x[-1]) # en son elemana ulaşırız. negatif index olunca tersten -1 ile başlar -2 demek en sondaki 2. eleman demek. 5 elemanlı bir array ile -5 ile en baştaki elemana en sondan ulaşmış oluruz.
        print(x[-2]) # en sondan ikinci elemanı getirecek.
        print(x[2:]) # 2. indexteki elemandan en sona gitmek demektir. arrayi parçalarız.

        x[2] = 200 # bunu diyerek direkt atama ve değişim yapabiliriz. 2. indexteki yani 3. eleman 200 olur.
        x += 10 # bununla birlikte tüm elemanlar 10 artar. eğer x'i kullanarak yani arrayi kullanarak işlem yaparsak o zaman tüm elemanlar etkilenir ama eğer biz belli aralıktakileri veya tek bir değeri belirtirsek sadece o kısım değişir.
        x *= 2 # bununla birlikte tüm elemanlar 2 ile çarpılır

....................................................

        import numpy as np

        x = np.arange(20)
        x[3:7] = 100
        print(x) # [  0   1   2 100 100 100 100   7   8   9  10  11  12  13  14  15  16  17 18  19]
        # belli bir aralıktaki değerlere atama yaptık.

....................................................

        import numpy as np
 
        x = np.arange(12).reshape(3,4) # 12 tane elaman oluşur ve 3 satır 4 sutun olarak oluşur.
        print(x[0]) # 0 indexteki satır gelir yani birinci satır gelir.
        print(x[0,0]) # 0 indexteki satırın 0 indexteki elemanı gelir yani 1. satırın 1. elemanı gelir.
        print(x[2,3]) # 2 .indexteki satırın 3. indexteki elemanı gelir yani en sağ alttaki eleman gelir.
        print(x[2]) # en sondaki satırı getirir. pointer mantığı ile ilerler.
        print(x[1,2]) # 2. satırın 3. elemanını getirir.  
        x[0,0] = 100 # ilk satırın ilk elemanı 100 olur atama yaparız.

....................................................


        import numpy as np

        x = np.arange(6)
        print(x) # [0 1 2 3 4 5]
        y = np.delete(x, [0,1]) # x arrayinin 0. ve 1. indexteki elemanlarını silecek. eğer orjinali değiştirmek  istersek o zaman y yerine x derdik direkt olarak değişim yapardık.
        print(y) # [2 3 4 5]

....................................................

axis = 0 olursa row yani satır
axis = 1 olursa column yani sutun demektir. 

....................................................

        import numpy as np

        x = np.arange(16).reshape(4,4) 

        print(x)

        """

        [[ 0  1  2  3]
        [ 4  5  6  7]
        [ 8  9 10 11]
        [12 13 14 15]]
        
        """

        y = np.delete(x,1,axis=0) # axis 0 olduğu için 1. indexteki yani 2. satırı siler. ama axis = 1 olsa idi 2. sutunu silerdi.
        print(y)

        """
        [[ 0  1  2  3]
        [ 8  9 10 11]
        [12 13 14 15]]
        
        """

        z = np.delete(x,1,axis=1) # axis 1 olduğu için sutun silecek ve yeni array oluşturacak. sonra atama olacak.
        print(z)
        """
        [[ 0  2  3]
        [ 4  6  7]
        [ 8 10 11]
        [12 14 15]]

        """
        
        t = np.delete(x,[1,3],axis=0) # 1. ve 3. indexteki satırları sildi satırlaro silmesinin sebebi ise axis = 0 diye.
        print(t)

        """
        [[ 0  1  2  3]
        [ 8  9 10 11]]

        """

        p = np.delete(x,[1,3],axis=1) # 1 . ve 3. indexteki sutunları sildi. sutun silmesinin sebebi ise axis = 1 diye
        print(p)
        """
        [[ 0  2]
        [ 4  6]
        [ 8 10]
        [12 14]]

        """


....................................................

        import numpy as np


        # np.append() bu fonksiyonu kullanıdığımızda buı işlemi yapacağımız matrislerin bu işleme uygun olması gerekir. önce parametre olarak değişecek olanı alır arrayi alır  yani sonra ne eklenecek onu yazarız en sona ekleme yapar.

        x = np.arange(5)
        print(x) # [0 1 2 3 4]
        x = np.append(x,100) # eleman alacak olan rray ve hangi değerin ekleneceğini girdik. en sona ekler.
        print(x) # [  0   1   2   3   4 100] 
        x = np.append(x,[100,200,300]) # birden fazla değer eklemek istersek eğer bir liste içerisinde yollayacağız.
        print(x) # [  0   1   2   3   4 100 100 200 300]

        y = np.arange(9).reshape(3,3) # sırası ile oluşacak bu matris ilk 3 eleman ilk satıra sonraki 3 eleman sonraki satıra olacak şekilde olacak.

        y = np.append(y,[[100,200,300]],axis=0) # axis 0 olduğu için satıra ekleme yapacağız. satıra ekleme yapacağımız için sutun eleman sayısına göre ekleme yapacağız.
        print(y)

        """
        [[  0   1   2]
        [  3   4   5]
        [  6   7   8]
        [100 200 300]]
        
        """

        y = np.append(y,[[77],[77],[77],[77]],axis=1) # sutuna eleman ekleyeceğiz 4 satır olduğu için 4 tane eleman eklememiz lazım. bu sutun en sondaki sutun olacak. her sutun elemanı tek tek bir liste içerisinde yollandı çünkü aslında tek tek satır ekliyoruz. 
        print(y)

        """
        [[  0   1   2  77]
        [  3   4   5  77]
        [  6   7   8  77]
        [100 200 300  77]]

        """
        
....................................................

        import numpy as np

        x = np.arange(20)
        x = np.insert(x,5,[100,100,100]) # np.insert() bir array return eder. ilk parametre işlem görecek ndarray. ikinci parametre ise index hangi index veya hangi indexten başlayacak ekleme birden fazla eleman varsa. 3. parametre ise hangi eleman veya elemanlar birden fazla eleman eklenecekse o zaman 
        print(x) # [  0   1   2   3   4 100 100 100   5   6   7   8   9  10  11  12  13  14 15  16  17  18  19]  5.indexten itibaren yerleştirdi elemanları.

....................................................
  
        import numpy as np

        x = np.arange(9).reshape(3,3)
        x = np.insert(x,1,[100,100,100],axis=0) # axis 0 olduğu için satıra ekleme olacak. ilk olarak işlem görecek olanı gireriz sonra index sonra ne eklenecek sonra axis ve np.insert() bize işlemden çıkmış arrayin referansını return eder. atama olduğu için referans kalır bellekten silinmez. eklenen eleman sayısı ise sutun sayısı ile aynı olmalı. axis = 1 olsa idi o zaman satır sayısı kadar eleman eklememiz gerekirdi.
        print(x)
        """
        [[  0   1   2]
        [100 100 100]
        [  3   4   5]
        [  6   7   8]]
        
        """

....................................................

        import numpy as np

        # np.stack() vstack(vertical = dikey) ve hstack(hortizonal = yatay) olarak kullanacağız.

        x = np.arange(3)

        y = np.arange(9).reshape(3,3)

        print(y)

        """

        [[0 1 2]
        [3 4 5]
        [6 7 8]]
        
        """

        z = np.vstack((x,y)) # x'i y'ye dikey olarak ekle demek. x'i y'nin en üstüne yerleştirir. ilk satıra satır olarak yerleştirir.
        print(z)

        """
        [
        [0 1 2]
        [0 1 2]
        [3 4 5]
        [6 7 8]]
        
        """

        t = np.hstack((x,y.reshape(9,))) # x'i y'ye yatay olarak ekle. y = y.reshape(9,0) yapabilirdik bir satır yukarıda. ama direkt olarak içeride de y.reshape(9,0) yaparak 9 elemanlı tek boyutlu bir array haline çevirebiliriz 2 boyutlu bir arrayi.
        print(t)

        """
        [0 1 2 0 1 2 3 4 5 6 7 8] # y.reshape(9,0) diyerek tek boyutlu hale çevirdik ve öyle yatay ekleme yaptık x'in elemanlarını y'nin en başına ekledi.
        """
....................................................

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








////Ders 6 - Slicing - copy()/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        import numpy as np

        # ndarray[başlamanoktası:end(dahil değil):artış miktarı], ndarray[start:] başlama elemanında sona kadar git demektir. ndarray[:end] başlangıç noktasından ende kadar ama end dahil değil.

        x = np.arange(10)
        y = x[5:] # x'in bir bölümünü alır ve bir array oluşturur bunuda y'ye atar y'de bir array olur.
        print(type(y)) #<class 'numpy.ndarray'>

        print(x[:6]) # 6. indexe kadar gidecek 6 dahil değil. başlangıç noktasından itibaren. arrayden bir array oluşturur. 

        print(x[::-1]) # en sondan en başa teker teker gel demek.
        print(x[-1::-2]) # en sondan en başa ikişer ikişer gel demek -1 olsa idi tek tek gel demek olurdu.

        print(x[-4:-2]) # en sondan 4. elemandan en sondan 2. elemana ama en sondan 2. eleman dahil değil.

        t = np.arange(25).reshape(5,5)
        print(t)
        """
        [[ 0  1  2  3  4]
        [ 5  6  7  8  9]
        [10 11 12 13 14]
        [15 16 17 18 19]
        [20 21 22 23 24]]
        
        """

        print(t[:2]) # birinci satırı ve ikinci satırı getirir. pointer mantığı ile eleman aslında satırdır. ilk olarak girilen satırdır 2:4,1:3 bu parametrelerde eğer sutun bilgisi vermezsek o zaman satırlar üzerinden işlem yaparız.

        """
        [[0 1 2 3 4]
        [5 6 7 8 9]]
        
        """

        print(t[:2,2:]) # satır ve sutun ayrı olarak işlem olacak :2 satır başlangıç satırından 2. satıra kadar 2.satır dahil değil VE 2. sutundan sonuncu sutuna kadar son dahil olan aralığı al demek.

        """
        [[2 3 4]
        [7 8 9]]

        """

        print(t[:,1:4]) # tüm satırlar dahil sutun olarak ise 1. indexten 4. indexe 4 dahil değil.

        """
        [[ 1  2  3]
        [ 6  7  8]
        [11 12 13]
        [16 17 18]
        [21 22 23]]
        
        """

        print(t[:,:]) # satırlar ve sutunlar için bir kısıtlama yok t'nin aynısı olur.

        """
        [[ 0  1  2  3  4]
        [ 5  6  7  8  9]
        [10 11 12 13 14]
        [15 16 17 18 19]
        [20 21 22 23 24]]
        """



        u = np.arange(9).reshape(3,3)
        print(u)

        """
        [[0 1 2]
        [3 4 5]
        [6 7 8]]

        """

        i = u[1:2,0:2] # 1. satır olacak ve sutunlardan ise 0. ve 1. index dahil olacak.
        print(i)
        """
        [[3 4]]

        """

        u[1,1] = 100 # 2.satır 2.sutundaki eleman 100 oldu.   : işareti ile aralık belirleriz. , ile ise satır sutun belirlemesi yaparız.
        i[0,0] = 333 # ilk satır ilk sutundaki eleman 333 oldu...
        print(u)
        """
        [[  0   1   2]
        [333 100   5]
        [  6   7   8]]

        """ # u'nun bir parçası olan i üzerinde işlem yapmamıza rağmen u'da değişim oldu bunun nedeni referanslar ile bellek adresleri ile işlem yapmak. aslında bellek adresinin bir kısmını alıp array olarak atıyoruz. bu yüzden parçada olan değişim ana arraydede etki eder çünkü o bellek alanı üzerinde değişim oldu. pointer mantığı. 

        print(np.shares_memory(u,i)) # aynı bellek adresinde mi çalışıyorlar True verir... hafızadaki yerleri aynı ortak elemanların bu yüzden yapılan bir değişim diğerinede etki ediyor.

        # farklı bellek adresleri olsun istersek o zaman .copy() metotunu kullanacağız...


        g = np.arange(16).reshape(4,4)

        h = np.copy(g[:3,1:4]) # g'den kopyala ve yeni bir yere ata. değerler farklı bellek gözlerinde olsun istiyoruz. np.copy() bize bir array referansı return eder.
        print(h)
        """
        [[ 1  2  3]
        [ 5  6  7]
        [ 9 10 11]]
        
        """

        print(np.shares_memory(g,h)) # False verir çünkü değerleri aynı bellek adreslerinde saklamıyor. .copy() ile sadece değerler alınır bellek adreslerinin farklı olması sağlanır.  

        j = g[:,2:].copy() # elde edilen array'i copy ile farklı bellek gözlerindeki bir yere atarız. .copy() ile direkt olarak böylece iki array'in elemanlar farklı bellek adreslerinde olur ve bellekte elemanların kesişimi olmaz.
        
        # birbirinden farklı ama elemanları aynı veya bir bölümü alınmış referansları farklı arrayler için .copy() metotunu kullanmak gerekir. 
        
        # satır ve sutun birimleri , ile ayrılır. aralık ise : ile belirlenir.  mesela x[:,3:] tüm satılar dahil demek ama sutun 3.indexten itibaren sona kadar demek yani her satırın ilk 3 elemanı hariç bir array olur bu.
        
        # ndarrayler referanlar ile çalışır x = np.arange(20) mesela y = x olsun y[:] = 100 olursa x'inde y'ninde tüm elemanları 100 olur. 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





////Ders 7 - Fancy, Boolean Indexing/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import numpy as np

        x = np.linspace(1,21,11)
        print(x) # [ 1.  3.  5.  7.  9. 11. 13. 15. 17. 19. 21.]
        y = np.array([2,4,7])
        print(x[y]) # [ 5.  9. 15.] bu ne demek = x'in içindeki y değerlerindeki indexlerden oluşan değerlerden bir array elde et ve getir demek. yani bir array halinde gitti y buraada her değeri bir işlem gördü ve bir array döndürdük.    y bir sayı içeren array ve sayılar index olarak kabul edildi.
 
        t = np.arange(25).reshape(5,5)
        print(t)
        z = np.array([1,2])
        print(t[z,:]) # satırlarda z yani 1. index ve 2. index sutunlarda ise hepsini alacağız. z'nin tüm değerleri işlem görecek ve indexleme için kullanılacak.
        """
        [[ 5  6  7  8  9]
        [10 11 12 13 14]]
        
        """

        u = t[z,:] 
        print(np.shares_memory(u,t)) # False verir. .copy() demekse bile. bir arrayi başka bir arrayin yardımı ile slicing ettiysem eğer o zaman bellekteki farklı bir yerde değerleri konumlandırır.


        u[0,0] = 1000
        print(t) # bir değişim olmadı .copy() ile içerik üretmediğimiz halde. bir ndarrayi başka bir ndarray ile slicing ettiysek eğer o zaman oluşan array bellekte ana arrayden farklı bir yerde oluşur.

        # fancy indexing... bir arrayi eğer başka bir array ile elde ediyorsak buna denir. bir arrayin alt kümesine başka bir array sayesinde ulaşırız ve oluşan array orjinal arrayden bağımsız olur bellek ortaklıkları olmaz.   .copy() ile oluşmuş gibi olur.

....................................................

        import numpy as np

        x = np.arange(20)
        z = x % 2 == 0
        print(z) # [ True False  True False  True False  True False  True False  True False True False  True False  True False  True False]
        print(x[z]) # [ 0  2  4  6  8 10 12 14 16 18] biz eğer x[(x % 2 == 0)] yaparsak aslında x[] içerisine bir array gelir x % 2 == 0 ile .True ve False den oluşan bir array ve arrayin her elemanı tek tek işlem görür True ile eşleşenler yeni arraye gelir. False ile eşleşenler ise es geçilir.    x % 2 == 0 yapısı bize True ve Falselerden oluşan bir array return eder.

....................................................

        import numpy as np

        # boolean indexing 

        x = np.arange(10)
        print(x) # [0 1 2 3 4 5 6 7 8 9]
        print(x[(x % 2 == 0)]) # [0 2 4 6 8] bana x'in elemanlarından 2 ile bölümü sıfır olanları bir array içerisinde dönder demek.

        z = x[(x % 2 == 0)]
        z[0] = 100 # z üzerinde yapılan değişim ana arrayi etkilemez çünkü bellek alanları farklı 
        # slicing ile yapılan işlemde bellek ortak kullanılır ama fancy ve booelan indexing'de bellek alanları farklı olur oluşan arraylerde.
        print(np.shares_memory(x,z)) # False verir. boolean indexing ile oluşan alt küme ana arrayden bağımsızdır. farklı bellek adresinde oluşur. 
           
        # boolean indexing bir array'e içerisi True ve False ile dolu array yollarız ve True ile eşlesen alınır False olan es geçilir booelan indexing ile elde edilen array ile ana arrrayin bellekteki referansları farklıdır. 

        u = np.random.randint(0,10,size=10)
        i = np.random.randint(0,10,size=10)
        print(u > i) # [ True  True False  True False  True False  True False  True] her eleman üzerinde karşılaştırma oldu. ve koşulan uyanlar True uymayanlar ise False verdi.
        print(type(u > i)) # <class 'numpy.ndarray'> class'ı ise ndArrayDir.
        print((u > i).dtype) # bool boolean veri tipi ile oluşmuştur oluşan yeni array.
 
        print(np.all(u > i)) # False eğer u'nun elemanlarının tamamı i'den büyük olsa idi yani koşulu sağlasa ve homojen bir array elde etseydi True olurdu.
        print(np.any(u > i)) # True eğer bir tane bile homojenliği bozan eleman varsa True verir.


....................................................

        import numpy as np

        x = np.linspace(1,21,11)
        print(x)
        mask = x % 3 == 0  
        print(type(mask)) # <class 'numpy.ndarray'>
        print(mask) # [False  True False False  True False False  True False False  True]   mask = x % 3 == 0 yaparsak eğer boolean bir array elde ederiz 3e bölümmden kalan 0 olanlar True olmayanlar False olur ve böyle bir array elde ederiz.
        print(x[x % 3 == 0]) #[ 3.  9. 15. 21.]
        print(x[mask]) # [ 3.  9. 15. 21.] x üzerinden tüm mask elemanlarını geçirir ve True olanlarla koşulu sağlayanlar ile bir array oluştururuz.
        x[mask] = -3 # True olanları -3 olarak değiştirdi. maskeleme yaptı...   ana array zaten x olduğu için yapılan değişiklik x'e etki eder.
        print(x) # [ 1. -3.  5.  7. -3. 11. 13. -3. 17. 19. -3.] # koşulu sağlayanlara -3 atandı.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


size = (9,) demek tek boyutlu 9 elemanlı demektir.


////Ders 8 - Grup İşlemleri, Sıralama/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import numpy as np

        # grup ve küme işlemleri... set operations. genellikle iki tane arrayi karşılaştırırken kullanırız.

        x = np.array([2,5,3,6,9])
        y = np.array([6,1,8,7,3])
        z = x[x > y] # x'in içindeki ve sırası ile indexler karşılıklı olarak karşılaştırınca koşulu sağlayan elemanlardan oluşan bir array elde ederiz.
        print(z) # [5 9]
        t = x > y # olursa tek tek tüm elemanları index sırasına göre kontrol eder ve bir array döner bu işlem x'in elemanı büyükse o zaman True değilse False vererek bir array oluşturur.

        print(np.intersect1d(x,y)) # [3 6] ortak elemanlardan oluşan yani kesişimden oluşan bir array getirir. iki arrayin kesişiminden array oluşturur.

        t = np.intersect1d(x,y)
        print(type(t)) # <class 'numpy.ndarray'>  bir ndarray döner yanii.


        print(np.setdiff1d(x,y)) # [2 5 9] x'de olan ancak y'de olmayan elemanları bize gösterecek... bir array geri dönecek. x'den kesişimi çıkaracak.
        print(np.setdiff1d(y,x)) # [1 7 8] y'de olan x'de olmayan elemanları bir array içerisinde return edecek. y'den kesişimi çıkaracal

        print(np.union1d(x,y)) # [1 2 3 5 6 7 8 9] iki arrayin birleşiminden elde edilen elemanlardan oluşan bir array döndürür. neden 8 eleman var çünkü kesişim iki kere yazılmadı bir kere olacak.

        print(np.in1d(x,y)) # [False False  True  True False] x'de olan bir elemanın y'de olup olmadığını bir array içerisinde True False biçiminde tutacak ve bunu döndürecek. eğer y,x yapsa idik y'de olup x'de olmayan elemanlar False olanlar True alacak ve bir array oluşacaktı.

....................................................

        import numpy as np


        x = np.array([2,5,3,6,9,4,3,6,5,0])
        print(np.unique(x)) # [0 2 3 4 5 6 9] tekrarlardan arındırılmış bir halde bize getirdi elemanları. set gibi düşünebiliriz.

        # sorting... (sıralama).

        y = np.random.randint(1,10,size = (10,)) # size = (10,) diyerek tek boyutlu 10 elemanlı bir array oluştur dedik.
        print(y) # [2 5 3 5 5 4 1 7 5 8]
        print(np.sort(y)) # [1 2 3 4 5 5 5 5 7 8] küçükten büyüğe sıralama yapar. sıralanmış arrayi return eder. y'de değişim olmaz ayrı bir array oluşturur.
        print(y) # [2 5 3 5 5 4 1 7 5 8] görüldüğü gibi np.sort() yapısı ana arrayde bir değişim yapmadı. sıralanmış bir array return eder ama kalıcı bir değişim yapmaz.


        u = np.random.randint(1,10,size = (10,))
        print(u) # [4 2 2 9 6 6 2 9 7 3]
        u.sort() # sıralama yaparız ve kalıcı olarak değişir u.  eğer i = u.sort() deseydikte u sıralanmış olacaktı çünkü direkt olarak bellekteki veriler üzerinden sıralama yapar.
        print(u) # [2 2 2 3 4 6 6 7 9 9]

....................................................

        import numpy as np

        x = np.random.randint(1,10,size=(5,5)) # size = (5,5) 5 satır 5 sutundan oluşsun dedik bir matris oluşturacak.
        print(x)
        """
        [[4 4 1 1 5]
        [9 1 4 8 7]
        [2 6 9 8 9]
        [7 2 4 3 6]
        [3 1 4 5 2]]
        """ 
        print(np.sort(x,axis=0)) # axis = 0 olursa sutunları kendi arasında sıralar(aynı sutun farklı satırlardaki elemanları sıralar) ama eğer axis = 1 olursa o zaman satırları kendi arasında sıralar(aynı satırdaki ama farklı sutunlardaki elemanları sıralar.).
        """
        [[2 1 1 1 2]
        [3 1 4 3 5]
        [4 2 4 5 6]
        [7 4 4 8 7]
        [9 6 9 8 9]]
        """



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








///Ders 9 - Matematiksel İşlemler,aritmetik işlemler, element-wise vs array-wise//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import numpy as np

        # element = wise. toplama işlemi vey herhangi bir işlem yaptığmızda ndarraylerin her bir elemanı diğer ndarrayin elemanı ile toplanır yani bir arrayin tüm elemanları etkilenir.
        # array wise = ndarrayin tamamının etkilendiği işlemler.

        x = np.random.randint(1,10,size = (5,))
        print(x) # [3 2 9 9 8]
        y = np.random.randint(1,10,size = (5,))
        print(y) # [2 1 9 7 2]
        print(x+y) # [ 5  3 18 16 10] tüm elemanların aynı indexli olanları toplanır ve bir array elde edilir.
        print(np.add(x,y)) # [ 5  3 18 16 10] direkt olarak numpy ilede toplama yapabiliriz bir array return eder aynı indexli olanlar toplanır.
        print(type(x+y)) # <class 'numpy.ndarray'>  operatör kullanıncada bir array elde edilir.
        print(x-y) # x'in elemanlarından index sıralaması ile y'nin elemanları çıkar ve yeni bir array elde edilir.
        print(np.subtract(x,y)) # sırası ile x'den y cıkar indexi aynı olanlar çıkar ve yeni bir array döner.
        print(x * y) # index sırası ile tüm elemanlar çarpılacak
        print(x / y) # index sırası ile x'in elemanları y'nin elemanlarına bölünecek.
        print(np.multiply(x,y)) #index sırası ile tüm elemanlar çarpılacak ve bir array return edecek
        print(np.divide(x,y)) # index sırası ile x'in elemanları y'nin elemanlarına bölünecek. ve bir array dönecek.


....................................................

        import numpy as np


        x = np.random.randint(1,10,size = (5,))
        print(x) # [6 7 2 4 5]
        y = np.random.randint(1,10,size = (5,))
        print(y) # [2 1 9 7 2]

        print(x * 10) # [60 70 20 40 50] x'in tüm elemanları 10 ile çarpılacak ve bir array dönecek bu işlem.
        x *= 10 # bunu yaparsak eğer kalıcı olarak x'in tüm elemanları 10 ile çarpılmış olacak tek tek.
        print(x) # [60 70 20 40 50]
        print(x - 3) # bir array döner ve tüm elemanlardan tek tek 3 çıkarılır. kalıcı olsun istersek eğer o zaman x -= 3 yapmamız lazım
        print(x + 3) # bir array döner tüm elemanlar tek tek 3 ile toplanır. kalıcı olsun istersek eğer o zaman x+=3 yapmamıız lazım
        print(x / 3) # bir array oluşur ve tüm elemanlar 3'e bölünür. eğer kalıcı olsun istersek o zaman x /= 3 yaparız.

        print(x == y) # Kontrol öperatorü. x'in ve y'nin elemanlarını birbirine eşit olup olmadığını kontrol edeceğiz. bir array oluşacak ve elemanlar True False olacak kontrol operatörü ile işlem yaptığımız için. aynı indexteki elemanlar karşılaştırılacak ve aynı indexte eşit olanların indexine True değilse False verilecek.

....................................................

        import numpy as np


        x = np.random.randint(1,10,size = (5,))
        print(x) #
        y = np.random.randint(1,10,size = (6,))
        print(y) #

        print(x == y) # eğer arraylerin eleman sayısı aynı olmazsa hata verir. elementwise comparison failed hatası alırız
        print(x + y) # buda hata verir. ValueError alırız. aritmetik işlem yaparken yaparken boyutlar ve eleman sayıları aynı olmalıdır. 2 koşulda sağlanmalıdır aritmetik işlem yaparken veya broadcastlable olmalı.

        # aritmetik ve element wise işlem olması için boyut ve eleman sayııs eşit olmalıdır. başka bir yolu var broadcasting gibi...

        t = np.array([1,2,3])
        z = np.array([1,2,3])

        print(np.array_equal(x,y)) # arraylerin eşit olup olmadığını kontrol eder.
        print(np.array_equal(t,z)) # True verir elemanları eşittir. aynı içeriğe sahiptir arrayler.
....................................................

        import numpy as np

        x = np.random.randint(1,10,size = (5,))

        print(np.sqrt(x)) # tüm elemanların kökünü alır tek tek ve yeni bir array return eder.
        print(x ** 0.5) # tüm elemanların kökünü alır ve bir array return eder.

....................................................
       
        import numpy as np

        x = np.random.randint(1,10,size = (5,))

        print(np.power(x,3)) # tüm elemanların tek tek küpü alınır..
        print(np.exp(x)) # tüm elemanlar doğal logaritmaya alınır tek tek bir array return edilir.
        
....................................................

        import numpy as np

        x = np.random.randint(1,10,size = (5,))

        print(np.sum(x)) # tüm elemanları toplar ve return eder.
        
        y = np.random.randint(1,10,size=(3,3))
        print(np.sum(y)) # tüm elemanları toplar ve return eder.

        print(np.sum(y,axis=0)) # sutunların toplamını döner.
        print(np.sum(y,axis=1)) # satırların toplamını döner

        print(y.min()) # en küçük değeri return eder.
        print(y.max()) # en büyük değeri return eder.
        print(y.mean()) # ortalamayı geri döndürür.
        print(y.argmin()) # en küçük değerin yerini return eder.
        print(y.argmax()) # en büyük değerin yerini verir.

....................................................


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








/////Ders 10 - İstatistik Fonksiyonları, Broadcasting////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import numpy as np

        x = np.random.randint(1,10,size = (8,))
        print(f"{x}\n") # 
        print(x.mean()) # ortalama değeri verir toplamın eleman sayısına bölümünü return eder
        print(np.median(x)) # medyanı verir. küçükten büyüğe sıralanınca en ortada olan sayıdır eğer iki sayı olursa onların ortalaması olur.
        print(x.std()) # standart sapmayı return eder.

....................................................

        import numpy as np

        x = np.random.randint(1,10,size = (4,3)) # 4 satır 3 sutunlu bir yapı elde ederiz.
        print(x)
        print(x.mean(axis=0)) # sutunların ortalamasını return eder axis = 1 olursa o zaman satırların ortalamasını return eder. 0 sutun 1 satir. bir array içerisinde verir.
        print(np.median(x,axis=1)) # satırların medyanını bulur. bir array içerisinde return eder.
        print(x.std(axis=0)) # standart sapmaları bir array içerisinde return eder.

....................................................

        import numpy as np

        #numpy'de bir çok işlem element wise'dır elemanlar teker teker işlem görür. mesela x + y yaparsak iki array üzerinde o zaman her eleman tek tek aynı konumunda olanlarla toplanır.

        x = np.random.randint(1,10,size = (3,2)) 
        print(x)

        y = np.random.randint(1,10,size = (3,2))
        print(y)

        print(x + y) # element wise işlemdir bu.
        
        # element wise işlemler birbiri ile broadcasting edilebilir arrayler üzerinde de çalışabilir.

        # mesela 4 satır 3 sutun olan bir matris var ve elimizde 3 sutun 1 satır olan başka bir array var o zaman broadcasting yapabiliriz. eşleme olabilir üst üste gelenler yani konumları tutanlar birbiri ile işlem görebilir.

        z = np.random.randint(1,10,size = (4,3))
        print(z)
        """
        [[9 3 5]
        [8 6 7]
        [2 6 9]
        [2 9 1]]
        
        """

        t = np.random.randint(1,10,size = (3,))
        print(t) # [8 5 1]

        print(z + t)
        """

        [[17  8  6] # üst üste geldi ve toplama oldu... matrisin ilk satırı ile array toplandı.
        [16 11  8]
        [10 11 10]
        [10 14  2]]
        
        """   

....................................................


        import numpy as np

        x = np.random.randint(1,10,size = (3,)) 
        print(x) # [2 7 3]

        y = np.random.randint(1,10,size = (3,1))
        print(y)
        """
        [[5]
        [2]
        [6]]
        """

        print(x + y)
        """
        [[ 7 12  8]
        [ 4  9  5]
        [ 8 13  9]]   
        
        """
             # broadcasting ile oluştu bu matris. 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////Ders 11 - SON DERS - Uygulama Dersi/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




....................................................



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


####################################################################################################################################################################################################################################################################################################################################