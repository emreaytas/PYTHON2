####################################################################################################################################################################################################################################################################################################################################

mysql parola = 12345

veritabanı verilerin depolandığı yazılımlardır. sql dili ile çalışır.
 normalde program içerisindeki değişken(listeler vs tüm alan kaplayan veriler) bilgisayarın ram'inde barınır uygulama sonlanırsa silinir gider.belli süre ramda bulunur bitince silinir. bunun için elde verilerin kalıcı olarak kalması için o zaman veritabanı kullanmak lazım. uygulama tekrar çalışınca veriler gitmesinn diye bunu saklamak lazım. 
 verileri dosya sistemde saklayabiliriz json sisteminde saklayabiliriz. vs vs. json xml xls dosyaları ile verileri sakalayabiliriz ama en iyisi veritbanında tutmaktır nedeni ise istenen ilişkiler kurabilir dil ile veritabanı ile iletişim kurabiliriz. örneğin 20 yaş üstü kişileri getir vs diyebiliriz.

verileri hafızada memory(ram)  filesystem(txt) .json .xml .xls gibi uzantılı dosyalarda  sql ile(mysql mssql sqlite) gibi ve nosql(mongodb) gibi yapılarda tutabiliriz. 

database iki yapı altında ele alınır = sql(mysql,sqlite3,msSql), nosql (MongoDB(veritabanı serveri) mesela içerisinde json bilgiler saklayabiliriz.) olarak ikiye ayırabiliriz.

server ve serverless(sqlite3 mesela(internet üzerinden değil uygulama içerisinde bulunan serverless veritabanı)) olarak iki yapıya ayrılır veritabanları. yani bir server var ve bağlanmak ve onun üzerinden işlem yapmak gerekiyor.

server olan veritabanı internet üzerinden çalışırsa adresi ve giriş bilgileri ile içerisindeki bilgilere ulaşabiliriz. 

mesela masaüstü uygulama için internetsiz uygulama için sqlite3 mantıklı txt gibi ama bir veritabanı. web veya internet ile ağ ile işlem yapacaksak eğer o zaman server veritabanları gerekli.

internet üzerinden açık bir database için server database olması lazım. çevrimiçi olarak etkileşim sağlayabiliriz.

drop database if exists emre; eğer emre adlı bir db varsa silecek.
 
mesela hepsiburada tek bir serverdatabase kullanır ve farklı cihazlar farklı uygulamalar ile kendi bilgilerimize vs ulaşabiliriz tek veritabanı ile her yerden aynı bilgilere ulaşabiliriz hepsi aynı server üzerindeki databasede çünkü. ama sqlite3 gibi serverless database kullansa o zaman her uygulama için farklı bir tane veritabanı kullanacaktı. ve veri geldikçe uygulamanın kapladığı alan artacaktı...

sql bir sorgulama dilidir. bu dil ile veritabanı ile uygulama arasında iletişim kurabiliriz.

veirleri tablolar üzerinde tutmamız gerekecek tablonun kolunların hepsinin ismi cismi olacak.

mesela elimizde ürünlerin ve alıcıların olduğu tablo var siparişler tablosunda biz ürünid ve alıcıid ile karmaşıklık olmadan siparişleri tutabiliriz. sadece ürün bilgileri kendi tablosunda sadece alıcı bilgileri kendi tablosunda olacak ve siparişler tek satırda ürün ve alıcı olarak tablo oluşturulacak.

id kolonu primary key yani birincil anahtar olarak adlandırılır.

tablolar arasında one to one (bire bir) one to many(bire çok) many to many(çoka çok) ilişkisi vardır. bu ilişkiler sayesinde gereksiz bilgi kalabalığı olmuyor.

uygulamamız databaseye bir sorgu yollar ve işlem database üzerinde gerçekleşir sorgular ile sql ile veritabanını yönetiriz.
................................................................................................................................................................................................................................................................................................................................................................................................................................................................

veri tabanı sunucusu isteklere göre işlem yapan bir serverda bulunan veritabanıdır. bir yazılımdır bir donanım değildir.  network üzerinde bir port üzerinden istekleri dinler ve ona göre işlem yapar...
her bir veritabanı sunucusu bir veritabanıdır ama her veritabanı bir veritabanı sunucusu değildir...
tüm veri tabanlarının dili sql'dir ama sunucular kendilerine göre özelleştirmiş zamanla...

................Tablo ilişkileri....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
  
verileri tablolarda tutarız... özellikler kolon olur... 
   ilişkisel tablo kullanmamızın sebebi veritekrarını engellemek içindir... mesela   kullanıcılar tablosu olsun primary key id olsun vesutunlarda as,soyad,tc,yaş vs vs gibi bilgiler olsun o zaman sadece id ile kişilere erişebiliriz böylece veri tekrarı azalır... ve hatalar azalır...
   
   one to many = bire çok
   one to one = bire bir
   many to many = çoka çok


ONE TO MANY....
   mesela bir telefon var ismi fiyatı ve kategoriid'si var. bir kategori tablosu vardır örnek olarak telefon bilgisayar vs olacak şekilde. o zmaan kategoriid ile bu işi halledebiliriz. her bir telefonun sadece bir kategorisi olabilir bir ürünün birden fazla kategorisi olamaz. bir kategori birden fazla ürüne gidebilir ama her ürün tek bir kategoriye sahip olabilir one to many ilişkisi budur.
   mesela arabalar tablosu var her arabanın bilgileri vs var ve kişiler var kişilerin arabası kolonu olur o kolona ise biz arabaid ile kimde hangi arabanın olduğunu görebiliriz. (her kişide sadece bir araba olduğunu varsayarsak olabilir. kişiler birden fazla araba alabilirse many to many olur herkesin tek arabassı olduğunu var sayıyoruz.)

   böylece karmaşıklığın önüne geçebiliriz. ve bir değişim bize çok maliyetli olmaz   

MANY TO MANY....

   mesela kişiler ve arabalar var her arabanın bilgileri özellikleri motor hacmi vs var ve kişiler tablosu var kişilerin ismi yaşı işi gibi bilgileri var.  bir kişinin birden fazla arabası olabilir arabaid kolonunda ve araba tablosundaki her araba birden fazla kişiye gidebilir(mesela 2016 focus birden fazla kişide olabilir.) buna many to many ilişkisi denir.


ONE TO ONE....   
e
   mesela arabalar tablosu var ve her arabanın kendine ait özelliklerinin tutulduğu farklı bir tablo var. mesela araba tablosunda ford focus 1. id'de özellikler tablosunda ise 1. id'de özellikleri var kolon kolon motor hacim renk ağırlık vs. eşleşme ile sadece bir tane ilişki kurulabilir. birisi sadece birine gidebilir.
   arabalar tablosu ve özellikleri tablosu var diyelim. her araba tek bir satırla eşleşebilir özellikler tablosundan özellikler tablosundaki satır ise tek bir araba ile eşleşebilir. eşleşenler birbiri ile ilişkilidir.
   
   veya ürünler tablosu ve detay tablosu var 3 ürün varsa 3 detay olacak her birisi biri ile eşleşecek. neden kullanırız gereksiz ise mesela detaylar sadece ürünler üzerinden işlemler yapabilirsek o zaman kullanmak mantıklıdır.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

client-> komut gönderici, server ise komutlara göre işlem yapan uzak sunucu....
her makine'nin kendi ip'si vardır.  127.0.0.1 
servername'i localhost yaparak kendi pcmize bağlanabiliriz...

sql server authentication seçeriz ve servername kısmına kendi ip'imizi girersek uzak sunucu gibi bağlanabiliriz sqlservera...

.....CREATE DATABASE kısmı...
    database files kısmında _log ve rows dosyası var... inital size ve maxsize ile ne kadar büyüyecek her büyümede ne kadar artacak maks sınırı olack mı olmayacak mı belirleyebiliriz...

ıdentity specification ile biz otomatik artan belirleyebiliriz kolonları... int vs olması lazım ama...  
     identity increment başlama noktası seed ise artış miktarı...

SQL server arka planda sadece tsql çalıştırır mesela arayüz ile tablo oluştururuz ama veritabanına tsql kodları göndererek oluşturur...

///Veritabanına tablo ekleme.//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  bir database kurar use ile onu kullanırız sonra ise create table isim(   veriler  ); yapısı ile işlemleri yaparız.

  unique olursa eğer diğer veriler onunla aynı olamaz mesela id kolonu.  not null ile ise boş değer girilemesin komutu veririz.   
  auto increment ile ise otomatik arttırım sağlarız. id kolonu için biçilmiş kaftan.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///temel sql//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
data manipulation komutları = select,update,delete,insert,Truncate
veritabanı manipulation komutları = create alter drop 
    verinin kendisi değil veritabanı nesneleri üzerinde işlem yapmak için kullanırız database manipulation komutları ile.
    create database.
    alter database.
    create table, alter table, drop table, create index, drop index...

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//select komutu...////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
return mantığı ile çalışır aslında verileri çekmemize yarar.   select * veya kolonlar from tablename where ile şart sağlarız sonra...

USE ETRADE;
SELECT CUSTOMERNAME AS İSİM,BIRTHDATE AS DOGUM_GÜNÜ FROM CUSTOMERS; -- AS İLE İSİMLENDİRME YAPABİLİRİZ...
-- _ HARİCİ ÖZEL KARAKTER KULLANMAMALIYIZ İSİMLENDİRME YAPARKEN...  DOGUM_GÜNÜ GİBİ KULLANABİLİRİZ...     BOŞLUK VS OLMAZ İSİMLENDİRMEDE...

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///INSERT KOMUTU///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

USE ETRADE;
INSERT INTO CUSTOMERS(CUSTOMERNAME,CITY,BIRTHDATE,DISCRICT,GENDER) VALUES('EMRE','KARS','2002-10-29','SARIKAMIS','E'); -- ID BELİRTMEDİK ÇÜNKÜ O ZATEN OTOMATİK ARTAN ALAN EĞER DEĞER VERMEYE KALKARSAK HATA ALABİLİRİZ...
-- ID KOLONU OTOMATİK ARTAN BU YÜZDEN BİZ ONA ATAMA YAPMAYA KALKMAMALIYIZ...
-- DATE DEĞERİ GÖNDERİRKEN '' İÇERİSİMDE YIL-AY-GÜN OLARAK GÖNDERİRİZ...
-- KARAKTER DİZİLERİ ' ' İÇERİİSNDE YOLLANIR...

USE ETRADE;
INSERT INTO CUSTOMERS VALUES(11,'EMRE','KARS','2002-10-29','SARIKAMIS','E');
-- EĞER BİZ CUSTOMERS(KOLONLAR) KULLANMAZSAK ŞAYET O ZAMAN TÜM KOLONLARIN DEĞERLERİNİ SIRASI İLE VERMEMİZ GEREKİR...

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///UPDATE KOMUTU///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

USE ETRADE;
UPDATE CUSTOMERS SET CUSTOMERNAME = 'EMRE';
UPDATE CUSTOMERS SET CUSTOMERNAME = 'EMRE' WHERE CUSTOMERNAME = 'EMREA';

--SETTEN SONRA DEĞİŞİM OLDUKTAN SONRA NE, NE OLACAK BELİRLERİZ... WHERE İLE NELER DEĞİŞECEK BELİRLERİZ... WHERE KOŞULUNU GİRMEZSEK EĞER O ZAMAN ŞU OLUR TÜM SATILARI GEZER TRUE KABUL EDER HEPSİNİ SET EDER...

UPDATE CUSTOMERS SET CUSTOMERNAME = 'EMRE',GENDER = 'E' WHERE CUSTOMERNAME = 'EMREA';
-- BİRDEN FAZLA ALANIDA DEĞİŞTİREBİLİRİZ...    , İLE BÖLEREK...


USE ETRADE;
SELECT DATEDIFF(YEAR,'1980-12-11','2020-01-01') AS YIL_FARKI; --DATEDIFF İLE BİZ İKİ ZAMAN ARASINDA KAÇ SENE VAR GÖREBİLİRİZ YEAR GİRDİK ÇÜNKÜ...

***
UPDATE CUSTOMERS SET AGE = DATEDIFF(YEAR,BIRTHDATE,GETDATE()); -- BIRTHDATE HER SATIR İÇİN KENDİ BIRTHDATE'I OLACAK... SQL'DE İŞLEMLER SATIR SATIR YAPILIR... İTERASYON SATIRLAR ÜZERİNDE DÖNER...
-- YAŞ GÜNCELLEMESİ YAPABİLİRİZ...
--- DATEDIFF İLE ZAMAN FARKI BULABİLİRİZ...   YEAR İLE YIL FARKI BULACAĞIZ DEMEKTİR... BIRTHDATE HER SATIRIN KENDİ DOĞUM GÜNÜ SATIR SATIR İŞLEM OLACAK FOR DÖNGÜSÜ GİBİ HER DÖNGÜDE YENİ BİR SATIR İŞLEM GÖRECEK... GETDATE() İLE ŞU ANKİ ZAMANI RETURN EDEN METOT...

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//DELETE KOMUTU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DELETE FROM TABLOADI WHERE ...; 
DELETE FROM TABLOADI; -- TRUE KABUL EDER SATIR SATIR HER ŞEYİ SİLER... 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//TRUNCATE KOMUTU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
...NEDEN KULLANIRIZ: SİLİNEN VERİLER GERİ GELMESİN VE ÇOK HIZLI SİLİNSİN DİYE...
SIFIRDAN TABLOYU YENİ OLUŞTURMUŞ GİBİ TEMİZLER.

DELETE İLE BİR ŞEY SİLERSEK TÜM TABLOYU MESELA AUTO İNCREMENT VARSA O ZAMAN 1000 VERİ SİLDİYSEK YENİ GELEN 1001'DEN DEVAM EDER AMA TRUNCATE İLE SİLERSEK 1'DEN DEĞER VERMEYE BAŞLAR SANKİ YENİ OLUŞMUŞ GİBİ...
 VE ÇOK HIZLI BİR TEMİZLEME YAPAR DELETE'DEN DAHA HIZLI TEMİZLER...

TRUNCATE TABLE TABLOADI; -- BU YAPI İLE KULLANIRIZ... AUTO İNCREMENT İLE NORMALDE 1000 OLAN VE YENİ GELECEK VERİDE 1001 OLACAK DEĞER TRUNCATEDEN SONRA 1'DEN BAŞLAR TEKRAR DELETEDE İSE EN SON KALDIĞI YERDEN DEVAM EDER...

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//WHERE ŞARTI...////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

WHERE şartlar...

<   küçüktür eğer öyleyse true verir yoksa false verir...
>   büyüktür eğer öyleyse true verir yoksa false verir...
=   eşittir eğer öyleyse true verir yoksa false verir...
<>  eşit değildir eğer öyleyse true verir yoksa false verir...
>= büyük eşittir değilse false öyleyse true...
<= küçük eşittir değilse false öyleyse true...
in (....)   ... içinde aranan varsa true yoksa false birden fazla değer arayacaksak kullanırız...
not in (....)   ... içindekilerden birisi değilse true yoksa false birden fazla olmayan ararsan o zaman kullanırız...
between arasındadır...
like    ile başlar... ile biter... içerir...
not like  ile başlamaz... ile bitmez... içermez...

               -- karşılaştırma operatörleri
               -- EŞİTTİR 
               select * from products where price = 18;
               -- BÜYÜKTÜR
               select * from products where price > 18;
               -- KÜÇÜKTÜR 
               select * from products where price < 18; 
               -- BÜYÜK EŞİTTİR
               select * from products where price >= 18; 
               --KÜÇÜK EŞİTTİR
               select * from products where price <= 18; 
               -- EŞİT DEĞİLDİR(yerine not kullanabiliriz...mesela select * from tablename where not city = 'izmir')   
               select * from products where price <> 18;  -- eşit değildir operatorleri <> demektir...

               --birden fazla koşul...
               select name1,surname1 from products where price > 100 and categoryid = 1; -- iki şartta sağlanmalıdır... 
               select name1,surname1 from products where price > 100 or categoryid = 1; -- ikisinden birisi tutsa yeter.

               -- Select Top ifadesi     üstten belirli sayıda satır getirir...

               select top (50) proid,proname from  products;  -- top (sayi) ekleriz selectten sonra en üstteki sayi kadar satırı getirir.
               select top (50) proid,proname from  products where price <> 100;

               -- order by ile sıralama...

               select * from products order by stock asc ; -- default olarak asc zaten küçükten büyüğe sıralar. asc yazmsadakta olurdu...
               select proid,proname from products order by stock desc; -- büyükten küçüğe sıralama yapabiliriz.

               -- like ile arama filtrelem yapma.
               select proid,proname from products where productname like 'a%';  -- a ile başlayanlar demek...
               select * from products where productname like 'abs%'; -- abs ile başlayan isimleri getir...
               select * from products where productname like '%abs'; -- abs ile bitenleri getir demektir...
               select * from products where productname like '%ab'; -- ab ile bitenleri getir demektir... 
               select proid,proname from products where productname like '%abs%' -- içinde abs geçenleri getir demektir
               select proid,proname from products where contanctname like '_r%'; -- ikinci karakteri r ile başlayanları getirir.
               select * from products where productname like '%r_'; -- sondan ikinci karakteri r olanlar ı getir demektir.
               select * from products where productname like 'a__%' -- adı a ile başlayan ve en az 3 karakter olan kayıtları getir demektir.
               select * from products where productname like '%___a'; -- adı a ile biten ve en az 4 karakter olan kayıtları getir demektir.
               select * from products where productname like 'a%b' -- a ile başlayan ve b ile biten kayıtları getirir...
               select * from products where productname like 'ab%cd' -- ab ile başlyan ve cd ile biten kaytılatrı getirir.
               select * from products where productname not   like '%a' --  a ile bitmeyen kayıtları getirir not like dedik cunku....
               select * from products where productname not   like 'em%' -- em ile baslamayanları getirir...

               -- SQL IN,NOT IN OPERATORU...
               select * from products where country in ('UK','germany','brazil') -- () içerisinde birden fazla seçeneğimiz varsa or or yerine bunu kullanırız
               select * from products where country not in ('UK','germany','brazil') -- () içine girilenler harici satırları getirir...birden fazla seçenek için kullanılır...


select * from customers where birthdate > '19901001'   -- tarih formatını böyle kullananiliriz yılaygün  veya 'yıl-ay-gün' yapabiliriz...
SELECT * FROM CUSTOMERS where BIRTHDATE between '19901001' and '20001201'; -- iki tarihte  dahil... <=  ve => birleşimidir...
                                               -- tarih formatını böyle yazarsak eğer o zaman dilden bağımsız olur...

SELECT * FROM CUSTOMERS where CITY in('istanbul','kars') AND CUSTOMERNAME IN ('EMRE','FARUK'); -- AND OR VS VS İLE BİRDEN FAZLA KOŞULU BİRBİRİNE BAĞLAYABİLİRİZ...


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///AND VE OR OPERATORLERİ...///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AND VE OR İLE BİRDEN FAZLA KOŞULU BİRBİRİNE BAĞLAYABİLİRİZ...

SELECT * FROM CUSTOMERS WHERE CUSTOMERNAME <> 'EMRE' AND CITY = 'KARS';   -- TRUE OLMASI İÇİN İKİ KOŞULUNDA SAĞLANMASI GEREKİR...
SELECT * FROM CUSTOMERS WHERE (CUSTOMERNAME <> 'EMRE' AND CITY = 'KARS') or AGE = 22;  -- () OR ()   İKİSİNDEN BİRİSİ TRUE OLSA YETERLİDİR...
bir koşul bloğunu () içerisine koyabiliriz ve (() and ())  or ()  gibi yapılar kurabiliriz...

SELECT * FROM CUSTOMERS WHERE (BIRTHDATE > '20001011' AND BIRTHDATE <= '20101012');

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///DISTINCT   Anahtar KELİMESİ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

TEKRAR EDEN SATILARI TEKİLLEŞTİRMEK İÇİN KULLANILAN KOD... MESELA 5000 BİN SATIŞ OLMUŞ HER ALICI 10 ÜRÜN ALMIŞ 500 TEKİL MÜŞTERİYİ DISTINCT İLE KULLANABİLİRİZİ.

SELECT DISTINCT * VEYA KOLONLAR  FROM  TABLOADI WHERE ....
SELECT DISTINCT CITY FROM CUSTOMERS; -- ŞEHİRLERİ TEKİLLEŞTİRİR GETİRİR. KAÇ ADET ŞEHİR VAR GÖREBİLİRİZ...
SELECT DISTINCT CITY,DISCRICT FROM CUSTOMERS WHERE CITY = 'İSTANBUL'; -- İSTANBULDAKİ İLÇELERİ TEKİLLEŞTİRİP GETİRECEK...

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///ORDER BY KOMUTU///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SIRALAMAK İÇİN KULLANIRIZ... sisteme ekleme sırasına göre yaşa göre ada date'ye göre vs vs sıralayabilirzi..

select * from tablename where .... order by kolon1 asc, kolon2 desc,...     -- tek bir kolona göre sıralama olacak diye bir şey yok...
 -- burada önce kolon1'e göre sıralar... sonra kolon1 değerleri aynı olanlar kolon2'ye göre sıralanır...
-- asc küçükten büyüğe sıralama... desc büyükten küçüğe sıralama...    srtringlerde sıralama alfabeye göre olur...

SELECT * from CUSTOMERS order by ID asc,CUSTOMERNAME;  -- asc desc belirtmezsek default olarak asc kabul eder...
  -- asc desc olarak belirtmezsek eğer o zamana default olarak asc yani küçükten büyüğe sıralar.

order by id,name,surname; -- önce id sonra name sonra surnameye göre sıralr... id aynı  olanları name'ye name'si aynı olanları suranmeye göre sıralar. öncelik id... sonra id'si aynı olanlar nameye göre vs vs...

SELECT * from CUSTOMERS order by city asc,CUSTOMERNAME desc where gender = 'K';

SELECT * from CUSTOMERS where gender = 'K' order by CITY asc,CUSTOMERNAME desc ; -- ŞEHİRLERİ TEKİLLEŞTİRİR GETİRİR. KAÇ ADET ŞEHİR VAR GÖREBİLİRİZ...
-- WHERE İLE BERABER KULLANIMI...

SELECT * from CUSTOMERS  order by 2,1 ;  -- 2.kolon,1.kolon demektir... 
-- order by 1,2... dersek sırası ile 1. kolon 2. kolon verilen sayılar kolonların yerine girilir.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//TOP KOMUTU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EN DEĞERLERİ GETİRMEK İÇİN KULLANILIR... BİR VERİSETİNDEKİ VERİLERİN BİR KISMINI GÖRMEMİZ İÇİNDİR... YÜZDE VEYA SAYI İLE BELİRTME YAPABİLİRİZ...

SELECT TOP(N) *VEYAKOLONLAR FROM TABLENAME WHERE.... ORDER BY....; GİİB KULLANILABİLİR...

SELECT TOP(100) * FROM CUSTOMERS ORDER BY CUSTOMERNAME;
   -- ÖNCE SIRALAR SONRA İLK 100 KAYDI GETİRİR. YÜZ TANE VEYA DAHA AZ SATIR VARSA O ZAMAN HEPSİNİ GETİRİR... GİRİLEN DEĞER MAKS HACİMDİR ASLINDA...

SELECT TOP 20 PERCENT * FROM CUSTOMERS ORDER BY CUSTOMERNAME;
  -- TOP N PERCENT DERSEK %N KADARINI GETİRİR... 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///ORNEK DATABASE RESTORE ETMEK...///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

-- .BAK dosyası veritabanı dosyasıdır...
databases -> sağtık -> restore database oradan device sorna .bak dosyasını seç ve ekle...


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//aggregate functions////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GENELDE GROUP BY İLE KULLANILIR... 
SUM,MİN,MAX,AVG GİBİ METOTLAR...

SELECT COUNT(*) FROM SALES; -- KAÇ SATIR VAR GÖREBİLRİİZ...
SELECT * FROM SALES ORDER BY AMOUNT; -- EN AZ ALANDAN EN ÇOK ALANA GÖRE SIRALADIK...
SELECT MIN(AMOUNT) FROM SALES; -- EN AZ ALAN'I GÖREBİLİRİZ...
SELECT MAX(AMOUNT) FROM SALES; -- EN FAZLA ALANI GÖREBİLİRİZ...
SELECT AVG(AMOUNT) FROM SALES; -- ORTALAMA ALIMI GÖREBİLİRİZ..

SELECT AVG(AMOUNT) AS 'ORTALAMA',MIN(AMOUNT) AS 'MINIMUM',MAX(AMOUNT) AS 'MAKSIMUM',COUNT(AMOUNT) AS 'SATIR SAYISI', SUM(AMOUNT) AS 'TOPLAM AMOUNT' FROM SALES;
-- COUNT(*) VEYA BİR KOLON OLABİLİR SATIR SATIR OKUMA YAPACAK KAÇ ADET KOLONA DENK GELDİ ONU SAYACAK...
SELECT AVG(TOTALPRICE) AS 'ORTALAMA',MIN(TOTALPRICE) AS 'MINIMUM',MAX(TOTALPRICE) AS 'MAKSIMUM',COUNT(TOTALPRICE) AS 'SATIR SAYISI', SUM(TOTALPRICE) AS 'TOPLAM AMOUNT' FROM SALES WHERE CITY = 'İSTANBUL'; --ŞEHİR ŞARTI EKLEDİK... AS İLE İSİMLENDİRDİK... aggregate METOTLARI İLE İSTENEN DEĞERLERİ RETURN ETTİRDİK...

SELECT * FROM SALES ORDER BY TOTALPRICE ASC; -- DEFAULT OLARAK ASC ZATEN...

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///GROUP BY KULLANIMI...///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
GROUP BY gruplamaK İÇİN ORDER BY İSE SIRALAMAK İÇİN KULLANILIR...
mesela satışların olduğu tablo var... şehirlere göre gruplarız ve her şehrin değerini ise toplatırız... böylece her şehirde ne kadar satış yapmışız görebiliriz...

select kolon1,kolon2... sum(price),count(id),min(price),max(price)... from tabloname group by kolon1,kolon2... 

select CITY AS 'SEHİR',AVG(TOTALPRICE) AS 'ORTALAMA',MIN(TOTALPRICE) AS 'MINIMUM',MAX(TOTALPRICE) AS 'MAKSIMUM',COUNT(TOTALPRICE) AS 'SATIR SAYISI', SUM(TOTALPRICE) AS 'TOPLAM AMOUNT' FROM SALES group BY CITY;
-- GROUP BY CITY İLE SEHİRLERE GÖRE GRUPLANDIRDIK... SELECTTEN SONRA MAX MIN CITY VS VS İÇİN DEĞERLERİ GETİREBİLİRİZ. GRUPLANMIŞ VERİLER ÜZERİNDEN.

select top(10) CITY AS 'SEHİR',AVG(TOTALPRICE) AS 'ORTALAMA',MIN(TOTALPRICE) AS 'MINIMUM',MAX(TOTALPRICE) AS 'MAKSIMUM',COUNT(TOTALPRICE) AS 'SATIR SAYISI', SUM(TOTALPRICE) AS 'TOPLAM AMOUNT' FROM SALES group BY CITY order by sum(TOTALPRICE) desc; -- group by ile grupladık... order by ile ise sıralarız... desc büyükten küçüğe demektir...
-- top(10) ile ilk on şehir ama en çok satış yapan şehirleri getirdik...



use ETRADE2;

select * from SALES WHERE CITY = 'ANKARA' ORDER BY TOTALPRICE DESC;
SELECT *,CONVERT(DATE,DATE_) AS 'DATE2' FROM SALES WHERE CITY = 'ANKARA' ORDER BY DATE_; -- SELECT *, CONVERT(DATE,DATA_) DEDİK TÜM KOLONLARA EK OLARAK DATE OLMUŞ  DATETİME BİLGİSİNİ ALIRIZ...
SELECT CONVERT(date,'2019-01-20 13:47:54.000'); -- DATE DEMEK TARİH DEMEK DATETİME İSE TARİH VE ZAMAN BİLGİSİ DEMEKTİR...
SELECT CONVERT(datetime,'2019-01-20 13:47:54.000'); -- CONVERT İLE DÖNÜŞÜM YAPABİLİRİZ...  ÖNCE HANGİ TÜRE ÇEVİRECEĞİZ BUNU VERİRİZ SONRA İSE VERİSİNİ VERİRİZ...

update SALES set DATE2 = CONVERT(date,DATE_); -- date2 kolonu ekledik date tipinde ve null olan verileri düzenledik...

select * from SALES where CITY = 'ANKARA' AND DATE2 = '2019-01-01' ORDER BY DATE_;

SELECT CITY,SUM(TOTALPRICE) AS 'TOTAL PRİCE' FROM SALES WHERE CITY = 'ANKARA'
GROUP BY CITY,DATE2 ORDER BY CITY,DATE2

SELECT CITY from SALES GROUP BY CITY; -- şehirleri grupla ve şehri getir dedik...

-- hata verir...SELECT * from SALES GROUP BY CITY; -- böyle yaparsak seçim yok veriler gruplandı şehirlere göre ama biz hangi değerleri alacağız... max mın avg sum gibi değerleri çağırmamız lazım...


use ETRADE2;

SELECT AVG(TOTALPRICE) as 'TOTAL PRİCE', COUNT(TOTALPRICE) AS 'SEHİRDE KAC SATIS OLMUS' from SALES GROUP BY CITY; -- şehirlere göre grupla. ve şehirlerin ortalama totalprice değerini getir dedik...
-- COUNT(TOTALPRİCE) DEMEK VERİLER GRUPLANDI ÖNCE SONRA COUNT(TOTALPRİCE) DİYEREK HER ŞEHİRDE KAÇ KERE TOTALPRİCE VAR BUNU GÖREBİLİRİZ...

select CITY from SALES GROUP BY CITY ORDER BY CITY; -- ŞEHİRLERE GMRE GRUPLA, GRUPLARIN İÇİNDEN CITY BİLGİSİNİ GETİR VE CITYE GÖRE SIRALA DEDİK...

SELECT CITY,SUM(TOTALPRICE) AS TOPLAM_SATIS FROM SALES GROUP BY CITY; -- ŞEHİRLERİ GRUPLADIK VE TOPLAM SATIŞLARINI İSİMLERE GÖRE SIRALAYARAK GÖRDÜK...


SELECT CITY,DATE2,SUM(TOTALPRICE)AS TOPLAM_SATIS ,COUNT(DATE2) AS 'TEKRAR SAYISI' FROM SALES GROUP BY CITY,DATE2 ORDER BY CITY; -- HEM ŞEHRE HEM TARİHE GÖRE GRUPLADIK... ÖNCE ŞEHİRLERE GÖRE SONRA ŞEHİRLER KENDİ ARALARINDA TARİHLERE GÖRE GRUPLANDILAR...


select DATE2,CITY,SUM(TOTALPRICE) AS 'TOPLAM SATIŞ' from SALES where DATE2 = '20190101' 
GROUP BY DATE2,CITY
ORDER BY SUM(TOTALPRICE) DESC; -- DATE2,CITY,SUM(TOTALPRICE) BU DEĞERLERİ GETİR. DATE2 VE CITY'YE GÖRE GRUPLA SUM(TOTALPRİCE) DESC İLE SATIŞA GÖRE BÜYÜKTEN KÜÇÜĞE SIRALA DEDİK...

select CITY,DATE2,SUM(TOTALPRICE) AS 'TOPLAM SATIŞ',COUNT(DATE2) AS 'BELLİ SEHİRDE BELLİ BİR TARİHTE YAPILAN SATIS SAYISI' from SALES 
GROUP BY DATE2,CITY
ORDER BY CITY; -- GROUP BY DATE2,CITY DEDİK BUNUN ANLAMI ÖNCE ŞEHİRLERE GÖRE GRUPLA SONRA GRUPLADIĞIN ŞEHİRLERİ TARİHLERE GÖRE GRUPLA AYNI OLANLAR GRUPLANSIN YANİ VERİ ÖNCE ŞEHİRLERE BÖLÜNECEK SONRA TARİHE GÖRE ŞEHİRLER BÖLÜNECEK VE BİR NESNE OLUŞACAK...
-- ORDER BY İLE İSE SIRALADIK...


use ETRADE2;
-- YENİ BİR KOLON EKLEDİK... DATAPART(MONTH,DATE)  BİZE BİR SAYI DÖNER YILIN HANGİ AYINDASIN BUNU RETURN EDER...
UPDATE SALES SET MONTHNAME_ = '01.OCAK' WHERE DATEPART(MONTH,DATE2) = 1;
UPDATE SALES SET MONTHNAME_ = '02.SUBAT' WHERE DATEPART(MONTH,DATE2) = 2;
UPDATE SALES SET MONTHNAME_ = '03.MART' WHERE DATEPART(MONTH,DATE2) = 3;
UPDATE SALES SET MONTHNAME_ = '04.NİSAN' WHERE DATEPART(MONTH,DATE2) = 4;
UPDATE SALES SET MONTHNAME_ = '05.MAYIS' WHERE DATEPART(MONTH,DATE2) = 5;
UPDATE SALES SET MONTHNAME_ = '06.HAZİRAN' WHERE DATEPART(MONTH,DATE2) = 6;
UPDATE SALES SET MONTHNAME_ = '07.TEMMUZ' WHERE DATEPART(MONTH,DATE2) = 7;
UPDATE SALES SET MONTHNAME_ = '08.AĞUSTOS' WHERE DATEPART(MONTH,DATE2) = 8;
UPDATE SALES SET MONTHNAME_ = '09.EYLÜL' WHERE DATEPART(MONTH,DATE2) = 9;
UPDATE SALES SET MONTHNAME_ = '10.EKİM' WHERE DATEPART(MONTH,DATE2) = 10;
UPDATE SALES SET MONTHNAME_ = '11.KASIM' WHERE DATEPART(MONTH,DATE2) = 11;
UPDATE SALES SET MONTHNAME_ = '12.ARALIK' WHERE DATEPART(MONTH,DATE2) = 12;
-- NEDEN AYLARIN ÖNÜNE SAYI KOYDUK BUNUN NEDENİ SIRALAMA YAPARKEN AY SIRASINA GÖRE OLSUN DİYE YOKSA AĞUSTOS OCAKTAN ÖNCE GELEBİLİR BU YÜZDEN SIRASI İLE EKLEME YAPTIK...


SELECT MONTHNAME_,SUM(TOTALPRICE) AS 'TOPLAM SATIŞ' FROM SALES
GROUP BY MONTHNAME_
ORDER BY MONTHNAME_;  -- AYLARA GÖRE SATIŞLAR...

SELECT CITY,MONTHNAME_,SUM(TOTALPRICE) AS 'TOPLAM SATIŞ' FROM SALES
GROUP BY CITY,MONTHNAME_
ORDER BY CITY,MONTHNAME_
; -- ŞEHİRLERİN AYLIK SATIŞLARINI GÖREBİLİRİZ...


SELECT CITY,MONTHNAME_,SUM(TOTALPRICE) AS 'TOPLAM SATIŞ' FROM SALES
GROUP BY CITY,MONTHNAME_
ORDER BY SUM(TOTALPRICE) DESC
; -- ŞEHİRLERİ VE AYLARI GRUPLADIK ÖNCE ŞEHİRLER SONRA SEHİRLER AYLARA GÖRE GRUPLANDI...
-- SIRALAMA TOTAL SATIŞA GÖRE BÜYÜKTEN KÜÇÜĞE...
-- BİZ ŞEHİR,AY VE TOPLAM SATIŞI ÇEKTİK ŞEHRE VE AYA GÖRE BÖLÜNMÜŞ NESNELERDEN...


         use ETRADE2;

         SELECT  CATEGORY1,CATEGORY2,CATEGORY3,CATEGORY4 ,
         SUM(TOTALPRICE) AS 'TOTAL FİYAT',
         COUNT(*) AS 'KAC ADET?', 
         SUM(AMOUNT) AS 'TOTAL AMOUNT'
         FROM SALES
         GROUP BY CATEGORY1,CATEGORY2,CATEGORY3,CATEGORY4
         ORDER BY CATEGORY1,CATEGORY2,CATEGORY3,CATEGORY4;
                        CT1,  CT2,              CT3,        CT4,         
                        ---------------------------------------------------------------------------
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BAKIM ORTULERI	579,3	7	37
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BARDAK	2331,3	20	98
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BEBE SABUNLARI	304,2	5	36
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BEBE SAMPUANLARI	1844,5	37	175
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BEBEK BAKIM SETLERI	1136,22	6	29
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BEBEK DETERJAN	265,68	7	36
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BEBEK KREMLERI	4023,2	30	149
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BEBEK PUDRA	2216,85	23	120
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BEBEK YAGLARI	2051,35	17	85
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BESLENME	1676,2	11	58
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BIBERON	12766,37	136	715
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BIBERON UCU	275,5	6	29
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	BURUN ASPIRATORU	2147,85	25	129
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	DIGER URUNLER	725	5	29
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	DIS KASIYICI	542,15	6	35
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	DISLIK	1049,41	15	84
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	EMZIK	15031,736	314	1698
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	FIRCA	2266,3	23	131
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	GOGUS KORUYUCU	481,35	8	45
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	ISLAK MENDIL	154,368	4	24
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	KASIK	658	5	40
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	LOSYON VE SUTLERI	2396,8	20	91
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	PISIK KREMLERI	1646,39	12	61
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	SAC KREMLERI	175	4	20
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	SAMPUAN	6935,132	87	505
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	TIRLE	332	4	16
                        BEBEK	BEBE MALZEMELERI	BEBEK BAKIM	TIRNAK MAKASI	397,75	6	37
                        BEBEK	BEBE MALZEMELERI	CILT BAKIM	GUNES KREMI	6072,876	15	81
                        BEBEK	BEBE MALZEMELERI	COCUK BEZLERI	GECE KILODU	1697,3	14	67
                        BEBEK	BEBE MALZEMELERI	COCUK BEZLERI	STANDART PAKET	193346,164	1094	6028
                        BEBEK	BEBE MALZEMELERI	KATI SABUNLAR	BEBE SABUNLARI	1875,7	17	83
                        BEBEK	BEBE MALZEMELERI	SAMPUANLAR	SAC KREMLERI	1967,1	17	79
                        BEBEK	BEBE MALZEMELERI	SAMPUANLAR	SAMPUAN	4114,316	73	412
                        BEBEK	BEBE MALZEMELERI	SAMPUANLAR	VUCUT SAMPUANI	145,536	4	16
                        BEBEK	BEBEK MALZEMELERI	ISLAK HAVLU	BEYAZ	2315,7	13	83
                        BEBEK	BEBEK MALZEMELERI	KOLONYALAR	BEBE KOLONYALARI	5668,42	67	347
                        BEBEK	GIYIM	BEBE GIYIM	PENYE	179,4	8	39
                        BEBEK	GIYIM	BEBE GIYIM	TAKIM	3475,392	56	308
                        BEBEK	GIYIM	BEBE GIYIM	TEK ALT	538,92	22	108
                        BEBEK	HAZIR YEMEK-MAMA	HAZIR COCUK YEMEKLERI	BEBE BISKUVISI	2220,788	68	364
                        BEBEK	HAZIR YEMEK-MAMA	HAZIR COCUK YEMEKLERI	HAZIR MAMALAR	72745,2939991999	605	3502
                        BEBEK	IC GIYIM	CORAPLAR	COCUK CORAP	6036,646	291	1644
                        BEBEK	SAGLIK URUNLERI	PAMUK-KULAK CUBUGU	PAMUK	1892,3	20	127
                        BEBEK	TEKSTIL-GIYIM-AKSESUAR	CAMASIRLAR	COCUK CAMASIR	15793,716	793	4279
                        BEBEK	VUCUT-EL BAKIM	KREMLER	VAZALIN	861,8	15	62



select COUNT(CUSTOMERCODE) AS 'ALICI SAYISI' from SALES; --SALE'TEKİ TÜM SATILARI GEZER VE KAÇ ADET ALICI VAR GÖREBİLİRİZ...
SELECT  FICHENO,COUNT(FICHENO)  FROM SALES WHERE MONTHNAME_ = '01.OCAK' AND CITY = 'ADANA' GROUP BY FICHENO; -- HEM ADANA HEM OCAK AYI FİŞ NUMARASINA GÖRE GRUPLA. VE KAÇ ADETKULLANICI VAR GÖREBİLİRİZ...

use ETRADE2;

SELECT CITY,COUNT(DISTINCT FICHENO),
COUNT (DISTINCT CUSTOMERNAME) AS 'TEKİL KULLANICI' 
FROM SALES
WHERE MONTHNAME_ = '01.OCAK'
GROUP BY CITY
ORDER BY CITY;


use ETRADE2;

SELECT TOP 50 CITY,SUM(TOTALPRICE) AS 'TOPLAM SATIS' -- TOP 50 DEDİK AMA 50 TANE YOKSA HEPSİİN GETİRİR MAKS 50 DEMEK ASLINDA..
FROM SALES -- WHERE ŞARTINDA SUM VS KULLANAMAYIZ MIN MAX KULLANAMAYIZ BUNUN NEDENİ BOOL DEĞERLER İLE ÇALIŞIR KOŞUL BLOKLARI...
GROUP BY CITY HAVING SUM(TOTALPRICE) > 40000 --ŞEHİRLERE GÖRE GRUPLAYINCA TOPLAM SATIŞI 40000 ÜZERİNDE OLAN ŞEHİRLERİ GETİR DEMEKTİR...
ORDER BY (SUM(TOTALPRICE)) DESC;
-- aggregate METOTLARI EĞER BİR KOŞULLA KONTROL ETMEK İSTERSEK HAVING'E VERMEMİZ LAZIM...

use ETRADE2;

SELECT CITY,SUM(TOTALPRICE) AS 'TOPLAM SATIS',COUNT(DISTINCT CUSTOMERNAME) AS 'CUSTOMER COUNT'  -- ŞEHİR,TOPLAMSATIŞ VE TEKİLLEŞTİRİLMİŞ KAÇ ADET KULLANICI ADI VAR GETİR...
FROM SALES 
GROUP BY CITY -- ŞEHRE GÖRE GRUPLA...
HAVING COUNT(DISTINCT CUSTOMERNAME) > 1500 AND SUM(TOTALPRICE) >= 40000 -- aggregate METOTLARDAN DÖNEN DEĞERLERİ BİR ŞART OLARAK KULLANMAK İSTERSEK EĞER O ZAMAN HAVING KULLANMAMIZ GEREKİR...
ORDER BY (SUM(TOTALPRICE)) DESC; -- TOPLAM SATIŞA GÖRE SIRALA BÜYÜKTEN KÜÇÜĞE DEMEKTİR...


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

SQL = Structured Query Language
VERİTABANI, TABLOLAR,SATIRLAR VE SUTUNLARDAN OLURŞUR... SUTUNLARIN VERİ TİPİ VE İSMİ BELLİ OLMALIDIR...

//TAM SAYI VERİ TİPLERİ...////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////,,

SAYISAL VERİ TİPLERİ = BİGİNT(8 BYTE) 64BİT  64 - 1 = 63  MİNİMUM -2^^63, MAKS 2 ^^ 63 - 1
                       İNT(4 BYTE)
                       SMALLİNT(2 BYTE)
                       TİNYİNT(1 BYTE)
                       BİT(1BİT) EĞER TABLODA 8 VEYA DAHA AZ BİT KOLONU VARSA 1BYTE YER KAPLAR 9 OLURSA 2 BYTE YER KAPLAR... ALAN AÇILIR BYTE BYTE SONRA DOLAR. YETMEZSE YENİ BYTE AÇILIR...
                       .......ONDALIKLI...............
                       decimal 1'den 9'a kadar 5 byte, 10'dan 19'a kadar 9 byte, 20'den 26'ya kadar 13 byte, 29'dan 38'e kadar 17 byte...
                       money 8 byte virgülden sonra 4 basamak tutar özel bir decimal(18,4) default olarak...
                       smallmoney 4 byte virgülden sonra 4 basamak tutar
                       float 7 basamağa kadar 4 byte 15 basaamağa kadar 8 byte... esnek olduğu için tercih edilir...
                       real 4 byte,virgülden sonra 4 basamak tutar...
 
EĞER DORĞU ŞEKİLDE KULLANIRSAK O ZAMAN ÇOK FAZLA TASARRUF EDEBİLİRİZ...
DECİMAL(18,2) DEMEK 18 DİGİTLİK YER TUT VİRGÜLDEN SONRA 2 HANELİK YER AYIR DEMEKTİR...
decimal(18,4) yaparsak virgülden sonra 4 hane tutar bölme vs vs işlemler olacaksa gayet güzel.

///METIN(STRING) VERİ TİPLERİ...///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

karakterlernden oluşan yapılar...
başında n olursa mesela n varchar unicode olur demektir her alfabeyi kapsar... n olmazsa 255 karakter asciiden tutar... n olursa eğer o zaman tüm alfabeleri tutacak şekilde unicode olur. ama n olursa her karakter için fazladan byte tutar çünkü 255 değerinden fazla değer tutmaya çalışır... n olursa her karakter için 2byte yer kaplar...
CHAR(50) DERSEK EĞER O ZAMAN STATİC OLARAK 50 KARAKTERLİK YER AYIRIR... 10 DERSEK 10 KARAKTERLİK YER AYIRIR...
NCHAR(SAYİ) OLURSA EĞER O ZAMAN UNİCODE OLUR VE STATİC YER KAPLAR...
varchar(...) olursa dinamik olur... dezavantajı var oda işlem yapar fazladan girilen verinin uzunluğuna göre işlem yapar... ama mesela 11 haneli tcno kullanacaksan o zaman char(11) kullanmak en mantıklısıdır performans için... ama isim adres vs vs için varchar() kullanmak mantıklıdır...
char(50) 50bytelik yer kaplar nchar(50) 100 bytelık yer kaplar...



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



































////veritabanı bağlantısı./////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
python ile bağlantı kurabilmek için mysql connector kullanmamız lazım.  pip install mysql-connector   ile bunu indiririz.   mysql veritabanıdır. ne ile yazarsak ona göre bir connector kullanmamız lazım. mesela java ise java connector lazım  

..................................

   import mysql.connector    ile import ederiz bağlantıyı.  bunu pip install mysql-connector ile kurduk bu bir paket. lib klasörüne yerleşecek bu pakette..

   mydb = mysql.connector.connect(    # bunun çalışabilmesi için güncel olması lazım mysql'in ve connector'ün.
      host = "localhost", # host olarak bunu seçtik... var olan host.  eğer server üzerinden olmasını istersek o zaman hizmet satın almamız lazım oonlarda bize bir adres verecek 192.23.45.56 gibi.
      user = "root", # kullanıcı bilgisi
      password = "12345", # parola bilgisi.
      database = "EMRE" 
   )

   print(mydb) # ne olduğu bilgisini görebiliriz.
 
   mycursor = mydb.cursor()  # bu yapı ile cursor oluştururuz.
   mycursor.execute("""
   create database if not exists EMRE
   """)  # execute ile emir veririz. sorgularımızı göndeririz.
   
   mycursor.execute("""  
   show databases
   """) # bilgiler imlece yani cursora yüklenecek.
   
   for x in mycursor: # tüm bilgiler bir tuple içerisinde mycursor'a gelir.  imleç mantığı ile bunları okuruz.
      print(x)  
   
   mycursor.execute("""
   create table if not exists customers(name varchar(255),adress varchar(255))
   """) # seçili database'de bir tablo oluşturduk.
  

......................................................................................................... 

      import pymysql  # mysql.connector yerine bunu kullandık pip install pymysql ile indirebilir ve import ederiz lib klasörüne yerleşir neredeyse her paket gibi.


      mydb = pymysql.connect(
         host = "localhost",
         user = "root", 
         password = "12345",   
      )

      mycursor = mydb.cursor()
      mycursor.execute("""
      create database if not exists schooldb               
                     """)

      mycursor.execute("""
                     use schooldb 
                     """)

      mycursor.execute("""show databases""")

      for x in mycursor:
         print(x) # tüm databaseleri görebiliriz.

.........................................................................................................


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///veri ekleme.//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import pymysql  # mysql.connector yerine bunu kullandık pip install pymysql ile indirebilir ve import ederiz lib klasörüne yerleşir neredeyse her paket gibi.

def insertProduct(name,price,imageUrl,description):  # name price vs dışarıdan input ile alıp sonra fonksiyona gönderebiliriz böylece dinamik bir yapı kazanır sistem.
    connection = pymysql.connect(
        host = "localhost",
        password = "12345",
        user= "root"        
    )
    cursor = connection.cursor()
    
    sql = "insert into Products(name,price,imageUrl,description) values(%s,%s,%s,%s)" # Produts(id,name) vs olarak sıralamazsak kendimiz belirtmezsek değerler sırası ile default olan sıra ile yüklenir tablonun sutun sırasına göre. mesela eğer id hariç sutunları girersek ve id kolonunu auto increment edersek o zaman otomatik olarak veirlerden bağımsız id artar.
    values = (name,price,imageUrl,description) 
    cursor.execute(sql,values) # (%s,%s,%s,%s) olarak vermemizin sebebi her seferinde farklı veri gelebilir bundan dolayı bu %s yapısı gelecek olan verinin yerini tutacak.  sqlite'deki (?,?,?,?)  ne geleceği belii değik ama 4 tane veri gelecek sırası ile yerleştirmek için kullanırız.
    try:  
        connection.commit() # aslında sorgular commit ile veritabanına gider.
        print(f"{cursor.rowcount} tane kayit eklendi.") # cursor ile bazı bilgilere erişebiliriz burada kaç tane kayıt eklenmiş bunu görebileceğiz.
        print(f"Son eklenen kaydin id: {cursor.lastrowid}") # cursor ile son satırın rowid'sine ulaşabiliriz.
    except pymysql.Error as err: # eğer sorguda bağlantıda vs sorun varsa bize Error hatası verecek.
        print("Hata: ",err)
    finally:    
        connection.close() # hata olsun olmasın bu blok çalışacak ve bağlantı kesilecek .close() ile.
        print("Bağlantı kesildi. Hata olsun veya olmasın.")
        

................................

birden fazla veri eklemek istersek eğer o zaman cursor.executemany(sql,values) # ama values içerisinde tuple veriler olan bir liste olacak tuple'lerin içerisinde ise 



......neden çoklu ekleme yaparız çünkü sürekli bağlantı aç kapa aç kapa yapmamak için tek bir iletişimle tüm verileri girebilmek için ramda saklar sonra db'ye yollarız kısaca.............................................................................................


   import pymysql  # mysql.connector yerine bunu kullandık pip install pymysql ile indirebilir ve import ederiz lib klasörüne yerleşir neredeyse her paket gibi.

   def insertProducts(list1):  
      connection = pymysql.connect(
         host = "localhost",
         password = "12345",
         user= "root"
         database = "node_app"        
      )

      cursor = connection.cursor()
      
      sql = "insert into Products(name,price,imageUrl,description) values(%s,%s,%s,%s)" # Produts(id,name) vs olarak sıralamazsak kendimiz belirtmezsek değerler sırası ile default olan sıra ile yüklenir tablonun sutun sırasına göre. mesela eğer id hariç sutunları girersek ve id kolonunu auto increment edersek o zaman otomatik olarak veirlerden bağımsız id artar.
      values = list1
      cursor.executemany(sql,values) # birden fazla veri olduğu için executemany kullandık. her veri bir tuple halinde olmalı.  böylece list içerisindeki tüm tupleler tek tek işlenecek.
      try:  
         connection.commit() # aslında sorgular commit ile veritabanına gider.
      except pymysql.Error as err: # eğer sorguda bağlantıda vs sorun varsa bize Error hatası verecek.
         print("Hata: ",err)
      finally:    
         connection.close() # hata olsun olmasın bu blok çalışacak ve bağlantı kesilecek .close() ile.
         print("Bağlantı kesildi. Hata olsun veya olmasın.")

   list1 = []
   while True:
      name = input("ismi giriniz: ")
      surname = int(input("Degeri giriniz: "))
      url = input("url giriniz: ")
      desc = input("Description giriniz: ")
      
      list1.append((name,surname,url,desc)) # değerler bir tuple içerisine koyulacak ve tupleler liste içerisine yerleşecek.
      cikis = input("Cikmak icin h'ye basiniz: ")
      if cikis == 'h':
         print("bilgiler veritabanina ekleniyor.")
         insertProducts(list1)   
         break
      
..................................................................................................

eğer sql'e datetime bilgisi gireceksek o zaman  import datetime diyecek ve datetime.datetime(2002,10,19) gibi bilgileri gireceğiz. çünkü o veri tipi ile özdeşmeli...    ("Emre","Aytas","220202098",datetime.datetime(2002,10,19)) yapısı ile gireriz.  sqldede datetime olarak ayarlarız sutun türünü çünkü.

mysql workbench ile bir tablonun oluşturma sorgusunu alıp program içerisinde kullanabiliriz.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




/////sorgulama////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

select *(her kolon demek) ama istersek istenen kolonları belirtebiliriz. from table    where(koşul belirtiriz) number > 10000 mesela numarası 10000 den büyük olanları getirir.  where koşulunda or ve and kullanılabilir.

mycursor.execute("select * from students") yaparsak veriler mycursora gelir imleç mantığı ile.  where ile koşula bağlayabiliriz. 

veriler = mycursor.fetchall()   ile tüm verileri veriler değişkenine atarız.   .fetchone() dersek bir tane alır. sonra bir tane daha .fetchone() dersek ikinci veriyi alır imleç mantığı işlemektedir.
     .fetchmany() ise içine girilen sayı kadar getirir.   eğer 30 veri var ve 100 girersek 30 taneside getirir hata vermez.   0 verirsek tüm verileri getirir.    .fetch... olanları cursor ile kullanırız çünkü veriler cursora gelir.

eğer veriler boş ise veya boş mu değil mi kontrol etmek istersek o zaman 
     if veriler == ():   # eğer bize veri gelmedi ise sorgu ile o zaman () olacak veriler.
        ....
 

delete komutunda uygun koşulda direkt olarak satır silinir. tüm row gider yani.


.............................................................................................


select * from students where name = "emre"  dersek tum sutunlar gelir koşulu sağlayan satır için ama isim sutunu emre olanlar gelir.   .fetch...()  ile hallederiz gelen verileri.
select * from students where name = "emre" or surname = "ford"  # burada ise ya ismi emre olan ya da soyadi ford olanlardan veri gelecek.   and ile ve komutu verebiliriz    böylece hem ismi emre hemde soyadı ford olması gerekirdi koşul bu olurdu.
select * from students where name like '%mercedes%'   dersek like ile içersinde mercedes olanı sorgularız.       'mercedes%'   olursa başı mercedes olanları ararız   %mercedes dersek mercedes ile bitenleri ararız.

.fetchall()   ile bir liste içerisinde veriler gelir   veriler bir tuple içerisinde gelir. 
.fetchone()  olursa sorguda ilk gelen elemanı getirir.   bir tuple gelir.  her sutun tuple içerisindedir isteğe göre bu sutunlar ayarlanabilir.  bir kere daha .fetchone() dersek o zaman bir sonraki veriyi verir bize imleç mantığı.

%s ile ne geleceği belli değilse kullınırız.    eğer sqlite ise ? kullanırız.  

....sıralama (order by).........................................................................................

select * from students order by number   # numaraya göre sıralama yapar.    order by name dersek isme göre sıralama yapar yani alfabetik sıralamaya göre.


tersten sıralama için ise DESC yaparsak o zaman büyükten küçüğe sıralama olur
select * from students order by name DESC   bunu yaparsak alfabetik sıraya göre en büyükten yani a'dan değil z'den sıralamaya başlar sayısal verileri ise en büyükten en küçüğe doğru sıralar.

select * from students order by name, price  # bunu dersek önce isme göre sıralama yapar isimleri aynı olanları ise price'a göre sıralar... 

select * from students where gender = 'K' order by name,surname    # genderi K olanları name ve surnameye göre sıralar küçükten büyüğe doğru.

...aggregate fonksiyonları...........................................................................................

select count(*) from students  # bunu dersek eğer kaç tane sutun vardır bize gösterir.

select count(*) from students where price > 1000   # bize kaç tane fiaytı 1000'den fazla olan var bunu getirir.
select avg(price) from students  # bizde tüm fiyatların ortalamasını getirir.
select sum(price) from students # bize tüm fiyatların toplamını getirir  tüm satırlardaki price'leri toplar.
select min(price) from students # bize en küçük fiyatı getirir max(price) dersek en büyük değeri getirir.

select name from Products where price = (select max(price) from Products)  # önce en büyük değeri içeren satırı getirir. sonra oradan ismi çeker en dıştaki sorgu.

.............................................................................................

.fetch...()   fonksiyonlarını  try except içerisinde kullanmak mantıklıdır. bunun sebebi verileri alırken hata olabilir. 

mesela 2003 doğumluları alacağız. datetime içerisinden o zaman   select * from students where year(birthdate) = 2003 yaparız.    year metotunu kullanırız ay için month()  gün için day() ...

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//güncelleme///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

cursor.execute("update students set name = "Emre" where name = 'emre' ") # set ile değişince olacak olan belirlenir where ile ise neye göre güncelleme alacağı.  where koşulu eklemezsek eğer True olarak kabul eder ve hepsi değişir.

update tabloismi set değişeceksutunlarvegelecekdeğer where koşul     eğer koşul eklemezsek o zaman hepsi değişir.
update sorgusunu commit etmemiz lazım işlemin gerçekleşebilmesi için   connection.commit() şeklinde olmalı cursor üzerinden değiş bağlantı üzerinden sağlarız commiti.
birden fazla sutunu güncellemek istersek virgül ile sıralarız.   set name = "ford",surname = 'focus',age = 8 gibi olur.   

sql = "update students set name = %s,surname = %s where id = %s"
values = (name,surname,id)    # eğer values tek bir değer olacaksa mesela bir tek id olacak o zaman values = (id,) olmalı.
cursor.execute(sql,values)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

sql injection olmaması için sql sorgusunu tek parça halinde yazmak iyidir    sql = "update students set name = 'ford' where name = "+name    yapmak mantıksızdır.   en iyisi sql = "update students set name = 'ford' where name = %s"    execute kısmında ise sql,name ile güncelleme yaparız.

////delete/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

delete from students where ...       böylece uyan koşullarda satır komple silinir.
delete from students dersek eğer bir koşul olmadan tüm veriler silinir buna dikkat etmek gerekir.

commit gibi işlemleri try except içerisinde yapmak ve finally olarak connect.close() yapmak mantıklıdır.   neden commit try içerisinde nedeni şu commit ile sql'e sorgu yollayacağız. hata orada çıkabilir.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////Birden fazla tablo ile çalışma./////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


mesela bir telefonlar tablomuz var hangi kategoride olduğunu eklemek istiyoruz ya başka kategoriler tablosu yapacak ve sonra telefonlar tablosuna kategoriid sutunu ekleyeceğiz ya da direkt olarak başka tablo olmadan telefonlar tablosunda kategori sutunu ekleyeceğiz.
    referanslar ile bağlantı sağlayabiliriz.   mesela telefonlar tablosundaki kategoriid kolonuna referans ile bağlantı yaptık ve kategori tablosunda bağlandı. o zaman örnek olarak kategoriid 1 ise telefon olacak gibi.
    yani kategoriid ile kategori tablosundaki satırların id'leri birbiri ile bağlanmalı.  böylece örnek olarak 2 dersek kategoriid'ye o zaman id'si 2 olan veri yani bilgisayar olduğu belli olacak.

........foreign key.................................................................................................................................................................................

bir kategori tablosu sutunları id ve kategoriadı olacak   id = primary key, unique, auto increment, not null ve kategori adı ise not null olacak.
bir ürünler tablosu olacak ve ek olarak kategoriid sutunu ekleyeceğiz veri tipi ise kategori tablosundaki id kolununun veri tipi ile aynı olmalıdır.  ve eğer kategoriid'ye not null dersek o zaman illaki her ürün bir kategoriye ait olmalıdır deriz.
nasıl referans yapabiliriz = alter table ürünler add constraint fk_categories_produtcts foreign key(kategoriid) references kategori(id)   # yani kategoriid ile kategori tablosunun id sutunları birbiri ile ilişkilendirildi.

.........................................................................................................................................................................................



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////İlişkili tablolardan veri çekme.../////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inner join ile kesişimi alırız. ikisinde de sağlanan koşulu yakalarız. birbiri ile ilişkisi varsa tablonun o zaman farklı işlemler olacak.

select * from urunler inner join kategori on kategori.id = urunler.kategoriid   # iki tablo arasında inner join olacak ve hangi koşulda olacak bunu belirleriz.   bu durumda bir tuple içerisine iki tane satır gelir ve birleşir hem urun hemde kategori gelir.
 
select * from urunler inner join kategori on kategori.id = urunler.kategoriid where urunler.name = 'samsung'  böylece ismi samsung olanlar kategorisi ile gelir...

as ile isimlendirme yapabiliriz.
select p.name,p.price,c.name from urunler as p inner join kategori as c on p.kategoriid = c.id where p.name = 'samsung'    böylece tablo isimlendirmesi yapabiliriz as ile.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


####################################################################################################################################################################################################################################################################################################################################

pip install pymssql   ile mssql bağlantısı için gerekli connectoru yükleriz.

drop table if exists dersek eğer o zaman o tablo varsa onu yok et demek.

primary key olunca değerlerin kombinasyonları aynı olamaz mesela   id1 id2 id3 var  3ünün kombinasyonları bir kez var olabilir ama 3üde unique olursa o zaman hepsi birbirinden sürekli farklı olmak zorunda.

sqlite3 aslında gömülü bir veritabanı türü sql dili ile çalışır ama serverless'tir.   mesela bir mobil oyun yaptık oyun sadece çevrimdışı olacaksa ve verileri sadece kullanıcı kullanacaksa o zaman serverless bri veritabanı yeterlidir.   veya bir masaüstü uygulama olacak sadece veriler uygulamanın olduğu pcde tutulacak o zmn serverless db kullanmak mantıklıdır. 
     yani eğer datalara birden fazla uygulama, kullanıcı ulaşmayacaksa sadece açıp kapama ile verileri kaybolmasın istiyorsak o zaman sqlite3 kullanbiliriz...





