//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
jsx ile hem javascript hemde html css kodlarını aynı anda kullanmamızı sağlar.
npm install ile kurulumları yapabiliriz.
npm'in çalışması için node.js'i kurmamız gerekir.
main.jsx 

...................................
let name = "emre"
let name1 = "Aytas"
<div>
{name} + {name1}
</div>

yapısı ile kullanmak lazım
.....................................................................................................................................................................................................................................................
src altına genelde components klasörü oluştururuz. tekrar tekrar kullanmak istediğimiz yapılar için vs kullanabiliriz.  api,redux,containers vs gibi klasörler ekleyebiliriz.
........................................................................................................................................................................
components:

React'ta components (bileşenler), kullanıcı arayüzünü daha yönetilebilir ve yeniden kullanılabilir küçük parçalara bölmek için kullanılır. Her bileşen, uygulamanın belirli bir kısmının (örneğin bir düğme, bir form veya bir kullanıcı kartı) mantığını, görünümünü ve davranışını kapsar. Bu modüler yapı, kodun okunabilirliğini artırır, tekrar kullanım sağlar ve bakımını kolaylaştırır. Ayrıca, bileşenler arasında veri akışını (props ve state) yöneterek dinamik ve etkileşimli arayüzlerin oluşturulmasını sağlar.
her yerden çağırabiliriz metot mantığı gibidir bir yerde oluşturup sonra bir yerde çağırıp halledebiliriz.

        Örneğin, bir kullanıcı profili sayfası oluşturduğunuzu düşünelim. Bu sayfa; bir kullanıcı fotoğrafı, kullanıcı bilgileri ve bir düzenleme düğmesi gibi bölümlerden oluşabilir. React'ta bu bölümleri bileşenlere bölebiliriz:

        jsx

        // Kullanıcı Fotoğrafı Bileşeni
        const ProfilePhoto = ({ photoUrl }) => {
        return <img src={photoUrl} alt="Profile" className="profile-photo" />;
        };

        // Kullanıcı Bilgileri Bileşeni
        const UserInfo = ({ name, email }) => {
        return (
            <div>
            <h2>{name}</h2>
            <p>{email}</p>
            </div>
        );
        };

        // Düzenleme Düğmesi Bileşeni
        const EditButton = () => {
        return <button>Edit Profile</button>;
        };

        // Kullanıcı Profili Ana Bileşeni
        const UserProfile = ({ user }) => {
        return (
            <div className="user-profile">
            <ProfilePhoto photoUrl={user.photoUrl} />
            <UserInfo name={user.name} email={user.email} />
            <EditButton />
            </div>
        );
        };

        // Kullanımı
        const user = {
        photoUrl: "https://example.com/photo.jpg",
        name: "John Doe",
        email: "john.doe@example.com",
        };

        export default function App() {
        return <UserProfile user={user} />;
        }
        Avantaj: Bu şekilde her bileşen kendi sorumluluğunu taşır ve gerektiğinde bağımsız olarak yeniden kullanılabilir. Örneğin, ProfilePhoto bileşeni başka bir sayfada da kullanılabilir.

metot çağrısı mantığı ile tekrar tekrar yazmadan kullanbiliriz istediğimiz sistemleri.
..........................................................................
react props: 
 
        React'ta props (properties), bir bileşene dışarıdan veri aktarmak için kullanılan mekanizmadır. Props, bileşenin dışından geçilir ve bileşen içinde bir nesne olarak erişilebilir. Props, bileşenlerin daha dinamik ve tekrar kullanılabilir olmasını sağlar.

        Props'un Temel Özellikleri:
        Okunabilir (Read-only): Props yalnızca okunabilir olup bileşen içinde değiştirilemez. Bileşenin davranışı props'a göre belirlenir.
        Dinamik Veri Aktarımı: Bir bileşene farklı props değerleri geçirerek farklı çıktılar alınabilir.
        Fonksiyonel Bileşenlerde Kullanım: Fonksiyonel bileşenlerde props parametresi üzerinden erişilir.
        Props Nasıl Kullanılır?
        Bir bileşene props geçirmenin ve kullanmanın örneği:

        jsx.........
     
        // Mesaj Bileşeni
        const Message = (props) => {
        return <p>{props.text}</p>;
        };

        // Kullanımı
        export default function App() {
        return (
            <div>
            <Message text="Merhaba Dünya!" />
            <Message text="React öğrenmek çok eğlenceli!" />
            </div>
        );
        }
        Bu örnekte, Message bileşeni iki farklı props (text) ile çağrılmıştır. Her biri farklı bir metin gösterecektir.

        Destructuring ile Props Kullanımı
        Kodunuzu daha okunabilir yapmak için destructuring kullanılabilir:

        jsx......

        const Message = ({ text }) => {
        return <p>{text}</p>;
        };
        Bu yöntemle props.text yerine doğrudan text olarak erişebilirsiniz.

        Özet
        Props, React'ta veri veya işlevsellik taşımanın temel yoludur. Bu sayede bileşenler, aynı yapılarını korurken farklı verilerle dinamik davranışlar gösterebilir.

özellikler vererekte butonları değiştirebiliriz. tek bir yapı üstünde mesela buton üstündeki yazıyı değiştirerek işlemler yapabiliriz.
..............................................................................
Hooks: 


        React'ta Hooks, fonksiyon bileşenlerine sınıf bileşenlerinde mevcut olan durum (state) ve yaşam döngüsü (lifecycle) özelliklerini eklemenin bir yoludur. React 16.8 sürümüyle tanıtılmıştır. Hooks sayesinde fonksiyonel bileşenler daha güçlü ve esnek hale gelir.

        Hooks'un Temel Amacı:
        State ve diğer React özelliklerini sınıfsız kullanma: Daha az karmaşık kodla bileşenleri oluşturma.
        Kodun tekrar kullanılabilirliği: Hook'lar sayesinde kodunuzu daha modüler ve okunabilir hale getirebilirsiniz.
        Esneklik: Sınıflara bağlı kalmadan React özelliklerinden yararlanabilirsiniz.
        En Yaygın Kullanılan Hooks:
        1. useState
        Bir bileşenin durumunu (state) tanımlamak için kullanılır.
        State değiştikçe bileşen yeniden render edilir.
        Örnek:

        jsx

        import React, { useState } from "react";

        const Counter = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <p>Sayac: {count}</p>
            <button onClick={() => setCount(count + 1)}>Arttır</button>
            </div>
        );
        };

        export default Counter;
        2. useEffect
        Yan etkileri (side effects) yönetmek için kullanılır. Örneğin: veri çekme (fetching data), DOM güncellemeleri, abonelikler.
        Örnek:

        jsx

        import React, { useState, useEffect } from "react";

        const DataFetcher = () => {
        const [data, setData] = useState(null);

        useEffect(() => {
            fetch("https://jsonplaceholder.typicode.com/posts/1")
            .then(response => response.json())
            .then(data => setData(data));
        }, []); // Boş array, yalnızca ilk render'da çalışır.

        return <div>{data ? data.title : "Yükleniyor..."}</div>;
        };

        export default DataFetcher;
        3. useContext
        Context API ile birlikte kullanılarak, props zincirlemesi yapmadan verileri bileşenler arasında paylaşır.
        Örnek:

        jsx

        import React, { useContext, createContext } from "react";

        const ThemeContext = createContext();

        const App = () => {
        return (
            <ThemeContext.Provider value="dark">
            <Toolbar />
            </ThemeContext.Provider>
        );
        };

        const Toolbar = () => {
        const theme = useContext(ThemeContext);
        return <p>Güncel tema: {theme}</p>;
        };

        export default App;
        Hooks'un Avantajları:
        Daha Basit ve Temiz Kod: Sınıflar yerine fonksiyonlar kullanılır, karmaşıklık azalır.
        Kodun Tekrar Kullanımı: Özelleştirilmiş Hook'lar (Custom Hooks) oluşturabilirsiniz.
        Sınıf Karmaşıklığını Azaltır: this anahtar kelimesi veya yaşam döngüsü metotları ile uğraşmaya gerek kalmaz.
        Esneklik: Fonksiyon bileşenlerinde kullanılabilir.
        Hooks'un Sınırlamaları:
        Sadece Fonksiyon Bileşenlerinde Kullanılır: Sınıf bileşenlerinde kullanılamaz.
        Kurallara Bağlılık:
        Hook'lar sadece en üst seviyede çağrılmalı, döngüler, koşullar ya da iç içe fonksiyonlar içinde kullanılmamalıdır.
        Sadece React fonksiyon bileşenlerinde veya özelleştirilmiş Hook'larda kullanılabilir.
        Özet:
        Hooks, React bileşenlerinin daha modern, modüler ve güçlü olmasını sağlar. Özellikle state ve yaşam döngüsü yönetimini daha kolay bir şekilde sunar. En yaygın kullanılanları useState ve useEffect olsa da, React'te özel ihtiyaçlara yönelik başka birçok Hook bulunmaktadır.


..............................................................................
Map: arraylerle alakalı bir metottur. 

        React'ta map metodu, bir dizi öğesini tekrarlayarak her öğeden bir JSX elemanı oluşturmak için kullanılır. Genellikle bir listeyi render etmek için tercih edilir. React, her öğenin benzersiz bir şekilde tanımlanabilmesi için bir key özelliği gerektirir.

        Kullanım Şekli:
        map metodu, bir dizideki her öğeyi döner ve her bir öğeden bir yeni değer (örneğin bir JSX elemanı) döner.

        Sözdizimi:

        jsx

        array.map((element, index) => {
        // İşlem
        return JSXElement;
        });
        Örnek Kullanım:
        1. Basit Bir Listeyi Render Etme
        jsx
        Kodu kopyala
        import React from "react";

        const NameList = () => {
        const names = ["Ali", "Ayşe", "Mehmet", "Zeynep"];

        return (
            <ul>
            {names.map((name, index) => (
                <li key={index}>{name}</li> // key benzersiz bir değer olmalıdır
            ))}
            </ul>
        );
        };

        export default NameList;
        Çıktı:
        Ali
        Ayşe
        Mehmet
        Zeynep
        2. Bir Dizi Obje Üzerinde map Kullanımı
        jsx
        Kodu kopyala
        import React from "react";

        const ProductList = () => {
        const products = [
            { id: 1, name: "Telefon", price: 5000 },
            { id: 2, name: "Bilgisayar", price: 15000 },
            { id: 3, name: "Tablet", price: 3000 },
        ];

        return (
            <div>
            <h1>Ürün Listesi</h1>
            <ul>
                {products.map((product) => (
                <li key={product.id}>
                    {product.name} - {product.price} TL
                </li>
                ))}
            </ul>
            </div>
        );
        };

        export default ProductList;
        Çıktı:
        Telefon - 5000 TL
        Bilgisayar - 15000 TL
        Tablet - 3000 TL
        3. Koşullu Render ile map Kullanımı
        Bir öğeyi belirli bir koşula göre filtreleyerek gösterebilirsiniz:

        jsx

        import React from "react";

        const FilteredList = () => {
        const numbers = [1, 2, 3, 4, 5, 6];

        return (
            <ul>
            {numbers.map((number) =>
                number % 2 === 0 ? <li key={number}>{number} (Çift)</li> : null
            )}
            </ul>
        );
        };

        export default FilteredList;
        Çıktı:
        2 (Çift)
        4 (Çift)
        6 (Çift)
        React'ta key Özelliği
        key: React'in her liste öğesini benzersiz bir şekilde tanımlayabilmesi için gereklidir. Performansı artırır ve yanlış render'ların önüne geçer.
        Doğru key Kullanımı:
        Benzersiz bir değer (örneğin bir ID) olmalıdır.
        index yalnızca benzersiz bir ID yoksa kullanılmalıdır.
        Örnek:

        jsx

        <li key={product.id}>...</li>
        React'ta map Kullanmanın Avantajları
        Dinamik Liste Render'ı: Dizi içeriğini kolayca bir bileşene dönüştürür.
        Temiz ve Okunabilir Kod: Tekrarlı öğeleri render etmek için basit bir yapı sunar.
        Modülerlik: Dizi öğelerini bileşenlere dönüştürerek tekrar kullanılabilir yapılar oluşturabilirsiniz.
        Özet:
        React'ta map, diziler üzerinde tekrar yapmak ve her bir öğeyi JSX elemanına dönüştürmek için kullanılır. Basit bir liste render etmekten karmaşık koşullu yapıları işlemek için geniş bir kullanım alanına sahiptir. Benzersiz bir key ile performans optimizasyonu sağlanabilir.

..............................................................................
useEffect:

        React'ta useEffect, bir fonksiyon bileşeni içinde yan etkileri (side effects) yönetmek için kullanılan bir hook'tur. Yan etkiler, bileşenin işleyişine doğrudan bağlı olmayan işlemler olabilir; örneğin:

        Veri çekme (API çağrıları)
        DOM manipülasyonları
        Abonelik işlemleri
        Zamanlayıcılar veya interval kullanımları
        Temel Kullanım
        useEffect, bileşenler her render edildiğinde veya belirli bir bağımlılık değiştiğinde çalışır.

        Sözdizimi:

        jsx
        Kodu kopyala
        useEffect(() => {
        // Yan etki işlemleri
        return () => {
            // Temizlik işlemleri (cleanup)
        };
        }, [dependencies]); // Bağımlılıklar (dependencies) array'i
        Kullanım Detayları
        1. Her Render Sonrası Çalıştırma
        Varsayılan olarak, useEffect her render işleminden sonra çalışır.

        jsx
        Kodu kopyala
        import React, { useEffect } from "react";

        const Example = () => {
        useEffect(() => {
            console.log("Bileşen render edildi.");
        });

        return <div>Merhaba!</div>;
        };

        export default Example;
        2. Bir Kere Çalıştırma (ComponentDidMount)
        Bağımlılık dizisi boş bırakılırsa, useEffect yalnızca bileşen ilk kez yüklendiğinde çalışır.

        jsx
        Kodu kopyala
        useEffect(() => {
        console.log("Bileşen ilk kez yüklendi.");
        }, []);
        3. Belirli Değişkenler Değiştiğinde Çalıştırma
        Bağımlılık dizisine eklenen değişkenler değiştiğinde useEffect tekrar çalışır.

        jsx
        Kodu kopyala
        useEffect(() => {
        console.log("Sayac değeri değişti:", count);
        }, [count]); // Sadece count değiştiğinde çalışır
        4. Temizlik İşlemleri (Cleanup)
        Temizlik işlemleri (örneğin bir aboneliği iptal etmek veya interval'i temizlemek), useEffect'in dönüş fonksiyonunda yapılır.

        jsx
        Kodu kopyala
        useEffect(() => {
        const interval = setInterval(() => {
            console.log("Interval çalışıyor.");
        }, 1000);

        return () => {
            clearInterval(interval); // Bileşen kaldırıldığında interval temizlenir
        };
        }, []);
        Örnek Kullanımlar
        1. API'den Veri Çekme
        jsx
        Kodu kopyala
        import React, { useState, useEffect } from "react";
        import axios from "axios";

        const FetchData = () => {
        const [data, setData] = useState([]);

        useEffect(() => {
            const fetchData = async () => {
            const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
            setData(response.data);
            };

            fetchData();
        }, []); // Sadece bileşen ilk kez yüklendiğinde çalışır

        return (
            <ul>
            {data.map((item) => (
                <li key={item.id}>{item.title}</li>
            ))}
            </ul>
        );
        };

        export default FetchData;
        2. Zamanlayıcı Kullanımı
        jsx
        Kodu kopyala
        import React, { useState, useEffect } from "react";

        const Timer = () => {
        const [seconds, setSeconds] = useState(0);

        useEffect(() => {
            const interval = setInterval(() => {
            setSeconds((prev) => prev + 1);
            }, 1000);

            return () => clearInterval(interval); // Bileşen kaldırıldığında temizlenir
        }, []);

        return <div>Geçen Süre: {seconds} saniye</div>;
        };

        export default Timer;
        3. Pencere Boyutu Dinleme
        jsx
        Kodu kopyala
        import React, { useState, useEffect } from "react";

        const WindowSize = () => {
        const [width, setWidth] = useState(window.innerWidth);

        useEffect(() => {
            const handleResize = () => setWidth(window.innerWidth);

            window.addEventListener("resize", handleResize);

            return () => {
            window.removeEventListener("resize", handleResize); // Event temizlenir
            };
        }, []); // Bir kere çalışır ve dinleyiciyi ekler

        return <div>Pencere Genişliği: {width}px</div>;
        };

        export default WindowSize;
        Avantajları
        Yan Etki Yönetimi: API çağrıları, zamanlayıcılar, DOM manipülasyonları gibi işlemleri kolayca yönetir.
        Lifecycle Metotlarını Basitleştirir: Class bileşenlerde kullanılan componentDidMount, componentDidUpdate ve componentWillUnmount gibi lifecycle metotlarının yerine kullanılabilir.
        Esneklik: Bağımlılık dizisi sayesinde yalnızca gerekli olduğunda çalıştırılabilir.
        Dezavantajları
        Yanlış Kullanım: Bağımlılık dizisinin yanlış kullanımı sonsuz döngülere veya yanlış davranışlara yol açabilir.
        Hata Yönetimi: Karmaşık senaryolarda temiz ve okunabilir kod yazmak zor olabilir.
        Özet
        useEffect, React'ta bileşen yaşam döngüsüne bağlı yan etkileri kontrol etmek için kullanılır. API çağrıları, DOM manipülasyonları, zamanlayıcılar gibi işlemler için çok uygundur. Ancak bağımlılık dizisinin doğru kullanımı ve temizlik işlemlerinin yapılması önemlidir. 


..............................................................................
npm install react-router-dom ile routing işlemlerinde kullanacağımız sistemi indiririz.
..............................................................................
Route: 

        React'ta Route, kullanıcıların uygulama içinde farklı sayfalara veya bileşenlere yönlendirilmesini sağlayan bir yapıdır. React, tek sayfa uygulamaları (Single Page Applications, SPA) oluşturmak için kullanılır. Bu yapı içinde, farklı URL'lere göre bileşenleri veya sayfaları göstermek için React Router kullanılır. Route, bu yönlendirme işleminin temel yapı taşıdır.

        React Router
        React Router, React uygulamalarında yönlendirme (routing) işlemlerini yönetmek için kullanılan bir kütüphanedir. Bu kütüphane, uygulamanın farklı bölümleri arasında gezinmeyi sağlar ve kullanıcı deneyimini geliştiren bir SPA davranışı sunar.

        Route'un Çalışma Mantığı
        URL'yi Dinler: Kullanıcının tarayıcıdaki URL'sine bakar.
        Bileşen Gösterir: URL'ye göre uygun bileşeni ekrana getirir.
        Dinamik Yönlendirme: URL'deki değişikliklere dinamik olarak tepki verir ve sayfayı yenilemeden içerik değiştirir.
        Route Kullanımı
        1. React Router Kurulumu
        Öncelikle React Router kütüphanesini yüklemeniz gerekir:

        bash
        Kodu kopyala
        npm install react-router-dom
        2. Temel Kullanım
        jsx
        Kodu kopyala
        import React from "react";
        import { BrowserRouter as Router, Route, Routes } from "react-router-dom";

        const Home = () => <h1>Home Page</h1>;
        const About = () => <h1>About Page</h1>;
        const Contact = () => <h1>Contact Page</h1>;

        const App = () => {
        return (
            <Router>
            <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/about" element={<About />} />
                <Route path="/contact" element={<Contact />} />
            </Routes>
            </Router>
        );
        };

        export default App;
        <Router>: Uygulamanın yönlendirme yeteneklerini sağlar.
        <Routes>: Tüm <Route> öğelerini kapsar.
        <Route>: URL ile ilişkilendirilmiş bileşeni belirtir.
        path: URL yolu.
        element: Gösterilecek bileşen.
        Dinamik Route
        Bazı durumlarda, URL'deki bir parametreye bağlı olarak içerik göstermek isteyebilirsiniz. Örneğin, ürün detay sayfası:

        jsx
        Kodu kopyala
        import React from "react";
        import { BrowserRouter as Router, Route, Routes, useParams } from "react-router-dom";

        const Product = () => {
        const { id } = useParams(); // URL'deki 'id' parametresini alır
        return <h1>Product ID: {id}</h1>;
        };

        const App = () => {
        return (
            <Router>
            <Routes>
                <Route path="/product/:id" element={<Product />} />
            </Routes>
            </Router>
        );
        };

        export default App;
        :id: Dinamik parametre. /product/123 gibi bir URL'de id değeri 123 olur.
        useParams: Dinamik parametreleri almak için kullanılır.
        Link Kullanımı
        React Router ile gezinme işlemi için Link bileşeni kullanılır. Tarayıcıda sayfa yenilenmeden bir URL'ye yönlendirme sağlar.

        jsx
        Kodu kopyala
        import React from "react";
        import { BrowserRouter as Router, Route, Routes, Link } from "react-router-dom";

        const Home = () => <h1>Home Page</h1>;
        const About = () => <h1>About Page</h1>;

        const App = () => {
        return (
            <Router>
            <nav>
                <Link to="/">Home</Link> | <Link to="/about">About</Link>
            </nav>
            <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/about" element={<About />} />
            </Routes>
            </Router>
        );
        };

        export default App;
        <Link to="/">: Kullanıcıyı / URL'sine yönlendirir.
        Tarayıcıda sayfa yenilenmeden, SPA yapısına uygun bir şekilde içerik değiştirilir.
        Avantajları
        Hızlı ve Dinamik Gezinme: Sayfa yenileme olmadan yönlendirme yapılır.
        Basit Yapı: React bileşenleriyle kolayca entegre edilir.
        Dinamik Yönlendirme: Kullanıcının URL'deki değişikliklerine kolayca tepki verir.
        Modülerlik: Her sayfa veya bileşeni bir Route ile ilişkilendirerek uygulamayı düzenli tutabilirsiniz.
        Sonuç
        React Router, React'ta farklı sayfalara yönlendirme işlemlerini kolaylaştırır. <Route> bileşeni, belirli bir URL'yi bir bileşenle eşleştirerek SPA deneyimini sağlar. Bu yapı, modern web uygulamalarında kullanıcı deneyimini geliştirir ve dinamik içerik sunmayı mümkün kılar.


..............................................................................
useNavigate:


        useNavigate, React Router kütüphanesinde bir hook'tur ve React uygulamalarında programlı gezinme (navigasyon) yapmayı sağlar. Yani, kullanıcıyı belirli bir sayfaya yönlendirmek istediğinizde kullanılır. Bu işlem, genellikle bir butona tıklandığında veya bir işlemin tamamlanmasından sonra gerçekleştirilir.

        Özellikleri
        Tarayıcıdaki geçmiş (history) yığınına yeni bir giriş ekleyerek sayfa yönlendirmesi yapar.
        SPA (Single Page Application) mantığına uygun olarak sayfa yenilenmeden kullanıcıyı başka bir URL'ye taşır.
        Eski useHistory hook'unun yerini almıştır.
        Kullanım Şekli
        useNavigate React Router'dan import edilerek kullanılır. İşte temel kullanım:

        jsx
        Kodu kopyala
        import React from "react";
        import { useNavigate } from "react-router-dom";

        const HomePage = () => {
        const navigate = useNavigate();

        const goToAboutPage = () => {
            navigate("/about"); // Kullanıcıyı '/about' URL'sine yönlendirir
        };

        return (
            <div>
            <h1>Home Page</h1>
            <button onClick={goToAboutPage}>About Sayfasına Git</button>
            </div>
        );
        };

        export default HomePage;
        Parametreler
        navigate(path, options)
        path: Kullanıcıyı yönlendirmek istediğiniz URL (örn: "/about").
        options: Opsiyonel ayarlar.
        replace: true: Gezinmenin, tarayıcı geçmişinde yeni bir giriş oluşturmamasını sağlar (geri butonuyla önceki sayfaya dönülemez).
        state: Geçilen sayfaya veri gönderir.
        Örnekler
        1. Temel Kullanım
        jsx
        Kodu kopyala
        navigate("/about");
        Kullanıcıyı /about URL'sine yönlendirir.

        2. Geçici Yönlendirme (Replace)
        jsx
        Kodu kopyala
        navigate("/about", { replace: true });
        Bu yönlendirme, tarayıcı geçmişinde yeni bir giriş oluşturmaz. Kullanıcı geri butonuna tıkladığında yönlendirmeden önceki sayfaya dönemez.

        3. Veri Gönderme
        jsx
        Kodu kopyala
        navigate("/details", { state: { userId: 123 } });
        state parametresiyle yönlendirilen sayfaya veri gönderebilirsiniz. Bu veri, useLocation hook'u ile alınabilir.

        jsx
        Kodu kopyala
        import { useLocation } from "react-router-dom";

        const DetailsPage = () => {
        const location = useLocation();
        const { userId } = location.state || {};

        return <h1>Kullanıcı ID: {userId}</h1>;
        };
        Senaryolar
        Form İşlemleri: Form gönderildikten sonra kullanıcıyı teşekkür sayfasına yönlendirme.
        Doğrulama Sonrası: Kullanıcı girişi tamamlandıktan sonra dashboard sayfasına yönlendirme.
        Dinamik Yönlendirme: Bir liste elemanına tıklandığında detay sayfasına yönlendirme.
        Avantajları
        React Router'ın SPA yapısına uygun olarak yönlendirme yapar.
        Kullanıcı deneyimini geliştirmek için programlı gezinme sağlar.
        State ile veri taşıma imkanı sunar.
        Sonuç
        useNavigate, React Router ile kullanıcı yönlendirme işlemlerini hızlı ve verimli bir şekilde yapmayı sağlar. Özellikle form gönderimleri, giriş işlemleri veya kullanıcı etkileşimleri sonrasında belirli sayfalara geçiş için sıkça kullanılır.

..............................................................................


..............................................................................


..............................................................................


..............................................................................


..............................................................................


..............................................................................

..............................................................................






