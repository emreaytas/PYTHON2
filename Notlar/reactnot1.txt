//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
jsx ile hem javascript hemde html css kodlarını aynı anda kullanmamızı sağlar.
npm install ile kurulumları yapabiliriz.
npm'in çalışması için node.js'i kurmamız gerekir.
main.jsx 

...................................
let name = "emre"
let name1 = "Aytas"
<div>
{name} + {name1}
</div>

yapısı ile kullanmak lazım
.....................................................................................................................................................................................................................................................
src altına genelde components klasörü oluştururuz. tekrar tekrar kullanmak istediğimiz yapılar için vs kullanabiliriz.  api,redux,containers vs gibi klasörler ekleyebiliriz.
........................................................................................................................................................................
components:

React'ta components (bileşenler), kullanıcı arayüzünü daha yönetilebilir ve yeniden kullanılabilir küçük parçalara bölmek için kullanılır. Her bileşen, uygulamanın belirli bir kısmının (örneğin bir düğme, bir form veya bir kullanıcı kartı) mantığını, görünümünü ve davranışını kapsar. Bu modüler yapı, kodun okunabilirliğini artırır, tekrar kullanım sağlar ve bakımını kolaylaştırır. Ayrıca, bileşenler arasında veri akışını (props ve state) yöneterek dinamik ve etkileşimli arayüzlerin oluşturulmasını sağlar.
her yerden çağırabiliriz metot mantığı gibidir bir yerde oluşturup sonra bir yerde çağırıp halledebiliriz.

        Örneğin, bir kullanıcı profili sayfası oluşturduğunuzu düşünelim. Bu sayfa; bir kullanıcı fotoğrafı, kullanıcı bilgileri ve bir düzenleme düğmesi gibi bölümlerden oluşabilir. React'ta bu bölümleri bileşenlere bölebiliriz:

        jsx

        // Kullanıcı Fotoğrafı Bileşeni
        const ProfilePhoto = ({ photoUrl }) => {
        return <img src={photoUrl} alt="Profile" className="profile-photo" />;
        };

        // Kullanıcı Bilgileri Bileşeni
        const UserInfo = ({ name, email }) => {
        return (
            <div>
            <h2>{name}</h2>
            <p>{email}</p>
            </div>
        );
        };

        // Düzenleme Düğmesi Bileşeni
        const EditButton = () => {
        return <button>Edit Profile</button>;
        };

        // Kullanıcı Profili Ana Bileşeni
        const UserProfile = ({ user }) => {
        return (
            <div className="user-profile">
            <ProfilePhoto photoUrl={user.photoUrl} />
            <UserInfo name={user.name} email={user.email} />
            <EditButton />
            </div>
        );
        };

        // Kullanımı
        const user = {
        photoUrl: "https://example.com/photo.jpg",
        name: "John Doe",
        email: "john.doe@example.com",
        };

        export default function App() {
        return <UserProfile user={user} />;
        }
        Avantaj: Bu şekilde her bileşen kendi sorumluluğunu taşır ve gerektiğinde bağımsız olarak yeniden kullanılabilir. Örneğin, ProfilePhoto bileşeni başka bir sayfada da kullanılabilir.

metot çağrısı mantığı ile tekrar tekrar yazmadan kullanbiliriz istediğimiz sistemleri.
..........................................................................
react props: 
 
        React'ta props (properties), bir bileşene dışarıdan veri aktarmak için kullanılan mekanizmadır. Props, bileşenin dışından geçilir ve bileşen içinde bir nesne olarak erişilebilir. Props, bileşenlerin daha dinamik ve tekrar kullanılabilir olmasını sağlar.

        Props'un Temel Özellikleri:
        Okunabilir (Read-only): Props yalnızca okunabilir olup bileşen içinde değiştirilemez. Bileşenin davranışı props'a göre belirlenir.
        Dinamik Veri Aktarımı: Bir bileşene farklı props değerleri geçirerek farklı çıktılar alınabilir.
        Fonksiyonel Bileşenlerde Kullanım: Fonksiyonel bileşenlerde props parametresi üzerinden erişilir.
        Props Nasıl Kullanılır?
        Bir bileşene props geçirmenin ve kullanmanın örneği:

        jsx.........
     
        // Mesaj Bileşeni
        const Message = (props) => {
        return <p>{props.text}</p>;
        };

        // Kullanımı
        export default function App() {
        return (
            <div>
            <Message text="Merhaba Dünya!" />
            <Message text="React öğrenmek çok eğlenceli!" />
            </div>
        );
        }
        Bu örnekte, Message bileşeni iki farklı props (text) ile çağrılmıştır. Her biri farklı bir metin gösterecektir.

        Destructuring ile Props Kullanımı
        Kodunuzu daha okunabilir yapmak için destructuring kullanılabilir:

        jsx......

        const Message = ({ text }) => {
        return <p>{text}</p>;
        };
        Bu yöntemle props.text yerine doğrudan text olarak erişebilirsiniz.

        Özet
        Props, React'ta veri veya işlevsellik taşımanın temel yoludur. Bu sayede bileşenler, aynı yapılarını korurken farklı verilerle dinamik davranışlar gösterebilir.

özellikler vererekte butonları değiştirebiliriz. tek bir yapı üstünde mesela buton üstündeki yazıyı değiştirerek işlemler yapabiliriz.
..............................................................................
Hooks: 


        React'ta Hooks, fonksiyon bileşenlerine sınıf bileşenlerinde mevcut olan durum (state) ve yaşam döngüsü (lifecycle) özelliklerini eklemenin bir yoludur. React 16.8 sürümüyle tanıtılmıştır. Hooks sayesinde fonksiyonel bileşenler daha güçlü ve esnek hale gelir.

        Hooks'un Temel Amacı:
        State ve diğer React özelliklerini sınıfsız kullanma: Daha az karmaşık kodla bileşenleri oluşturma.
        Kodun tekrar kullanılabilirliği: Hook'lar sayesinde kodunuzu daha modüler ve okunabilir hale getirebilirsiniz.
        Esneklik: Sınıflara bağlı kalmadan React özelliklerinden yararlanabilirsiniz.
        En Yaygın Kullanılan Hooks:
        1. useState
        Bir bileşenin durumunu (state) tanımlamak için kullanılır.
        State değiştikçe bileşen yeniden render edilir.
        Örnek:

        jsx

        import React, { useState } from "react";

        const Counter = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <p>Sayac: {count}</p>
            <button onClick={() => setCount(count + 1)}>Arttır</button>
            </div>
        );
        };

        export default Counter;
        2. useEffect
        Yan etkileri (side effects) yönetmek için kullanılır. Örneğin: veri çekme (fetching data), DOM güncellemeleri, abonelikler.
        Örnek:

        jsx

        import React, { useState, useEffect } from "react";

        const DataFetcher = () => {
        const [data, setData] = useState(null);

        useEffect(() => {
            fetch("https://jsonplaceholder.typicode.com/posts/1")
            .then(response => response.json())
            .then(data => setData(data));
        }, []); // Boş array, yalnızca ilk render'da çalışır.

        return <div>{data ? data.title : "Yükleniyor..."}</div>;
        };

        export default DataFetcher;
        3. useContext
        Context API ile birlikte kullanılarak, props zincirlemesi yapmadan verileri bileşenler arasında paylaşır.
        Örnek:

        jsx

        import React, { useContext, createContext } from "react";

        const ThemeContext = createContext();

        const App = () => {
        return (
            <ThemeContext.Provider value="dark">
            <Toolbar />
            </ThemeContext.Provider>
        );
        };

        const Toolbar = () => {
        const theme = useContext(ThemeContext);
        return <p>Güncel tema: {theme}</p>;
        };

        export default App;
        Hooks'un Avantajları:
        Daha Basit ve Temiz Kod: Sınıflar yerine fonksiyonlar kullanılır, karmaşıklık azalır.
        Kodun Tekrar Kullanımı: Özelleştirilmiş Hook'lar (Custom Hooks) oluşturabilirsiniz.
        Sınıf Karmaşıklığını Azaltır: this anahtar kelimesi veya yaşam döngüsü metotları ile uğraşmaya gerek kalmaz.
        Esneklik: Fonksiyon bileşenlerinde kullanılabilir.
        Hooks'un Sınırlamaları:
        Sadece Fonksiyon Bileşenlerinde Kullanılır: Sınıf bileşenlerinde kullanılamaz.
        Kurallara Bağlılık:
        Hook'lar sadece en üst seviyede çağrılmalı, döngüler, koşullar ya da iç içe fonksiyonlar içinde kullanılmamalıdır.
        Sadece React fonksiyon bileşenlerinde veya özelleştirilmiş Hook'larda kullanılabilir.
        Özet:
        Hooks, React bileşenlerinin daha modern, modüler ve güçlü olmasını sağlar. Özellikle state ve yaşam döngüsü yönetimini daha kolay bir şekilde sunar. En yaygın kullanılanları useState ve useEffect olsa da, React'te özel ihtiyaçlara yönelik başka birçok Hook bulunmaktadır.


..............................................................................
Map: arraylerle alakalı bir metottur. 

        React'ta map metodu, bir dizi öğesini tekrarlayarak her öğeden bir JSX elemanı oluşturmak için kullanılır. Genellikle bir listeyi render etmek için tercih edilir. React, her öğenin benzersiz bir şekilde tanımlanabilmesi için bir key özelliği gerektirir.

        Kullanım Şekli:
        map metodu, bir dizideki her öğeyi döner ve her bir öğeden bir yeni değer (örneğin bir JSX elemanı) döner.

        Sözdizimi:

        jsx

        array.map((element, index) => {
        // İşlem
        return JSXElement;
        });
        Örnek Kullanım:
        1. Basit Bir Listeyi Render Etme
        jsx
        Kodu kopyala
        import React from "react";

        const NameList = () => {
        const names = ["Ali", "Ayşe", "Mehmet", "Zeynep"];

        return (
            <ul>
            {names.map((name, index) => (
                <li key={index}>{name}</li> // key benzersiz bir değer olmalıdır
            ))}
            </ul>
        );
        };

        export default NameList;
        Çıktı:
        Ali
        Ayşe
        Mehmet
        Zeynep
        2. Bir Dizi Obje Üzerinde map Kullanımı
        jsx
        Kodu kopyala
        import React from "react";

        const ProductList = () => {
        const products = [
            { id: 1, name: "Telefon", price: 5000 },
            { id: 2, name: "Bilgisayar", price: 15000 },
            { id: 3, name: "Tablet", price: 3000 },
        ];

        return (
            <div>
            <h1>Ürün Listesi</h1>
            <ul>
                {products.map((product) => (
                <li key={product.id}>
                    {product.name} - {product.price} TL
                </li>
                ))}
            </ul>
            </div>
        );
        };

        export default ProductList;
        Çıktı:
        Telefon - 5000 TL
        Bilgisayar - 15000 TL
        Tablet - 3000 TL
        3. Koşullu Render ile map Kullanımı
        Bir öğeyi belirli bir koşula göre filtreleyerek gösterebilirsiniz:

        jsx

        import React from "react";

        const FilteredList = () => {
        const numbers = [1, 2, 3, 4, 5, 6];

        return (
            <ul>
            {numbers.map((number) =>
                number % 2 === 0 ? <li key={number}>{number} (Çift)</li> : null
            )}
            </ul>
        );
        };

        export default FilteredList;
        Çıktı:
        2 (Çift)
        4 (Çift)
        6 (Çift)
        React'ta key Özelliği
        key: React'in her liste öğesini benzersiz bir şekilde tanımlayabilmesi için gereklidir. Performansı artırır ve yanlış render'ların önüne geçer.
        Doğru key Kullanımı:
        Benzersiz bir değer (örneğin bir ID) olmalıdır.
        index yalnızca benzersiz bir ID yoksa kullanılmalıdır.
        Örnek:

        jsx

        <li key={product.id}>...</li>
        React'ta map Kullanmanın Avantajları
        Dinamik Liste Render'ı: Dizi içeriğini kolayca bir bileşene dönüştürür.
        Temiz ve Okunabilir Kod: Tekrarlı öğeleri render etmek için basit bir yapı sunar.
        Modülerlik: Dizi öğelerini bileşenlere dönüştürerek tekrar kullanılabilir yapılar oluşturabilirsiniz.
        Özet:
        React'ta map, diziler üzerinde tekrar yapmak ve her bir öğeyi JSX elemanına dönüştürmek için kullanılır. Basit bir liste render etmekten karmaşık koşullu yapıları işlemek için geniş bir kullanım alanına sahiptir. Benzersiz bir key ile performans optimizasyonu sağlanabilir.

..............................................................................
useEffect:

        React'ta useEffect, bir fonksiyon bileşeni içinde yan etkileri (side effects) yönetmek için kullanılan bir hook'tur. Yan etkiler, bileşenin işleyişine doğrudan bağlı olmayan işlemler olabilir; örneğin:

        Veri çekme (API çağrıları)
        DOM manipülasyonları
        Abonelik işlemleri
        Zamanlayıcılar veya interval kullanımları
        Temel Kullanım
        useEffect, bileşenler her render edildiğinde veya belirli bir bağımlılık değiştiğinde çalışır.

        Sözdizimi:

        jsx
        Kodu kopyala
        useEffect(() => {
        // Yan etki işlemleri
        return () => {
            // Temizlik işlemleri (cleanup)
        };
        }, [dependencies]); // Bağımlılıklar (dependencies) array'i
        Kullanım Detayları
        1. Her Render Sonrası Çalıştırma
        Varsayılan olarak, useEffect her render işleminden sonra çalışır.

        jsx
        Kodu kopyala
        import React, { useEffect } from "react";

        const Example = () => {
        useEffect(() => {
            console.log("Bileşen render edildi.");
        });

        return <div>Merhaba!</div>;
        };

        export default Example;
        2. Bir Kere Çalıştırma (ComponentDidMount)
        Bağımlılık dizisi boş bırakılırsa, useEffect yalnızca bileşen ilk kez yüklendiğinde çalışır.

        jsx
        Kodu kopyala
        useEffect(() => {
        console.log("Bileşen ilk kez yüklendi.");
        }, []);
        3. Belirli Değişkenler Değiştiğinde Çalıştırma
        Bağımlılık dizisine eklenen değişkenler değiştiğinde useEffect tekrar çalışır.

        jsx
        Kodu kopyala
        useEffect(() => {
        console.log("Sayac değeri değişti:", count);
        }, [count]); // Sadece count değiştiğinde çalışır
        4. Temizlik İşlemleri (Cleanup)
        Temizlik işlemleri (örneğin bir aboneliği iptal etmek veya interval'i temizlemek), useEffect'in dönüş fonksiyonunda yapılır.

        jsx
        Kodu kopyala
        useEffect(() => {
        const interval = setInterval(() => {
            console.log("Interval çalışıyor.");
        }, 1000);

        return () => {
            clearInterval(interval); // Bileşen kaldırıldığında interval temizlenir
        };
        }, []);
        Örnek Kullanımlar
        1. API'den Veri Çekme
        jsx
        Kodu kopyala
        import React, { useState, useEffect } from "react";
        import axios from "axios";

        const FetchData = () => {
        const [data, setData] = useState([]);

        useEffect(() => {
            const fetchData = async () => {
            const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
            setData(response.data);
            };

            fetchData();
        }, []); // Sadece bileşen ilk kez yüklendiğinde çalışır

        return (
            <ul>
            {data.map((item) => (
                <li key={item.id}>{item.title}</li>
            ))}
            </ul>
        );
        };

        export default FetchData;
        2. Zamanlayıcı Kullanımı
        jsx
        Kodu kopyala
        import React, { useState, useEffect } from "react";

        const Timer = () => {
        const [seconds, setSeconds] = useState(0);

        useEffect(() => {
            const interval = setInterval(() => {
            setSeconds((prev) => prev + 1);
            }, 1000);

            return () => clearInterval(interval); // Bileşen kaldırıldığında temizlenir
        }, []);

        return <div>Geçen Süre: {seconds} saniye</div>;
        };

        export default Timer;
        3. Pencere Boyutu Dinleme
        jsx
        Kodu kopyala
        import React, { useState, useEffect } from "react";

        const WindowSize = () => {
        const [width, setWidth] = useState(window.innerWidth);

        useEffect(() => {
            const handleResize = () => setWidth(window.innerWidth);

            window.addEventListener("resize", handleResize);

            return () => {
            window.removeEventListener("resize", handleResize); // Event temizlenir
            };
        }, []); // Bir kere çalışır ve dinleyiciyi ekler

        return <div>Pencere Genişliği: {width}px</div>;
        };

        export default WindowSize;
        Avantajları
        Yan Etki Yönetimi: API çağrıları, zamanlayıcılar, DOM manipülasyonları gibi işlemleri kolayca yönetir.
        Lifecycle Metotlarını Basitleştirir: Class bileşenlerde kullanılan componentDidMount, componentDidUpdate ve componentWillUnmount gibi lifecycle metotlarının yerine kullanılabilir.
        Esneklik: Bağımlılık dizisi sayesinde yalnızca gerekli olduğunda çalıştırılabilir.
        Dezavantajları
        Yanlış Kullanım: Bağımlılık dizisinin yanlış kullanımı sonsuz döngülere veya yanlış davranışlara yol açabilir.
        Hata Yönetimi: Karmaşık senaryolarda temiz ve okunabilir kod yazmak zor olabilir.
        Özet
        useEffect, React'ta bileşen yaşam döngüsüne bağlı yan etkileri kontrol etmek için kullanılır. API çağrıları, DOM manipülasyonları, zamanlayıcılar gibi işlemler için çok uygundur. Ancak bağımlılık dizisinin doğru kullanımı ve temizlik işlemlerinin yapılması önemlidir. 


..............................................................................
npm install react-router-dom ile routing işlemlerinde kullanacağımız sistemi indiririz.
..............................................................................
Route: 

        React'ta Route, kullanıcıların uygulama içinde farklı sayfalara veya bileşenlere yönlendirilmesini sağlayan bir yapıdır. React, tek sayfa uygulamaları (Single Page Applications, SPA) oluşturmak için kullanılır. Bu yapı içinde, farklı URL'lere göre bileşenleri veya sayfaları göstermek için React Router kullanılır. Route, bu yönlendirme işleminin temel yapı taşıdır.

        React Router
        React Router, React uygulamalarında yönlendirme (routing) işlemlerini yönetmek için kullanılan bir kütüphanedir. Bu kütüphane, uygulamanın farklı bölümleri arasında gezinmeyi sağlar ve kullanıcı deneyimini geliştiren bir SPA davranışı sunar.

        Route'un Çalışma Mantığı
        URL'yi Dinler: Kullanıcının tarayıcıdaki URL'sine bakar.
        Bileşen Gösterir: URL'ye göre uygun bileşeni ekrana getirir.
        Dinamik Yönlendirme: URL'deki değişikliklere dinamik olarak tepki verir ve sayfayı yenilemeden içerik değiştirir.
        Route Kullanımı
        1. React Router Kurulumu
        Öncelikle React Router kütüphanesini yüklemeniz gerekir:

        bash
        Kodu kopyala
        npm install react-router-dom
        2. Temel Kullanım
        jsx
        Kodu kopyala
        import React from "react";
        import { BrowserRouter as Router, Route, Routes } from "react-router-dom";

        const Home = () => <h1>Home Page</h1>;
        const About = () => <h1>About Page</h1>;
        const Contact = () => <h1>Contact Page</h1>;

        const App = () => {
        return (
            <Router>
            <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/about" element={<About />} />
                <Route path="/contact" element={<Contact />} />
            </Routes>
            </Router>
        );
        };

        export default App;
        <Router>: Uygulamanın yönlendirme yeteneklerini sağlar.
        <Routes>: Tüm <Route> öğelerini kapsar.
        <Route>: URL ile ilişkilendirilmiş bileşeni belirtir.
        path: URL yolu.
        element: Gösterilecek bileşen.
        Dinamik Route
        Bazı durumlarda, URL'deki bir parametreye bağlı olarak içerik göstermek isteyebilirsiniz. Örneğin, ürün detay sayfası:

        jsx
        Kodu kopyala
        import React from "react";
        import { BrowserRouter as Router, Route, Routes, useParams } from "react-router-dom";

        const Product = () => {
        const { id } = useParams(); // URL'deki 'id' parametresini alır
        return <h1>Product ID: {id}</h1>;
        };

        const App = () => {
        return (
            <Router>
            <Routes>
                <Route path="/product/:id" element={<Product />} />
            </Routes>
            </Router>
        );
        };

        export default App;
        :id: Dinamik parametre. /product/123 gibi bir URL'de id değeri 123 olur.
        useParams: Dinamik parametreleri almak için kullanılır.
        Link Kullanımı
        React Router ile gezinme işlemi için Link bileşeni kullanılır. Tarayıcıda sayfa yenilenmeden bir URL'ye yönlendirme sağlar.

        jsx
        Kodu kopyala
        import React from "react";
        import { BrowserRouter as Router, Route, Routes, Link } from "react-router-dom";

        const Home = () => <h1>Home Page</h1>;
        const About = () => <h1>About Page</h1>;

        const App = () => {
        return (
            <Router>
            <nav>
                <Link to="/">Home</Link> | <Link to="/about">About</Link>
            </nav>
            <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/about" element={<About />} />
            </Routes>
            </Router>
        );
        };

        export default App;
        <Link to="/">: Kullanıcıyı / URL'sine yönlendirir.
        Tarayıcıda sayfa yenilenmeden, SPA yapısına uygun bir şekilde içerik değiştirilir.
        Avantajları
        Hızlı ve Dinamik Gezinme: Sayfa yenileme olmadan yönlendirme yapılır.
        Basit Yapı: React bileşenleriyle kolayca entegre edilir.
        Dinamik Yönlendirme: Kullanıcının URL'deki değişikliklerine kolayca tepki verir.
        Modülerlik: Her sayfa veya bileşeni bir Route ile ilişkilendirerek uygulamayı düzenli tutabilirsiniz.
        Sonuç
        React Router, React'ta farklı sayfalara yönlendirme işlemlerini kolaylaştırır. <Route> bileşeni, belirli bir URL'yi bir bileşenle eşleştirerek SPA deneyimini sağlar. Bu yapı, modern web uygulamalarında kullanıcı deneyimini geliştirir ve dinamik içerik sunmayı mümkün kılar.


..............................................................................
useNavigate:


        useNavigate, React Router kütüphanesinde bir hook'tur ve React uygulamalarında programlı gezinme (navigasyon) yapmayı sağlar. Yani, kullanıcıyı belirli bir sayfaya yönlendirmek istediğinizde kullanılır. Bu işlem, genellikle bir butona tıklandığında veya bir işlemin tamamlanmasından sonra gerçekleştirilir.

        Özellikleri
        Tarayıcıdaki geçmiş (history) yığınına yeni bir giriş ekleyerek sayfa yönlendirmesi yapar.
        SPA (Single Page Application) mantığına uygun olarak sayfa yenilenmeden kullanıcıyı başka bir URL'ye taşır.
        Eski useHistory hook'unun yerini almıştır.
        Kullanım Şekli
        useNavigate React Router'dan import edilerek kullanılır. İşte temel kullanım:

        jsx
        Kodu kopyala
        import React from "react";
        import { useNavigate } from "react-router-dom";

        const HomePage = () => {
        const navigate = useNavigate();

        const goToAboutPage = () => {
            navigate("/about"); // Kullanıcıyı '/about' URL'sine yönlendirir
        };

        return (
            <div>
            <h1>Home Page</h1>
            <button onClick={goToAboutPage}>About Sayfasına Git</button>
            </div>
        );
        };

        export default HomePage;
        Parametreler
        navigate(path, options)
        path: Kullanıcıyı yönlendirmek istediğiniz URL (örn: "/about").
        options: Opsiyonel ayarlar.
        replace: true: Gezinmenin, tarayıcı geçmişinde yeni bir giriş oluşturmamasını sağlar (geri butonuyla önceki sayfaya dönülemez).
        state: Geçilen sayfaya veri gönderir.
        Örnekler
        1. Temel Kullanım
        jsx
        Kodu kopyala
        navigate("/about");
        Kullanıcıyı /about URL'sine yönlendirir.

        2. Geçici Yönlendirme (Replace)
        jsx
        Kodu kopyala
        navigate("/about", { replace: true });
        Bu yönlendirme, tarayıcı geçmişinde yeni bir giriş oluşturmaz. Kullanıcı geri butonuna tıkladığında yönlendirmeden önceki sayfaya dönemez.

        3. Veri Gönderme
        jsx
        Kodu kopyala
        navigate("/details", { state: { userId: 123 } });
        state parametresiyle yönlendirilen sayfaya veri gönderebilirsiniz. Bu veri, useLocation hook'u ile alınabilir.

        jsx
        Kodu kopyala
        import { useLocation } from "react-router-dom";

        const DetailsPage = () => {
        const location = useLocation();
        const { userId } = location.state || {};

        return <h1>Kullanıcı ID: {userId}</h1>;
        };
        Senaryolar
        Form İşlemleri: Form gönderildikten sonra kullanıcıyı teşekkür sayfasına yönlendirme.
        Doğrulama Sonrası: Kullanıcı girişi tamamlandıktan sonra dashboard sayfasına yönlendirme.
        Dinamik Yönlendirme: Bir liste elemanına tıklandığında detay sayfasına yönlendirme.
        Avantajları
        React Router'ın SPA yapısına uygun olarak yönlendirme yapar.
        Kullanıcı deneyimini geliştirmek için programlı gezinme sağlar.
        State ile veri taşıma imkanı sunar.
        Sonuç
        useNavigate, React Router ile kullanıcı yönlendirme işlemlerini hızlı ve verimli bir şekilde yapmayı sağlar. Özellikle form gönderimleri, giriş işlemleri veya kullanıcı etkileşimleri sonrasında belirli sayfalara geçiş için sıkça kullanılır.

..............................................................................
useRef: 

            useRef ile State Alternatifi:
            useRef, state'in aksine bir bileşen yeniden render edildiğinde değişmeden kalır. Bu, performans gerektiren durumlarda faydalıdır.

            Örnek:
            jsx
            Kodu kopyala
            import React, { useRef, useState } from "react";

            const Counter = () => {
            const countRef = useRef(0); // Ref ile sayaç
            const [state, setState] = useState(0); // State ile sayaç

            const increment = () => {
                countRef.current += 1; // State'i değiştirmeden artış
                console.log("Ref Count:", countRef.current);

                setState(state + 1); // State'i artırarak render
            };

            return (
                <div>
                <p>State Count: {state}</p>
                <p>Ref Count (render yok): {countRef.current}</p>
                <button onClick={increment}>Artır</button>
                </div>
            );
            };

            export default Counter;
            Sonuç:

            state değiştiğinde bileşen yeniden render edilir.
            useRef değiştiğinde render edilmez.
            DOM Manipülasyonu ve useRef:
            Bir DOM öğesine doğrudan erişmek için useRef kullanılabilir. Örneğin, bir form alanını temizlemek veya belirli bir HTML elemanını odaklamak için kullanılabilir.

            Örnek:
            jsx
            Kodu kopyala
            import React, { useRef } from "react";

            const DomManipulation = () => {
            const inputRef = useRef(null);

            const handleClear = () => {
                inputRef.current.value = ""; // Input alanını temizler
            };

            return (
                <div>
                <input ref={inputRef} type="text" placeholder="Adınızı girin" />
                <button onClick={handleClear}>Temizle</button>
                </div>
            );
            };

            export default DomManipulation;
            Önemli Noktalar:
            useRef ve State Farkı:

            useRef: Değer değişir, ancak render tetiklenmez.
            state: Değer değişir ve render tetiklenir.
            Ref'in Başlangıç Değeri:

            useRef(initialValue) ile başlangıç değeri atanabilir.
            Örneğin: const ref = useRef(0);
            current Özelliği:

            useRef tarafından döndürülen nesne, current özelliğiyle değer taşır.
            ref.current üzerinden değer okunur veya yazılır.
            React'in Ref Kullanımı:

            Ref doğrudan DOM manipülasyonu gerektiğinde kullanılır. Ancak, React'in kontrollü bileşenler kullanımı önerilir.
            Ne Zaman Kullanılır?
            DOM'a doğrudan erişim gerektiğinde (örneğin, odaklama, temizleme, animasyon).
            Bir değeri tutmak ama yeniden render istememek gerektiğinde (örneğin, sayaç, önceki değer saklama).
            Performansı artırmak için state yerine kullanılabilir.
            Avantajları:
            Performansı artırır çünkü bileşen yeniden render edilmez.
            DOM'a erişimi kolaylaştırır.
            Dezavantajları:
            React'in "kontrollü bileşen" prensibini ihlal edebilir.
            Karmaşık kullanım durumlarında kod okunabilirliğini azaltabilir.
            Sonuç:
            useRef, React uygulamalarında hem DOM manipülasyonu hem de render tetiklemeden veri saklama gibi farklı senaryolar için güçlü ve esnek bir araçtır. Ancak, gereksiz yere kullanımı React'in kontrolsüz

..............................................................................
state sayfayı render eder her çalışmada. useref ise kendi alanını değiştirir sadece: 


    React'te useState ve useRef iki farklı amaç için kullanılan hook'lardır. Her ikisi de bileşenlerin durumunu yönetmek için kullanılsa da, işlevsel olarak önemli farkları vardır. İşte bu iki hook arasındaki temel farklar:

    1. Temel Fark
    Özellik	useState	useRef
    Yeniden Render	Değeri değiştiğinde bileşeni yeniden render eder.	Değeri değişse bile bileşeni yeniden render etmez.
    Amacı	Bileşen durumunu takip etmek ve değişikliklerde UI'yı güncellemek için kullanılır.	DOM manipülasyonu yapmak veya bir değişkeni saklamak için kullanılır.
    2. Kullanım Amacı
    useState:

    Bileşenin durumunu yönetir ve UI'yi otomatik olarak günceller.
    Kullanıcı etkileşimleri, form verileri gibi bileşenin durumunu etkileyen her şey için kullanılır.
    useRef:

    Değer değişikliği durumunda bileşeni yeniden render etmeden, bir değişkeni saklamak için kullanılır.
    DOM elemanlarına doğrudan erişim veya bir değer izleme için uygundur.
    3. Performans
    useState: Değeri değiştiğinde React bileşeni yeniden render eder. Bu, performans gereksinimleri yüksek uygulamalarda maliyetli olabilir.
    useRef: Performans dostudur, çünkü değeri değiştirmek bileşenin yeniden render edilmesine neden olmaz.
    4. Kullanım Örnekleri
    useState Kullanımı:
    jsx
    Kodu kopyala
    import React, { useState } from "react";

    const Counter = () => {
    const [count, setCount] = useState(0);

    return (
        <div>
        <p>Sayaç: {count}</p>
        <button onClick={() => setCount(count + 1)}>Artır</button>
        </div>
    );
    };

    export default Counter;
    Açıklama:
    useState ile sayaç durumu takip edilir ve her butona tıklamada bileşen yeniden render edilir.
    useRef Kullanımı:
    jsx
    Kodu kopyala
    import React, { useRef } from "react";

    const CounterWithRef = () => {
    const countRef = useRef(0);

    const increment = () => {
        countRef.current += 1;
        console.log("Sayaç:", countRef.current); // Konsola yazdırır, render olmaz
    };

    return (
        <div>
        <p>Sayaç: {countRef.current} (Render edilmez)</p>
        <button onClick={increment}>Artır</button>
        </div>
    );
    };

    export default CounterWithRef;
    Açıklama:
    useRef ile sayaç değeri saklanır ama değişim bileşeni yeniden render etmez.
    5. Değişken Kullanımı
    Özellik	useState	useRef
    Başlangıç Değeri	useState(initialValue)	useRef(initialValue)
    Değeri Güncelleme	setState(newValue)	ref.current = newValue
    Değere Erişim	state	ref.current
    6. DOM Manipülasyonu
    useState: Doğrudan DOM manipülasyonu yapmaz. Ancak bileşenin durumunu güncelleyerek dolaylı olarak DOM'u etkiler.
    useRef: Bir DOM elemanına doğrudan erişmek için kullanılır.
    Örnek: DOM Manipülasyonu ile useRef:
    jsx
    Kodu kopyala
    import React, { useRef } from "react";

    const InputFocus = () => {
    const inputRef = useRef(null);

    const handleFocus = () => {
        inputRef.current.focus(); // Input'u odaklar
    };

    return (
        <div>
        <input ref={inputRef} type="text" placeholder="Odaklanmak için tıkla" />
        <button onClick={handleFocus}>Odaklan</button>
        </div>
    );
    };

    export default InputFocus;
    7. Ortak Kullanım Senaryoları
    Kullanım Durumu	useState	useRef
    Form verilerini yönetme	✅	❌
    Sayaç veya durum takibi	✅	Yalnızca performans gerekliyse ✅
    Bir önceki değeri saklama	❌	✅
    DOM'a erişim	❌	✅
    Performans optimizasyonu	❌	✅
    8. Avantaj ve Dezavantajlar
    useState:
    Avantajlar:

    React'in reaktif yapısını kullanarak UI'yi otomatik günceller.
    Bileşen durumunu yönetmek için standart bir yol sağlar.
    Dezavantajlar:

    Her değişiklikte bileşeni yeniden render eder.
    Performans açısından maliyetli olabilir.
    useRef:
    Avantajlar:

    Performans dostudur, çünkü render gerektirmez.
    DOM elemanlarına doğrudan erişim sağlar.
    Dezavantajlar:

    React'in durum yönetiminden bağımsızdır, bu nedenle yanlış kullanıldığında karmaşık hatalara yol açabilir.
    Özet
    useState: UI güncellemeleri için durum takibini sağlar. Bileşen durumu değiştiğinde yeniden render olur.
    useRef: Performans dostu bir şekilde değer saklama ve DOM manipülasyonu yapma olanağı sağlar. Değişiklikler render edilmez.
    İkisinin birlikte kullanılması da mümkün ve farklı ihtiyaçlara uygun çözüm sunar.
    
..............................................................................
useMemo:
 
        React'te useMemo Nedir?
        useMemo, React'in bir hook'u olup, bir hesaplamayı yalnızca bağımlılıkları değiştiğinde yeniden yapmak için kullanılır. Performans optimizasyonu amacı taşır. Özellikle pahalı hesaplamaların ya da ağır işlem yüküne sahip fonksiyonların her render işleminde yeniden çalışmasını önlemek için kullanılır.

        Temel Kullanım
        useMemo, bir memoized (önbelleğe alınmış) değer döndürür. Eğer bağımlılık değerlerinde değişiklik olmazsa, hesaplama tekrar yapılmaz ve önceki değer kullanılır.

        Sözdizimi:
        javascript
        Kodu kopyala
        const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
        () => computeExpensiveValue(a, b): Hesaplama fonksiyonu.
        [a, b]: Bu bağımlılıklardan biri değiştiğinde, hesaplama yeniden yapılır.
        Örnek Kullanım
        1. Pahalı Hesaplama İçin:
        jsx
        Kodu kopyala
        import React, { useState, useMemo } from "react";

        const ExpensiveCalculation = () => {
        const [count, setCount] = useState(0);
        const [otherValue, setOtherValue] = useState(0);

        // Pahalı bir işlem
        const computeExpensiveValue = (num) => {
            console.log("Pahalı işlem çalıştı...");
            let total = 0;
            for (let i = 0; i < 1000000000; i++) {
            total += i;
            }
            return num + total;
        };

        const expensiveValue = useMemo(() => computeExpensiveValue(count), [count]);

        return (
            <div>
            <h1>Pahalı Hesaplama Sonucu: {expensiveValue}</h1>
            <button onClick={() => setCount(count + 1)}>Artır</button>
            <button onClick={() => setOtherValue(otherValue + 1)}>
                Diğer Değeri Artır
            </button>
            </div>
        );
        };

        export default ExpensiveCalculation;
        Açıklama:
        count değiştiğinde, pahalı hesaplama yeniden çalışır.
        otherValue değiştiğinde, pahalı hesaplama çalışmaz çünkü bağımlılıkları değişmemiştir.
        Ne Zaman Kullanılır?
        Pahalı Hesaplamalar:

        Birden çok kez render edilmesine rağmen hesaplama sonucu değişmeyen durumlar.
        Liste Filtreleme veya Sıralama:

        Büyük bir listeyi filtreleme veya sıralama işlemi yapılacaksa.
        Kompleks Matematiksel İşlemler:

        CPU'ya yük bindiren işlemleri optimize etmek için.
        Liste Filtreleme Örneği:
        jsx
        Kodu kopyala
        import React, { useState, useMemo } from "react";

        const FilteredList = ({ items }) => {
        const [search, setSearch] = useState("");

        const filteredItems = useMemo(() => {
            console.log("Listeyi filtreliyor...");
            return items.filter((item) =>
            item.toLowerCase().includes(search.toLowerCase())
            );
        }, [search, items]);

        return (
            <div>
            <input
                type="text"
                placeholder="Ara..."
                value={search}
                onChange={(e) => setSearch(e.target.value)}
            />
            <ul>
                {filteredItems.map((item, index) => (
                <li key={index}>{item}</li>
                ))}
            </ul>
            </div>
        );
        };

        export default FilteredList;
        Açıklama:
        search veya items değiştiğinde filtreleme işlemi çalışır.
        Değişiklik yoksa, daha önceki filtreleme sonucu kullanılır.
        Avantajları
        Performans İyileştirme:

        Pahalı işlemlerin gereksiz yere çalışmasını önler.
        Render Optimizasyonu:

        Büyük listelerde veya CPU'ya yük bindiren işlemlerde daha verimli render sağlar.
        Kaynak Yönetimi:

        Bellek ve işlemci kullanımını azaltır.
        Dikkat Edilmesi Gerekenler
        Fazla Kullanım:

        useMemo, yalnızca pahalı işlemler için kullanılmalı. Gereksiz kullanım, kodun karmaşıklığını artırabilir.
        Hafif İşlemlerde Kullanılmamalı:

        Basit matematiksel işlemler veya hızlı işlemler için kullanılması performansı artırmaz.
        Bağımlılıklar:

        Yanlış bağımlılık listesi, beklenmedik sonuçlara yol açabilir.
        useMemo ve useCallback Farkı
        useMemo:

        Bir değeri önbelleğe alır (örneğin, hesaplama sonucu).
        Örneğin: Filtrelenmiş liste.
        useCallback:

        Bir fonksiyonu önbelleğe alır.
        Örneğin: Bir butonun onClick olayına bağlı bir fonksiyon.
        jsx
        Kodu kopyala
        import React, { useMemo, useCallback } from "react";

        // useMemo ile hesaplama sonucu saklanır
        const memoizedValue = useMemo(() => computeValue(a, b), [a, b]);

        // useCallback ile fonksiyon saklanır
        const memoizedFunction = useCallback(() => doSomething(a), [a]);
        Özet
        useMemo, pahalı işlemleri optimize etmek ve yalnızca bağımlılıkları değiştiğinde yeniden hesaplamak için kullanılır.
        Performans odaklı uygulamalarda gereksiz hesaplamaları önler.
        Doğru kullanıldığında kaynak tasarrufu sağlar ve uygulamayı hızlandırır.

..............................................................................
useCallback ve react.memoized

        useCallback Nedir?
        useCallback Hook'u, bir fonksiyonun gereksiz yere yeniden oluşturulmasını önlemek için kullanılır. Özellikle bileşenlerin yeniden render edilmesi sırasında performansı artırmak için kullanılır.

        Kullanım Durumu:
        Eğer bir bileşen yeniden render edildiğinde aynı fonksiyon her defasında yeniden oluşturuluyorsa, bu performans kaybına yol açabilir. useCallback, bir fonksiyonun bağımlılıkları değişmediği sürece referansını aynı tutarak bu sorunu çözer.

        Sözdizimi:
        javascript
        Kodu kopyala
        const memoizedCallback = useCallback(() => {
        // İşlemler
        }, [dependency1, dependency2]);
        Örnek:
        javascript
        Kodu kopyala
        import React, { useState, useCallback } from "react";

        const Counter = () => {
        const [count, setCount] = useState(0);

        const increment = useCallback(() => {
            setCount((prevCount) => prevCount + 1);
        }, []);

        return (
            <div>
            <h1>Count: {count}</h1>
            <button onClick={increment}>Increase</button>
            </div>
        );
        };
        Avantaj:
        useCallback, fonksiyonun referansını yeniden oluşturmayı önler.
        Özellikle React.memo ile kullanılan alt bileşenlerde performansı artırır.
        React.memo Nedir?
        React.memo, bir bileşeni yalnızca props'larında veya bağımlılıklarında bir değişiklik olduğunda yeniden render eder. Bu, gereksiz render işlemlerini önleyerek performansı artırır.

        Kullanım Durumu:
        Bir bileşen, kendisine verilen props'lar değişmediği sürece yeniden render edilmemesi gereken durumlarda kullanılır.

        Sözdizimi:
        javascript
        Kodu kopyala
        const MemoizedComponent = React.memo(MyComponent);
        Örnek:
        javascript
        Kodu kopyala
        import React from "react";

        const Child = React.memo(({ value }) => {
        console.log("Child component rendered");
        return <div>{value}</div>;
        });

        const Parent = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <Child value="Hello, World!" />
            <button onClick={() => setCount(count + 1)}>Increase Count</button>
            </div>
        );
        };
        Çıktı:
        Child bileşeni, value prop'u değişmediği sürece yeniden render edilmez.
        useCallback ve React.memo'nun Farkları:
        Kapsam:

        useCallback, bir fonksiyonun referansını aynı tutmak için kullanılır.
        React.memo, bir bileşenin props'ları değişmediği sürece yeniden render edilmesini önler.
        Kullanım Amaçları:

        useCallback, özellikle fonksiyonların bağımlılıklarına göre yeniden oluşturulmasını engeller.
        React.memo, bir bileşenin gereksiz yere yeniden render edilmesini engeller.
        Birlikte Kullanım:

        useCallback, alt bileşenlere geçirilen fonksiyonların referansını sabitlemek için kullanılabilir ve React.memo ile birlikte çalışır.
        Birlikte Örnek:
        javascript
        Kodu kopyala
        const Child = React.memo(({ increment }) => {
        console.log("Child rendered");
        return <button onClick={increment}>Increment</button>;
        });

        const Parent = () => {
        const [count, setCount] = useState(0);

        const increment = useCallback(() => {
            setCount((prev) => prev + 1);
        }, []);

        return (
            <div>
            <h1>Count: {count}</h1>
            <Child increment={increment} />
            </div>
        );
        };
        useCallback, increment fonksiyonunun referansını sabitler.
        React.memo, Child bileşeninin props'u değişmediği için yeniden render edilmesini önler.

..............................................................................
Axios Nedir?
            Axios, Promise tabanlı bir HTTP istemcisidir ve JavaScript ile web uygulamalarında API'lere istek göndermek için kullanılır. Hem tarayıcı ortamında hem de Node.js ortamında çalışır. RESTful API'ler ile iletişim kurmak için yaygın olarak kullanılan bir araçtır.

            Axios'un Temel Özellikleri
            HTTP İsteklerini Yönetir:

            GET, POST, PUT, DELETE gibi HTTP metodlarıyla veri alışverişi sağlar.
            Promise ve Async/Await Destekler:

            Axios, modern JavaScript'in Promise ve async/await yapısını tam destekler.
            Otomatik JSON Dönüştürme:

            Yanıtlardaki JSON verilerini otomatik olarak JavaScript nesnesine çevirir.
            İstek ve Yanıt İçin Interceptor'lar:

            İstek gönderilmeden veya yanıt alınmadan önce özelleştirme yapılabilir.
            HTTP Başlıklarını Özelleştirme:

            API çağrıları için özel başlıklar tanımlanabilir.
            Zaman Aşımı Ayarı:

            Uzun süren istekleri belirli bir süreden sonra iptal edebilir.
            İstekleri İptal Etme:

            Gereksiz veya tekrarlanan istekler iptal edilebilir.
            Dosya Yükleme/Dinamik Veri Gönderimi:

            Form verilerini ve dosyaları kolayca sunucuya gönderebilir.
            Axios Kurulumu
            Axios'u projenize eklemek için şu adımları takip edebilirsiniz:

            Node.js veya React Projelerinde:
            bash
            Kodu kopyala
            npm install axios
            # veya
            yarn add axios
            CDN ile Kullanım:
            Tarayıcı tabanlı projelerde CDN ile eklenebilir:

            html
            Kodu kopyala
            <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
            Axios Kullanımı
            GET İsteği:
            javascript
            Kodu kopyala
            import axios from "axios";

            axios
            .get("https://jsonplaceholder.typicode.com/posts")
            .then((response) => {
                console.log(response.data); // API'den dönen veriler
            })
            .catch((error) => {
                console.error("Hata oluştu:", error);
            });
            POST İsteği:
            javascript
            Kodu kopyala
            axios
            .post("https://jsonplaceholder.typicode.com/posts", {
                title: "Yeni Gönderi",
                body: "Bu bir deneme gönderisidir.",
                userId: 1,
            })
            .then((response) => {
                console.log("Başarıyla eklendi:", response.data);
            })
            .catch((error) => {
                console.error("Hata oluştu:", error);
            });
            Async/Await ile Kullanım:
            javascript
            Kodu kopyala
            const fetchData = async () => {
            try {
                const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
                console.log(response.data);
            } catch (error) {
                console.error("Hata oluştu:", error);
            }
            };

            fetchData();
            Axios'un Avantajları
            Kullanıcı Dostu API:

            Axios, Fetch API'ye kıyasla daha okunabilir ve kısa bir söz dizimine sahiptir.
            Tarayıcı ve Node.js Desteği:

            Hem istemci tarafında hem de sunucu tarafında kullanılabilir.
            Daha İyi Hata Yönetimi:

            HTTP hatalarını daha kolay bir şekilde yakalamaya olanak sağlar (response, request, ve message düzeyinde).
            Interceptors:

            Özellikle yetkilendirme veya hata yönetimi için istek öncesi ve sonrası işlemleri kolaylaştırır.
            İsteklerin İptali:

            Gereksiz veya uzun süren istekleri iptal etmek mümkündür.
            Axios ve Fetch Arasındaki Farklar
            Özellik	Axios	Fetch
            Söz Dizimi	Daha sade ve kolay	Daha karmaşık
            JSON Dönüştürme	Otomatik olarak yapar	Manuel yapılmalı
            Tarayıcı Desteği	Daha eski tarayıcıları da destekler	Fetch yalnızca modern tarayıcılar için çalışır
            Interceptor Desteği	Var	Yok
            Kapsamlı Örnek
            Bir axios örneği için Interceptor ile bir Authorization başlığı ekleyebiliriz:

            javascript
            Kodu kopyala
            import axios from "axios";

            const axiosInstance = axios.create({
            baseURL: "https://api.example.com",
            timeout: 5000,
            });

            // Authorization başlığı eklemek için Interceptor
            axiosInstance.interceptors.request.use((config) => {
            const token = "Bearer example-token";
            config.headers.Authorization = token;
            return config;
            });

            // API'ye GET isteği
            axiosInstance
            .get("/data")
            .then((response) => console.log(response.data))
            .catch((error) => console.error("Hata:", error));
            Axios, modern web uygulamalarında API ile iletişim kurmanın etkili bir yoludur.

..............................................................................
Redux: 

            Redux Nedir?
            Redux, JavaScript uygulamaları için bir durum yönetim kütüphanesidir. Özellikle React gibi UI kütüphaneleri ile birlikte kullanılır ve uygulamanın durumunu (state) merkezi bir şekilde yönetmeye olanak tanır. Redux, predictable state container (öngörülebilir durum konteyneri) olarak tanımlanır ve tek bir kaynak üzerinden tüm uygulama durumunu yönetir.

            Redux'un Temel Prensipleri
            Redux üç temel prensip üzerine inşa edilmiştir:

            Tekil ve Merkezi Store:

            Uygulamanın tüm durumu (state) bir nesne olarak saklanır ve bu nesne store adı verilen merkezi bir depoda tutulur. Bu, uygulamanın durumunu kolayca takip etmeyi ve yönetmeyi sağlar.
            Salt Okunabilir Durum (State):

            Redux'ta durum değiştirilemez. Durumun değişmesi için bir action (eylem) tanımlanır ve bu action bir fonksiyon olan reducer aracılığıyla durumu günceller. Böylece durum değişiklikleri daha öngörülebilir hale gelir.
            Değişiklikler Saf Fonksiyonlarla Yönetilir (Reducers):

            Redux'ta durum değişiklikleri saf fonksiyonlar olan reducer'lar aracılığıyla yapılır. Reducer'lar mevcut durumu ve gelen action'ı alarak yeni bir durum döndürür.
            Redux'un Temel Bileşenleri
            Store:

            Uygulamanın tüm durumunun saklandığı merkezi bir depodur. createStore fonksiyonu ile oluşturulur.
            State:

            Store içinde saklanan uygulamanın mevcut durumudur.
            Action:

            Durumda bir değişiklik yapılmasını talep eden bir nesnedir. Örneğin, bir kullanıcıyı eklemek için bir ADD_USER action tanımlanabilir.
            Action genellikle bir type (eylem türü) ve ek veri (payload) içerir:
            javascript
            Kodu kopyala
            {
            type: "ADD_USER",
            payload: { name: "Ali", age: 25 }
            }
            Reducer:

            Action'ları işleyen ve state üzerinde değişiklikler yapan saf bir fonksiyondur. Eski durumu (state) ve gelen action'ı alır, yeni bir durum döndürür:
            javascript
            Kodu kopyala
            const userReducer = (state = [], action) => {
            switch (action.type) {
                case "ADD_USER":
                return [...state, action.payload];
                default:
                return state;
            }
            };
            Dispatch:

            Bir action'ı tetiklemek için kullanılan yöntemdir. Örneğin:
            javascript
            Kodu kopyala
            store.dispatch({ type: "ADD_USER", payload: { name: "Ali", age: 25 } });
            Selector:

            Store'dan belirli bir veriyi seçmek ve almak için kullanılan fonksiyonlardır.
            Redux'un Çalışma Akışı
            Bir Action oluşturulur: Kullanıcı veya bir sistem olayı sonucu bir action tetiklenir.
            Action Reducer'a gider: Dispatch edilen action, reducer'a iletilir.
            Reducer yeni state döndürür: Reducer, mevcut durumu ve action'ı işleyerek yeni bir durum döndürür.
            Store güncellenir: Yeni durum store'da saklanır.
            UI güncellenir: Yeni duruma göre kullanıcı arayüzü güncellenir.
            Redux'un Avantajları
            Merkezi Durum Yönetimi:

            Tüm durum tek bir yerde yönetilir, böylece durumu izlemek ve debug yapmak kolaylaşır.
            Tahmin Edilebilirlik:

            Reducer'lar sayesinde durum değişiklikleri öngörülebilir hale gelir.
            Kolay Test Edilebilirlik:

            Reducer ve action gibi saf fonksiyonlar kolayca test edilebilir.
            Genişletilebilirlik:

            Redux, orta katman (middleware) desteği ile genişletilebilir. Örneğin, redux-thunk ile async işlemler yapılabilir.
            Redux'un Dezavantajları
            Kod Karmaşıklığı:

            Küçük uygulamalarda Redux kullanımı aşırı kod yazımına neden olabilir (boilerplate).
            Yavaş Öğrenme Eğrisi:

            Yeni başlayanlar için Redux'ın çalışma yapısını anlamak zaman alabilir.
            Performans Maliyetleri:

            Çok büyük state veya fazla action işleme gerektiren durumlarda performans sorunlarına neden olabilir.
            Redux Kullanımı
            Redux Kurulumu
            Redux kullanımı için aşağıdaki bağımlılıkları yükleyin:

            bash
            Kodu kopyala
            npm install redux react-redux
            Redux Örnek: Basit Sayaç
            Action:

            javascript
            Kodu kopyala
            const increment = () => ({ type: "INCREMENT" });
            const decrement = () => ({ type: "DECREMENT" });
            Reducer:

            javascript
            Kodu kopyala
            const counterReducer = (state = 0, action) => {
            switch (action.type) {
                case "INCREMENT":
                return state + 1;
                case "DECREMENT":
                return state - 1;
                default:
                return state;
            }
            };
            Store:

            javascript
            Kodu kopyala
            import { createStore } from "redux";
            const store = createStore(counterReducer);
            React Bağlantısı:

            javascript
            Kodu kopyala
            import React from "react";
            import { useSelector, useDispatch } from "react-redux";

            const Counter = () => {
            const count = useSelector((state) => state);
            const dispatch = useDispatch();

            return (
                <div>
                <h1>{count}</h1>
                <button onClick={() => dispatch({ type: "INCREMENT" })}>+</button>
                <button onClick={() => dispatch({ type: "DECREMENT" })}>-</button>
                </div>
            );
            };

            export default Counter;
            Redux, özellikle durum yönetimi karmaşık olan büyük uygulamalarda güçlü bir araçtır. Ancak, daha küçük projelerde veya basit durum yönetimi gereken durumlarda gereksiz bir yük olabilir. Bu nedenle, Redux kullanmadan önce ihtiyaçlarınıza uygun olup olmadığını değerlendirin.

..............................................................................

..............................................................................






