Install-Package System.Data.SQLite   console manager kısmına yazarak SQLite kullanabiliriz... masaüstü uygulamaları için harika entity framework'te kullanabiliriz orm olarak destekler...
        SQLite NuGet Paketini Yükleme:
        Projenize SQLite ile çalışmak için System.Data.SQLite NuGet paketini ekleyin. Visual Studio kullanıyorsanız, "NuGet Package Manager Console" penceresini açıp aşağıdaki komutu kullanarak paketi yükleyebilirsiniz:

        bash
        Copy code
        Install-Package System.Data.SQLite
******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Form1 ff = new Form1();
         ff.ShowDialog();


          Console.WriteLine("merhababaaaaaa");
c# dilinde showDialog ile form açılıyor ama ben açıldıktan sonra alltaki yazıyıda yazdırsın istiyorum yani programın okuması orada takılı kalıyor ne yapmam lazım
ChatGPT
ShowDialog metodu, ilgili form kapatılana kadar kontrolü ele geçirir. Bu nedenle, ShowDialog metodundan sonra gelen kodlar, form kapandığında çalışır. Eğer formun üzerindeki işlemler tamamlandıktan sonra bir şeyler yapmak istiyorsanız, Form1 sınıfınızda bir olay (event) tanımlayarak bu olayı uygun bir durumda tetikleyebilirsiniz. Örneğin, formunuz kapatıldığında bir olay tetikleyerek ardından gelen kodları çalıştırabilirsiniz.

c#'da from uygulaması showDialog ile açıldıktan sonra o panel açık olduğu sürece alt satıra geçmez programın okuma imleci orada takılı kalır taki kapanana kadar...


************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
C# dilini daha ileri seviyede öğrenmek için aşağıdaki konulara odaklanabilirsiniz. Bu konular, C# programlamadaki ileri seviye konseptlere ve geliştirme tekniklerine odaklanmaktadır:

Nesne Yönelimli Programlama (OOP):
    C#'da nesne yönelimli programlama temel bir konsepttir. Sınıflar, nesneler, miras, soyut sınıflar, arayüzler, çoklu kalıtım gibi OOP konularını öğrenmek önemlidir.

İleri Seviye Dil Özellikleri:
    C#'daki en yeni dil özelliklerini anlamak ve kullanmak için çalışın. Örneğin, C# 8 ve sonraki sürümlerdeki özellikler arasında nullable reference types, pattern matching, switch expressions gibi konular bulunmaktadır.

LINQ (Language Integrated Query):
    LINQ, veri sorgulama ve manipülasyonu için kullanılan güçlü bir dil entegre sorgu aracıdır. LINQ kullanarak veri tabanlarına, koleksiyonlara ve diğer veri kaynaklarına sorgular yazmayı öğrenmek önemlidir.
Asenkron ve Paralel Programlama:
    Modern uygulamalar genellikle asenkron ve paralel programlama tekniklerini kullanır. async ve await anahtar kelimelerini kullanarak asenkron programlamayı, paralel programlamayı da inceleyerek çoklu iş parçacığı (multithreading) konularını anlamak önemlidir.

Exception Handling (İstisna Yönetimi):
    Hata işleme konusunu daha iyi anlamak için try, catch, finally bloklarını kullanma becerisi geliştirmek önemlidir.
Veri Tabanı Programlaması:
    Entity Framework veya Dapper gibi C# ile entegre veri tabanı erişim araçlarını öğrenmek ve kullanmak.
    
ASP.NET MVC veya ASP.NET Core:
    Web uygulamaları geliştirmek için ASP.NET MVC veya ASP.NET Core framework'ünü öğrenmek. MVC tasarım deseni, routing, middleware kavramlarına hakim olmak önemlidir.

Unit Testing (Birim Testleri):
    NUnit, xUnit veya MSTest gibi birim testi çerçeveleri kullanarak uygulamalarınızı test etmeyi öğrenmek. Test yazma, test odaklı geliştirme ve test otomasyonu konularına hakim olmak önemlidir.
Dependency Injection ve IoC (Inversion of Control):
    Uygulama bağımlılıklarını yönetmek için Dependency Injection (Bağımlılık Enjeksiyonu) ve IoC konularını anlamak ve uygulamak.

Git ve Source Control Sistemleri:

Git gibi versiyon kontrol sistemlerini kullanarak kodunuzu yönetmeyi öğrenmek.
Bu konuları öğrenmek ve uygulamak, C# dilindeki yeteneklerinizi daha da geliştirmenize yardımcı olacaktır. Ayrıca, projeler üzerinde çalışmak ve gerçek dünya uygulamaları geliştirmek de öğrenme sürecinizi hızlandıracaktır.

......................................................................................................................................................................................................................................................................................................................................................................................................

C# programlama dilinde, bellek yönetimi iki temel alanı içerir: stack (yığın) ve heap (örtü). Bu iki alan, programın çalışma zamanında verileri depolamak için kullanılır, ancak farklı özelliklere sahiptir.

Stack (Yığın):
Stack, programın çalışma zamanında yönetilen bir bellek alanıdır. Bu alanda veriler, sıralı bir şekilde depolanır ve bu verilere hızlı erişim sağlanır. Stack'te veri depolamak için kullanılan bellek alanı, genellikle yönetilen (managed) veri tipleri ve değer tipleri içindir. İşte stack'te tutulan bazı veri tipleri:

Değer Tipleri:

int, char, float, double, bool gibi temel veri tipleri.
struct tarafından tanımlanan yapılar.
Yerel Değişkenler:

Metot içerisinde tanımlanan değişkenler.
Metot Çağrıları:

Metot çağrıları ve metot çağrılarına ait yerel değişkenler.
Stack'te depolanan veriler, programın akışı içinde meydana gelen işlemlerle birlikte otomatik olarak tahsis edilir ve serbest bırakılır. Stack, veri tipleri için hızlı erişim sağlar, ancak boyutları genellikle sınırlıdır ve yaşam süreleri kısa olduğu için otomatik olarak serbest bırakılır.

Heap (Örtü):
Heap, programın çalışma zamanında yönetilen bir diğer bellek alanıdır. Heap'te depolanan veriler, daha uzun ömürlüdür ve belirli bir yaşam süresine sahiptir. Genellikle heap, dinamik olarak tahsis edilen ve serbest bırakılan bellek alanıdır. Heap'te tutulan bazı veri tipleri şunlardır:

Referans Tipleri:

class tarafından tanımlanan nesneler.
string gibi dinamik bellek tahsisi gerektiren türler.
Dinamik Bellek Tahsisi:

new anahtar kelimesi ile oluşturulan nesneler.
Heap'te depolanan veriler, programcı tarafından elle serbest bırakılmalıdır (örneğin, Dispose veya Close gibi yöntemler kullanılarak), aksi takdirde bu bellek sızıntılarına neden olabilir.

İki bellek alanı arasındaki temel farklar şunlardır:

Hız ve Erişim Süresi: Stack, hızlı bir erişim sağlar çünkü bellek alanı sıralıdır. Heap ise daha fazla işlem gerektirir ve dolayısıyla daha yavaş erişim sağlar.

Ömür ve Kapsam: Stack'te depolanan veriler genellikle kısa ömürlüdür ve otomatik olarak serbest bırakılır. Heap'te depolanan veriler daha uzun ömürlüdür ve programcı tarafından serbest bırakılmalıdır.

......................................................................................................................................................................................................................................................................................................................................................................................................


// blank solution boş bir çözüm ekranı açar...
// existing project ile projelerin benzer kısımlarını çekebiliriz...
// bazen framework sürüm farklılığından dolayı projeler çalışmayabilir buna dikkat etmek lazım...
// Sürümlerde üst olan hepsini kapsar ama 4.7.2   4.8 ile yazılmış olanı desteklemeyebilir. ama 4.8 kendinden alt olanları destekler.  
// nuget ile biz istersek dependies ekleyebiliriz entity framework gibi...
// c#da her veri wrapper classtır yani her ver bir nesnedir. bu yüzden her verinin metotlarını kullanabiliriz. mesela int a = 8; deriz a.equals vs kullanabiliriz...  eğer bir metotta yollayıp değerinin değişmesini falan istersek o zaman ref ile yollarız...
// static metot static main içinde çalışabilir static olmayan değer static içinde çalışmaz... static-static veya non-static - non-static olmalı...
// mesela bir class'ın oluşması için önce onun superclass'ı oluşmalı oluşurken default constructor çalışır....
degistir(ref a)
public void degisttir(ref int b) gibi...

c#da ilkel yapılar yoktur. her şey nesnedir... wrapper classtır aslında veriler.
            Console.WriteLine(int.MinValue);   // mesela direkt olarak int class'ının içindeki static MinValue değerini çağırabiliriz...  static olan değerleri ve metotları direkt olarak class ile kullanabiliriz...
            Console.WriteLine(int.MaxValue);

Console.WriteLine(int.MinValue + " EMRE"+ byte.MinValue+" FORD"+byte.MaxValue);
     + demek String'de ekleme yap demektir. böylece tüm değerler string'e döner ve işlem yapabiliriz...



            double say11 = 12.2;
            Console.WriteLine(say11);
            float say12 = (float)12.33;  // her noktalı değer aslında double'dir bizim atama yaparken float'a tip dönüşümü yapmamız lazım uppercasting yapmamız gerekiyor...
            Console.WriteLine(say12);




c#tada diğer dillerde olduğu gibi tüm veriler tanımlanır bir metot eğer bir değer dönderiyorsa o zaman tipinde karşılanır int sayi1 = sayigetir(); gibi.

Tam Sayı Veri Tipleri:

int: 32 bitlik işaretli tam sayı.
long: 64 bitlik işaretli tam sayı.
short: 16 bitlik işaretli tam sayı.
byte: 8 bitlik işaretli tam sayı.
sbyte: 8 bitlik işaretli tam sayı.

Ondalıklı Sayı Veri Tipleri:

float: 32 bitlik ondalıklı sayı.
double: 64 bitlik ondalıklı sayı.
decimal: 128 bitlik ondalıklı sayı.

Karakter Veri Tipleri:

char: 16 bitlik Unicode karakter.

Boolean Veri Tipi:

bool: Mantıksal (true veya false) değeri temsil eder.

Metinsel Veri Tipleri:

string: Metin verilerini tutan veri tipi...  
        Console.WriteLine(String.Format("{0} {1}",str1,str2));   böylede kullanabiliriz...
        .Length ile uzunluk alabiliriz...
        string aa = bb.Clone(); ile ise biz bb'nin içeriğini aa'ya atayabiliriz. 
        string.IsNullOrWhiteSpace(str1)   true false çevirir... boş değilse false çevirir mail adresi için falan kullanılır.

Object Veri Tipi:

object: Tüm diğer türlerin temel türüdür. Her türden bir nesneyi temsil edebilir.
Diziler:

int[], string[], vb.: Belirli bir türdeki elemanları içeren diziler.
Nullable Veri Tipleri:

int?, bool?, vb.: Nullable türler, değerlerin null olabileceği anlamına gelir.
Enumerations (Enum):

enum: Belirli bir türdeki sabit değerlerin adlarını içeren bir türdür.
Yapılar (Structures):

struct: Değer türleri olan, ancak sınıflar gibi davranabilen türler.
Sınıflar (Classes):

class: Referans türleri olan ve nesne tabanlı programlamanın temelini oluşturan türler.
Interface ve Arayüzler:

interface: Bir sınıfın uygulamasını zorlayan bir sözleşme sağlayan tür.

// oop demek encapsulation,polymorphism and inheritance demektir aslında...
// interfaceler aslında birer sözleşmelerdir böylece içerisindeki metotları override etmek zorunlu olur implement eden class tarafından...

################################################################################################################################################################################################################################################


            Console.WriteLine(Byte.MaxValue); // 255    256 vermeye çalışırsan Byte değere o zaman hata verir...
            Console.WriteLine(Byte.MinValue); // 0
            Console.WriteLine(long.MinValue); // -9223372036854775808
            Console.WriteLine(long.MaxValue); //   9223372036854775807
            Console.WriteLine(int.MaxValue); // 2147483647    32 bit 4 byte 2^^32 değer alır.
            Console.WriteLine(int.MinValue); // - 2147483648
            Console.WriteLine(long.MaxValue / int.MaxValue); // 4294967298
            Console.WriteLine(double.MinValue); //-1,79769313486232E+308
            Console.WriteLine(double.MaxValue); // 1,79769313486232E+308
            Console.WriteLine(ulong.MaxValue); // 18446744073709551615
            Console.WriteLine(ulong.MinValue); // 0
            Console.WriteLine(sbyte.MaxValue); // 127
            Console.WriteLine(sbyte.MinValue); // - 128
            Console.WriteLine(short.MaxValue); // 32767
            Console.WriteLine(short.MinValue); //-32768
            Console.WriteLine(ushort.MaxValue); //65535
            Console.WriteLine(ushort.MinValue); //0
            Console.WriteLine(uint.MaxValue); // 4294967295
            Console.WriteLine(uint.MinValue); // 0
            Console.WriteLine(decimal.MaxValue); // 79228162514264337593543950335     // 12 byte'dır noktadan sonra 28-29 basamak duyarı vardır...  doublede 15 16 basamak iken decimalde 28 29 böylece hassaslık çok artar...
            Console.WriteLine(decimal.MinValue); // -79228162514264337593543950335  
            Console.WriteLine(char.MinValue); // nulldan başlar
            Console.WriteLine(char.MaxValue); // ?'e kadar gider çok fazla karakterleri tutabilir. tüm dillerin alfabelerindeki harfleri tutabilir. 2 bytedir 16 bit...

bool true veya false alır mantıksal veridir... a == b demek (a == b)   bize true veya false döndürecek demektir    return a == b diyebiliriz a == b 'de true veya false dönecek zaten...

internal bir erişim belirleyicisidir ve C# dilinde bir sınıfın veya bir üyenin, yalnızca bulunduğu proje içinde erişilebilir olmasını sağlar. internal olarak işaretlenen bir sınıf veya üye, aynı derleme içindeki diğer sınıflar tarafından erişilebilir, ancak başka bir derleme tarafından erişilemez.

    "Aynı derleme" ifadesi, bir C# projesinde bir araya getirilen tüm kodun toplandığı ve derlendiği yapıyı ifade eder. Bir C# projesi, bir veya birden fazla sınıf ve dosyanın bir araya getirildiği bir "derleme" üretir. Bu derleme genellikle bir .dll (dinamik bağlantı kitaplığı) veya .exe (yürütülebilir dosya) uzantısına sahiptir.

    Bir C# projesindeki tüm sınıflar, yapılar, enum'lar, metotlar ve diğer üyeler, projenin derlenmiş çıktısı içinde bir araya getirilir. Bu çıktıya "derleme" denir. Eğer tüm bu kodlar aynı proje içinde yer alıyorsa, bu kodlar aynı derleme içindedir.

    Eğer bir sınıf veya üye internal olarak işaretlenmişse, bu, bu sınıfın veya üyenin sadece aynı derleme içindeki diğer kodlar tarafından erişilebileceği anlamına gelir. Yani, internal olarak işaretlenen bir sınıf veya üyenin erişilebilir olması için, bu sınıf veya üyenin bulunduğu proje içinde olması gerekmektedir.

    Aynı derleme içinde olmak, bir C# projesinin sınıflarının, üyelerinin ve diğer yapılarının bir araya getirildiği ve derlendiği fiziksel sınırları ifade eder. Eğer farklı projeler arasında kod paylaşımı yapmak istiyorsanız, bu durumu public veya başka bir erişim belirleyici ile yönetmeniz gerekir.


// her kesirli sayı doubledir float vs yapmak istersek o zaman tip dönüşümü yapmak lazım (float) 5.6   veya 5.6f  olarak
double sayi1 = 5/4;  1.0 olur   5 int 4 int spnuç int 1 olur double olunca 1.0 olur....    (double) 5 / 4 olsa 5.0 / 4 olur  o zaman 1.25 çıkar direkt olarak...

bölümde falan kesirli sayılarda kayıplar olabilir bunun için decimal kullanılır... hassas hesaplar için decimal kullanırız. bunu e ticaret sitelerinde vs kullanabiliriz...
     tip dönüşümlerinde kayıplar vs olabilir kesirlerden kaynaklı kayıplar olabilir bunun için decimal kullanırız hassas hesaplarda...

karakterler '' içeriisnde stringler ise "" içerisinde belirtilmelidir. pythona böyle bir fark yoktur mesela...
'' içerisinde tek bir karakter belirtilebilir.
"" olursa karakter dizisi içerebilir.

\ demek benden sonra gelecek olan bilgisayarın program komutu değil demektir.
          ana \n alt satır \t ise bir tab boşluk demektir.

c# büyük harf küçük harf ayrımı yapar int sayi1,Sayi1; yapabiliriz... yani farklı olacaktir ikiside...

*******CASTİNG büyük alandaki veri küçük alana geçemez geçecek olursa kayıplar olur ancak casting ile kayıplarla beraber yapmak mümkün. küçük veriyi büyük veri tipine sorunsuz dönüştürebiliriz. 
  mesela floatı doubleye sorunsuz atabiliriz.  ama doubleyi dönüşüm yapmadan atamayız atarsakta kayıplar olur veri kaybı olur.
  long inti sorunsuz alır veri kaybı olmadan ama tam tersi zor.
  intin long'a atanması implicit(istemsiz) dönüşümdür bir hata vermez.     
  longun int olması ise explicit döünüşümdür dönüşümü belirtmek lazım downcasting yapmak gerekir. 
  longu int yapmak için derleyiciyi ikna etmemiz lazım....
  c#da java gibi önce derlenir sonra yorumlanır.
  explicit yaparsak manuel yapmalıyız  double sayi1 = 18.8;    int sayi2 = (int)sayi1; gibi...


            Console.WriteLine(Convert.ToString(3.43));
            Console.WriteLine(Convert.ToInt64(3.43));
            int sayi12 = Convert.ToInt32("12");
            long sayi13 = Convert.ToInt64("1221");

Convert.ToTip   ile biz içerisine attığımız değeri istenen değere çeviririz. ve bu yapı isteneni return eder... int'e atama yapacaksak Convert.ToInt32(); kullanmamız lazım 
Convert.ToInt32() bu bize değer return edecek ve kullanacağız.



################################################################################################################################################################################################################################################

dizilerde veri tipleri aynı olur;
Array bir sınıftır

            int[] array = { 1, 2, 3, 4, 5, }; // burada direkt atama yapabiliriz... 
            int[] array2 = new int[10]; // burada ise 10 tane int değer alacak yer ayırırız ve otomatik olarak hepsi sıfır olur sayılarda ilk atama otomatik sıfırdır string ve class'larda ise nulldır.

Arraylerde referancelerla çalışır yani 
        public static void degistir(int[] a)
        {

            a[0] = 11;


        }   // buraya bir array gelirse ilk değeri 11 olacak kalıcı şekilde...  bunun nedeni arrayler aslında referancedir.

int[][] ab = new int[10][];  // burada 10 tane int dizisi olacak diyoruz... ikinci [] atamaya gerek yok ama atarsak sabit olarak onlarda o sayı kadar değer taşıyan int arrayler olacak... 
yani ab 10 tane int array taşıyan bir array'dir.  ab.length dersek 10 alırız...
int[][] ab = new int[10][6]; dersek eğer 10 tane 6 tane int değer taşıyan aarray vardır 6,6,6,6,6,6,6,6,6,6,6 olacak şekilde...

            int[][] ab = new int[10][];
            for (int i = 0; i < ab.Length; i++)
            {
                ab[i] = new int[9];
            }
            // bu şekilde ise 10 kere çalışır for ve her arraye bellekte yer ayırır her arrya 9 tane değer alabilir hale gelir.  bu yapı ile kapasiteleri farklı arraylerden oluşan matrisler kurabiliriz.

ab[1][1] = 100; diyerek direkt atama yapabiliriz...

mesela 10 kapasiteli bir array var 11.ciye atama yapmak istersek hata alırız.

string[] ise string değer taşıyan bir arraydir bu bir referancedir.

array[index]  ile istenen elemana ulaşırız. indexin arrayin boyutuna göre olması gerekir bu önemlidir.  yoksa hata verebilir.

int[,] demekte 2 boyutlu bir dizidir.
int[,,] ise 3 boyutlu demektir...

..........................................................................................

            int[][] aa = new int[10][];
            for (int i = 0; i < aa.Length; i++) {
                aa[i] = new int[9];
            }

            for (int i = 0;i < aa.Length; i++) { 
            for (int j = 0; j < aa[i].Length; j++)
                {
                    Console.Write(aa[i][j]);  // aa[i,j] de olabilir fark etmez... 

                }
                Console.WriteLine();

            }

int[,] aa = new int[2,3] yapabiliriz  3,3 eleman taşıyan bir matris olur böylece.
veya aa = {{1,1,1},{1,1,1}} yapabiliriz.

..................................................................................................

% kalan bulma... a += b ;  a'ya b eklenir -= çıkarır *= çarpar.    ++ tek arrttırma -- tek çıkarma     solda veya sağda olması önemli solda olursa önce değeri değişir sonra işleme dahil olur sağda olursa önce işleme dahil olur sonra değeri değişir.

(float) a / b    ile (float) a / (float) b arasında fark olabilir dikkat etmek lazım...

        C# dilinde, operatörler matematiksel işlemlerden mantıksal kontrol işlemlerine kadar birçok farklı kategoride bulunmaktadır. Ayrıca, operatörlerin öncelik sıralaması da önemlidir, çünkü bu sıralama ifadeyi değerlendirirken kullanılır.

        İşte C# dilinde kullanılan bazı temel operatörler ve öncelik sıralaması:

        Matematik Operatörleri:

        + (toplama)
        - (çıkarma)
        * (çarpma)
        / (bölme)
        % (mod alma)
        Artırma ve Azaltma Operatörleri:

        ++ (artırma)
        -- (azaltma)
        Atama Operatörleri:

        = (atama)
        +=, -=, *=, /=, %= (toplama, çıkarma, çarpma, bölme, mod ile atama)
        Mantıksal Operatörler:
        a /= 10; demek a'yı 10 böl çıkan değeri a'ya ata demek %= içinde aynısı geçerli diğerleri içinde geçerliler...


        && (ve - AND)
        || (veya - OR)
        ! (değil - NOT)
        () parantezlerin içinin önceliği var... buna dikkat etmek lazım.
        (a > b) && (b  < c)  önce sağ sol parantez sonuç return eder sonra && çalışır...
        Karşılaştırma Operatörleri:  True veta False ile çalışırlar.

        == (eşit)
        != (eşit değil)
        < (küçük)
        > (büyük)
        <= (küçük veya eşit)
        >= (büyük veya eşit)
        Bitwise Operatörler:

        & (ve)
        | (veya)
        ^ (XOR - özel veya)
        ~ (bütünleyen)
        << (sol kaydırma)
        >> (sağ kaydırma)
        Koşullu Operatör:

        ? : (koşullu ifade)   (koşul <= mesela) ? True halde return edilecek: False halde return edilecek;


            int a = 0, b = 1;
            string sonuc = (a == b) ? "esit" : "degil"; // True ise soldakini atar False ise sağdakini atar...
            Console.WriteLine(sonuc); // degil...

        Tip Dönüşüm Operatörleri:

        (tip) (dönüşüm operatörü)
        as (as operatörü)
        is (is operatörü)
        Operatörlerin öncelik sıralaması, bir ifadenin hangi operatörün önce değerlendirileceğini belirler. Öncelik sıralaması, matematiksel operatörlerin öncelikli olması, ardından karşılaştırma, mantıksal ve diğer operatörleri içerir. Ancak, ifadeyi açıklığa kavuşturmak için parantezler kullanılabilir. Örneğin, parantez içindeki ifadeler her zaman önceliklidir.


bir if else if else bloğunda sadece bir tanesi çalışır...  sırası ile okur ilk sağlanan koşula girer hiçbirisi çalışmazsa else çalışır. else olmasada olur...
int a = -10;
if(a > 0){

+

}else if(a == 0){

0

}else{

-

}


################################################################################################################################################################################################################################################

    internal class Program
    {
        static void Main(string[] args)
        {
            int sayi1 = 0;
            atamayap(ref sayi1);
            Console.WriteLine(sayi1);





        }

        public static void atamayap(ref int a)
        {

            a = Convert.ToInt32(Console.ReadLine());
        
        }


    } // sayıya atama yapan bir program...


static ile class'a bağlarız bir değeri veya metotu... static metot içerisinde static olmayan metot nesnesiz şekilde çalışamaz...
void geriye değer döndermez. bir metot kullanacaksak return yapacaksa ne türden yapacak belirlememiz lazım.

static int kucukharfsayisi(string s){

int aa = 0;

foreach(var i in s){    // foreach ile karakter karakter string üzerinde dönebiliriz...

if(char.IsLower(i)) aa++; 

}
return aa;
}



......................................................................................................................................................................................

        static void Main(string[] args)
        {

            yazdir(a: "TT",c:"YY",b:"GHGH");   // bu şekilde bir metota gönderilecek değerlerin hangisi tarafından karşılanmasını istediğimizi belirtebiliriz...

        }




        public static void yazdir(string a , string b, string c)
        {

            Console.WriteLine(a + " " + b + " " + c);

        }

        public static void yazdir(string a , string b)  // burada ise aynı tipte aynı isimde farklı parametreli metotlar ile metot overloading yapaarız ve program verilen değişkenlere göre kendisini en az yoran ve en uygun olanı çağırır...
        {

            Console.WriteLine(a + " " + b);

        }

......................................................................................................................................................................................

C# programlama dilinde metotlar, kodunuzu modülerleştirmenin ve tekrar kullanılabilirliği artırmanın önemli bir yolu olarak karşımıza çıkar. Metotlar, belirli bir görevi yerine getiren ve genellikle bir isimle çağrılabilen kod bloklarıdır. Bu yazıda, C# dilinde metotların nasıl tanımlandığı, kullanıldığı ve özelleştirildiği konularına detaylı bir şekilde odaklanacağız.

Metot Tanımı:
C# programlama dilinde bir metot, aşağıdaki gibi bir yapıda tanımlanır:

erişim_belirleyici dönüş_türü MetotAdı(parametre_listesi)
{
    // Metotun içeriği
}
Erişim Belirleyici (Access Modifier): Metodun ne kadar görünür olduğunu belirler. Örneğin, public, private, protected, internal gibi.

Dönüş Türü (Return Type): Metodun geri döndüğü değerin türünü belirtir. Eğer metot bir değer döndürmüyorsa void kullanılır.

Metot Adı: Metodu çağırırken kullanılacak ismi belirtir.

Parametre Listesi: Metotun içinde kullanılacak değerleri almak için kullanılır. Parametreler opsiyonel olabilir.

Örnek Bir Metot Tanımı:

public int Topla(int sayi1, int sayi2)
{
    int toplam = sayi1 + sayi2;
    return toplam;
}
Bu metot, iki tane int tipinde parametre alır (sayi1 ve sayi2), bu sayıları toplar ve sonucu int türünde geri döner.

Metot Kullanımı:
Bir metodu kullanmak için, öncelikle sınıfın bir örneğini oluşturmalı veya metot static olarak tanımlanmışsa sınıf adı üzerinden çağrılmalıdır.


// Metot çağrısı
int sonuc = Topla(5, 7);
Console.WriteLine("Toplam: " + sonuc);
Parametre Türleri ve Seçenekler:
Metotlara parametreler ile veri iletimi yapılır. Parametreler, değer türleri (int, float, char, vb.) veya referans türleri (class, array, interface, vb.) olabilir. Ayrıca, parametreler opsiyonel olabilir, varsayılan değerler atanabilir.


public void Yazdir(string metin, int tekrarSayisi = 1)
{
    for (int i = 0; i < tekrarSayisi; i++)
    {
        Console.WriteLine(metin);
    }
}
Bu metot, bir metni belirli bir sayıda ekrana yazdırmak için kullanılır. tekrarSayisi parametresi varsayılan olarak 1'e ayarlanmıştır, ancak metot çağrısı sırasında farklı bir değer atanabilir.

Overloading (Aşırı Yükleme):
Bir sınıf içinde aynı isme sahip fakat farklı parametre listelerine sahip birden fazla metot tanımlamak mümkündür. Bu duruma "overloading" denir.


public int Topla(int sayi1, int sayi2)
{
    return sayi1 + sayi2;
}

public double Topla(double sayi1, double sayi2)
{
    return sayi1 + sayi2;
}
Bu örnekte, Topla isimli iki farklı metot tanımlanmıştır. İlk metot int türünde, ikinci metot ise double türünde çalışır.




ref ve out Parametreleri:
ref ve out parametreleri, metotların değerleri dışarıdan değiştirmesine izin verir.


public void Arttir(ref int sayi)
{
    sayi++;
}

public void Bol(ref int bolen, int bolunen, out int bolum)
{
    bolum = bolen / bolunen;
}



params Parametresi:
params anahtar kelimesi, değişken sayıda parametre alabilen bir metot tanımlamak için kullanılır.


public int Topla(params int[] sayilar)
{
    int toplam = 0;
    foreach (int sayi in sayilar)
    {
        toplam += sayi;
    }
    return toplam;
}



static Metotlar:
Bir metot static olarak tanımlandığında, sınıf adı üzerinden çağrılabilir ve sınıfın bir örneği oluşturulmasına gerek yoktur.


public class Matematik
{
    public static int KareAl(int sayi)
    {
        return sayi * sayi;
    }
}

// Kullanım
int sonuc = Matematik.KareAl(4);
Bu örnekte, KareAl metodu static olarak tanımlanmış ve Matematik sınıfı üzerinden çağrılmıştır.

Lambda İfadeleri ile Kısa Metotlar:
C# 3.0 ve sonrasında lambda ifadeleri kullanarak kısa metotlar tanımlamak mümkündür.


Func<int, int, int> topla = (x, y) => x + y;
Console.WriteLine(topla(3, 4));
Bu örnekte, topla adında bir lambda ifadesi kullanılarak kısa bir toplama metodu tanımlanmıştır.




################################################################################################################################################################################################################################################

        namespace appConsole
        {


            public class MyName
            {
                




            }


            internal class Program
            {
                static void Main(string[] args)
                {
                    int sayi1 = 0;
                    atamayap(ref sayi1);
                    Console.WriteLine(sayi1);





                }

                public static void atamayap(ref int a)
                {

                    a = Convert.ToInt32(Console.ReadLine());
                
                }


            }
        }




################################################################################################################################################################################################################################################
    ref Anahtar Kelimesi:
    ref anahtar kelimesi, bir metoda argüman olarak geçirilen bir değişkenin, metot içinde değiştirilebileceğini belirtir. Bu, metot içinde değişen değerin, çağrıldığı yerdeki orijinal değişkeni etkileyebileceği anlamına gelir.

    
    public void Arttir(ref int sayi)
    {
        sayi++;
    }

    // Kullanım
    int sayi = 5;
    Arttir(ref sayi);
    Console.WriteLine(sayi); // 6
    Bu örnekte, Arttir metodu bir ref parametre alır ve bu parametre üzerinde yapılan değişiklikler, orijinal değişkeni etkiler.

    out Anahtar Kelimesi:
    out anahtar kelimesi, bir metot tarafından bir değer döndürülmesini sağlar. Ancak, out ile belirtilen bir parametre, metot çağrısı yapmadan önce başlatılmasına rağmen, metot içinde değer atanması gerekmez. out parametreleri, metottan birden fazla değeri döndürmek amacıyla da kullanılabilir.

  
    public void Bol(int bolen, int bolunen, out int bolum)
    {
        bolum = bolen / bolunen;
    }

    // Kullanım
    int bolum;
    Bol(8, 2, out bolum);
    Console.WriteLine(bolum); // 4
    Bu örnekte, Bol metodu out parametre kullanarak bir değeri döndürüyor. out parametreler, metottan değeri döndürmek için kullanıldıklarında, metotun içinde değer atanması zorunlu değildir.

    ref ve out Kullanımına İlişkin Noktalar:
    ref ve out parametreleri, metot çağrısı yapmadan önce başlatılmalıdır. out parametreleri özellikle metot içinde değer atanmasa bile başlatılmalıdır.

    ref ve out kullanımı, genellikle bir metotun birden fazla değeri değiştirmesi veya döndürmesi gerektiğinde tercih edilir.

    ref kullanımında, değer atanmış bir değişkenin referansı geçilir ve metot içinde değiştirilen değer, orijinal değişkeni etkiler.

    out kullanımında, metotun değeri döndürmesi gerektiğinde veya metotun içinde değer atanması gerektiğinde tercih edilir.

    Hem ref hem de out parametreleri, metotun başlığında belirtilen türde olmalıdır.

    Bu anahtar kelimeler, programlamada değerleri metotlar arasında aktarırken ve metotlardan değer alırken kullanılır ve C# dilinde esnek bir parametre geçirme ve döndürme mekanizması sağlar.
################################################################################################################################################################################################################################################

constructor yapıcı metotdur. çok önemlidir... constructor overloading yapabiliriz. istediğimiz parametreler ile çalışır hale getirebiliriz...

public olursa her yerden erişebilir... public'te erişim kısıtı yoktur.
protected ait olduğu sınıftan ve o sınıftan türetilen yerlerden erişilebilir.




            C# programlama dilinde, erişim belirleyicileri (access modifiers), bir sınıfın, üyenin (örneğin, bir alan, bir metot veya bir özellik) veya bir derlemenin başka kod bloklarından ne kadar görünür ve erişilebilir olduğunu belirten özel anahtar kelimelerdir. Erişim belirleyicileri, sınıfın, üyenin veya derlemenin erişilebilirliğini kontrol etmek için kullanılır ve bu sayede programın modülerliğini ve güvenliğini sağlar.
            C# dilinde beş temel erişim belirleyici bulunmaktadır:

            public:

            Herkes tarafından erişilebilir.
            Örneğin: public class Example { }


            private:

            Sadece tanımlandığı sınıf içerisinden erişilebilir.
            Örneğin: private int count;


            protected:

            Tanımlandığı sınıf ve bu sınıftan türetilmiş sınıflar tarafından erişilebilir. yani kalıtım almış sınıflar ve kendi sınıfı erişebilir bu metotlara ve değişkenlere... 
            Örneğin: protected void DoSomething() { }


            internal:

            Bulunduğu derleme içerisindeki herhangi bir sınıf tarafından erişilebilir.
            Örneğin: internal class InternalClass { }


            protected internal:
             
            Tanımlandığı sınıf, türetilmiş sınıflar ve bulunduğu derleme içerisindeki herhangi bir sınıf tarafından erişilebilir.
            Örneğin: protected internal string Name { get; set; }
               mesela bir class içinde protected bir değişken var kendi içeriisnde ve kalıtım alanların içerisinde çalışır bu protected metotlar ve değişkenler. başka bir class'ta nesne oluşturup'ta erişemeyiz. 
               private olursa eğer super kullanmadan erişemeyiz kalıtım devreye girerse. 

                                class class1
                                {

                                    protected string name = "emre";

                                }

                                class Program
                                {

                                    static void Main(string[] args)
                                    {

                                        Console.WriteLine();
                                        Console.WriteLine(aa.name); // hata verir. erişemeyiz...

                                    }

                                }


            Bu erişim belirleyicileri, sınıfların, üyelerin ve derlemelerin ne kadar görünür olduğunu kontrol etmek için kullanılır. Bu, bir kod tabanının iyi bir şekilde organize edilmesini, sınıfların ve üyelerin sadece gerekli yerlerden erişilebilir olmasını ve kodun güvenliğini sağlamak açısından önemlidir.

################################################################################################################################################################################################################################################

namespace appConsole
{
    class TTT
    {

        private int skor;
        public int Skor
        {
            
            get { return skor; } // get bloğu skor okunmak istediği zaman çalışır.
            set {  skor = value; } // set ise atama yapılmak istendiği zaman çalışır.

        }

    }
    class Program
    {

        static void Main(string[] args)
        {

            TTT aaa = new TTT();
            aaa.Skor = 1; // set çalışır. private değişkene atama yapar.
            Console.WriteLine(aaa.Skor); // get çalışır burada.  private skorun değerini döndürür...

        }


    }
}


.........................................................................................................................

    class Kisi
    {
        private int yas;
        private string dogumyeri;
        private string meslek;

        public int Yas { 

        get { return yas; }
            set { 
            

                if (value < 0)
                {

                    yas = 0;
                }
                else
                {
                    yas = value;
                }
            
            }
        
        }

        public string Dogumyeri
        {

             get { return dogumyeri; }
            set { dogumyeri = value;}

        }

        public string Meslek
        {

            get { return meslek; }
            set { meslek = value; }
        
        }



        public Kisi(int yas, string dogumyeri, string meslek)
        {
            this.yas = yas;
            this.dogumyeri = dogumyeri;
            this.meslek = meslek;
        }



    }


################################################################################################################################################################################################################################################

// properity olayı...


namespace appConsole
{
    class Kisi
    {
        public int yas {  get; set; }
        public string dogumyeri { get; set; } 
        public string meslek {  get; set; }

        public Kisi(int yas, string dogumyeri, string meslek)
        {
            this.yas = yas;
            this.dogumyeri = dogumyeri;
            this.meslek = meslek;
        }
    }


    class Program
    {

        static void Main(string[] args)
        {
            Kisi kisi1 = new Kisi(1,"b",meslek:"c");
            kisi1.yas++; kisi1.dogumyeri = "ist"; kisi1.meslek = "otomasyon";
            Console.WriteLine(kisi1.meslek);
            Console.WriteLine(kisi1.dogumyeri+" "+kisi1.yas);

        }


    }
}

################################################################################################################################################################################################################################################

            C# programlama dilinde, bellek yönetimi iki temel alanı içerir: stack (yığın) ve heap (örtü). Bu iki alan, programın çalışma zamanında verileri depolamak için kullanılır, ancak farklı özelliklere sahiptir.

            Stack (Yığın):
            Stack, programın çalışma zamanında yönetilen bir bellek alanıdır. Bu alanda veriler, sıralı bir şekilde depolanır ve bu verilere hızlı erişim sağlanır. Stack'te veri depolamak için kullanılan bellek alanı, genellikle yönetilen (managed) veri tipleri ve değer tipleri içindir. İşte stack'te tutulan bazı veri tipleri:

            Değer Tipleri:

            int, char, float, double, bool gibi temel veri tipleri.
            struct tarafından tanımlanan yapılar.
            Yerel Değişkenler:

            Metot içerisinde tanımlanan değişkenler.
            Metot Çağrıları:

            Metot çağrıları ve metot çağrılarına ait yerel değişkenler.
            Stack'te depolanan veriler, programın akışı içinde meydana gelen işlemlerle birlikte otomatik olarak tahsis edilir ve serbest bırakılır. Stack, veri tipleri için hızlı erişim sağlar, ancak boyutları genellikle sınırlıdır ve yaşam süreleri kısa olduğu için otomatik olarak serbest bırakılır.

            Heap (Örtü):
            Heap, programın çalışma zamanında yönetilen bir diğer bellek alanıdır. Heap'te depolanan veriler, daha uzun ömürlüdür ve belirli bir yaşam süresine sahiptir. Genellikle heap, dinamik olarak tahsis edilen ve serbest bırakılan bellek alanıdır. Heap'te tutulan bazı veri tipleri şunlardır:

            Referans Tipleri:

            class tarafından tanımlanan nesneler.
            string gibi dinamik bellek tahsisi gerektiren türler.
            Dinamik Bellek Tahsisi:

            new anahtar kelimesi ile oluşturulan nesneler.
            Heap'te depolanan veriler, programcı tarafından elle serbest bırakılmalıdır (örneğin, Dispose veya Close gibi yöntemler kullanılarak), aksi takdirde bu bellek sızıntılarına neden olabilir.

            İki bellek alanı arasındaki temel farklar şunlardır:

            Hız ve Erişim Süresi: Stack, hızlı bir erişim sağlar çünkü bellek alanı sıralıdır. Heap ise daha fazla işlem gerektirir ve dolayısıyla daha yavaş erişim sağlar.

            Ömür ve Kapsam: Stack'te depolanan veriler genellikle kısa ömürlüdür ve otomatik olarak serbest bırakılır. Heap'te depolanan veriler daha uzun ömürlüdür ve programcı tarafından serbest bırakılmalıdır.


// struct tanımlama ve kullanımı

struct node // struct demek yapı ismi node ise kullanılacak isim.   class'lara benzerler... classların nesneleri heap alanında tutulur referancelidir.  structlarınki ise stack alanında tutulur ilkel veriler gibi.
{ // metottda tanımlayabiliriz...

    public int deger;
    public String name;
    public void yazdir(){

Console.WriteLine("AAAAA"); // WriteLine alt satıra geçirir Write alt satıra geçirmez...

    }
}

public static void Main(String[] args){
            node node1 = new node();

            node1.name = "emre";
            node1.deger = 15;
}



################################################################################################################################################################################################################################################

c#da her şey class'lar içerisinde yer alır global değişken vs gibi bir şey yoktur...
string sınıf referance ile çalışır. bir metot onu değiştirebilsin istersek eğer o zaman ref ile göndermemiz gerekir ref ile karşılamamız gerekir.
string name; yaparsak name otomatik null olur... null ise "" dir...  ascii'daki 0...
string sınıfı System kütüphanesinin altında yer alır System.string olarak kullanabiliriz...
string s;  s.Length ile uzunluk alabiliriz...  s[0] s[1] ... ile istenen indexteki elemana ulaşabiliriz...


            foreach (var item in kisi1.meslek)
            {
                Console.Write(item + " ");
            } // foreach ile string üzerinde dönebiliriz...


string s = "emre";
string b = s.Clone(); // böylece içerik kopyalama yapabiliriz Clone() ile...
s == b True verir... içerik kıyaslaması yapar c# eğer referance karşılaştırması yapmak istersek o zaman string.ReferenceEquals(a,b); kullanırız.

Endswith(); ve StarsWtih() ile nasıl başayıp nasıl bittiğini görebiliriz...
.Indexof() ise arar yoksa -1 verir varsa başlangıç indexini verir...
LastIndexOf() ise sondan aramaya başlar...
Insert(index,"istenen"); ile ekleme yapabiliriz. return eder yeni metni... araya eklersek isteneni diğerleri sağa kayar... sağında kalanlar istenen araya girer yani...
SubString(index,index2); index dahil index2 dahil değil arada kalan metni return et demektir...
.Replace(eski,yeni); return eder kalıcı değişim değildir. eski ile yeniyi değiştirir...
.Remove(index,index2); return eder istenen aralıktaki şeyleri siler...

kullanılmayan değerler garbage collector tarafından silinir...

###ENUM#############################################################################################################################################################################################################################################

nesneleri numaralandırmak için kullanılırlar...


namespace appConsole
{
    class Kisi
    {
        public int yas {  get; set; }
        public string dogumyeri { get; set; } 
        public string meslek {  get; set; }

        public Kisi(int yas, string dogumyeri, string meslek)
        {
            this.yas = yas;
            this.dogumyeri = dogumyeri;
            this.meslek = meslek;
        }
    }





    class Program
    {

        enum Aylar  // veritabanınıda yer almasını istemediğimiz verileri static olarak tutar programda. public statictir.
        {
           Ocak,Şubat,Mart,Nisan,Mayıs,Haziran,Temmuz,Ağustos,Eylül,Ekim,Kasım,Aralık
        }

        enum SiparisDurumu : byte // byte ile sıralandır demektir...
        {

            Hazırlanıyor,Hazırlandı,Kargolandı

        }

        enum Meyveler : int  
        {
            Elma = 1,muz = 2,Çilek = 3

        }

        static void Main(string[] args)
        {

            byte a = (byte)Meyveler.muz;
            byte b = (byte)Meyveler.Elma;
            byte c = (byte)Meyveler.Çilek;
            Console.WriteLine("{0} {1} {2}",a , b , c);
            
            Console.Read();


        }


    }
}



################################################################################################################################################################################################################################################

            namespace appConsole
            {
            
                class Person
                {

                    public Person() // constructor....
                    {

                        Console.WriteLine(1 + " ");
                    }

                }

                class Person2 : Person // Person2 Persondan kalıtım almış oldu... Person superclass Person2 ise Subclass olur...
                {

                    public Person2() // constructor....
                    {

                        Console.WriteLine(2);
                    }

                }

                class Program { 

                    static void Main(string[] args)
                    {

                        Person2 person = new Person2();  // 1 2 yazdırır çünkü bir subclass'ın oluşabilmesi için superclass'ın default constructor'unun çalışması lazım... ve hatta önce değişkenler oluşur bir class'ta sonra metotlar. class'lar değişkenler ve metotlardan oluşurlar...
                        // superclass'un default constructoru(boş olan) çalışmadan bitmeden subclass oluşmaz...
                    }


                }
            }

...................................................................................................................................

    class Person3
    {
        string name;

        public void yazdir(string name)
        {
            Console.WriteLine(name); // metota gelen name'yi yazdırır... eğer metota gelenle nesnenin namesi farklı isimle tanımlanmış olsa name1,name2 olarak o zaman this. vs kullanmaya gerek kalmazdır... hangisi nesnenin hangisi metotun belirtmeye gerek olmazdı...
            Console.WriteLine(this.name); // nesnenin namesini yazdırır... 

        }
        
    }

...................................................................................................................................

        using System;

        // Birinci sınıf (kalıtım alınan sınıf)
        public class Animal
        {
            public void Eat()
            {
                Console.WriteLine("The animal is eating.");
            }
        }

        // Birinci arayüz
        public interface IMove
        {
            void Move();
        }

        // İkinci arayüz
        public interface ISound
        {
            void MakeSound();
        }

        // Sınıf, hem Animal sınıfından kalıtım alıyor hem de IMove ve ISound arayüzlerini uyguluyor.
        public class Dog : Animal, IMove, ISound // yani : karşısına kalıtım alınacak nesne ve interfaceler yazılırsa iş tamamlanmış oluyor...
        {
            public void Bark()
            {
                Console.WriteLine("Woof woof!");
            }

            public void Move()
            {
                Console.WriteLine("The dog is moving.");
            }

            public void MakeSound()
            {
                Console.WriteLine("Barking sound");
            }
        }

        class Program
        {
            static void Main()
            {
                // Dog sınıfından bir örnek oluşturup kullanım
                Dog myDog = new Dog();
                myDog.Eat();        // Animal sınıfından kalıtım alınan metodu kullanma
                myDog.Bark();       // Dog sınıfının kendi metodunu kullanma
                myDog.Move();       // IMove arayüzünden gelen metodu kullanma
                myDog.MakeSound();  // ISound arayüzünden gelen metodu kullanma
            }
        }

...................................................................................................................................

mesela bir class'ın birden fazla interfacesi var ve bunların metotlarını override etmedi o zaman o class abstract olur... abstract class'tan nesne üretilemez... eğer abstract class'tan türetilen bir sınıf override edilmemiş şeyleri yani hepsini override etmezse abstract olur... nesne oluşturulması için bir o yapıda en kötü ihtimalle abstract olmayan class'ta hepsinin(geriye doğru toplam) override edilmesi lazım

...................................................................................................................................

Polimorfizm, bir nesnenin farklı türlerde davranabilme yeteneğidir. C# dilinde polimorfizm, genellikle iki şekilde gerçekleştirilir: method overriding (metot ezme) ve arayüzler.

1. Method Overriding (Metot Ezme):
Polimorfizmin temel özelliklerinden biri method overriding'dir. Bu özellik, bir alt sınıfta, üst sınıfta tanımlanan bir metodun aynı imza (signature) ile tekrar tanımlanmasını ifade eder. Bu, üst sınıftan türetilen nesnelerin aynı ad ve parametrelerle farklı davranışlar sergilemesini sağlar.


        public class Animal
        {
            public virtual void MakeSound()  // virtual olması lazım eğer bir metot'un override edilebilir olması için...
            {
                Console.WriteLine("Animal makes a sound");
            }
        }

        public class Dog : Animal
        {
            public override void MakeSound() // override ile ise override ettiğimizi belirtiriz... böylece subclass'ın nesnesine özgü olacak metot...
            {
                Console.WriteLine("Dog barks");
            }
        }

        public class Cat : Animal
        {
            public override void MakeSound()
            {
                Console.WriteLine("Cat meows");
            }
        }

        class Program
        {
            static void Main()
            {
                Animal animal1 = new Dog();
                Animal animal2 = new Cat();

                animal1.MakeSound(); // Dog barks
                animal2.MakeSound(); // Cat meows
            }
        }

superclass subclass'larına referance olabilir mesela buradan köpekten golden türetelim o zaman Animal ona referance olabilirdi...

...................................................................................................................................

namespace appConsole
{

    public class Animal
    {
        public virtual void MakeSound()
        {
            Console.WriteLine("Animal makes a sound");
        }
    }

    public class Dog : Animal
    {
        public override void MakeSound()
        {
            
            Console.WriteLine("Dog barks");

        }

        public void sesyaphele()
        {
        
            Console.WriteLine("SES");

        }

    }

    public class Cat : Animal
    {
        public override void MakeSound()
        {
            Console.WriteLine("Cat meows");
        }
    }

    class Program { 

        static void Main(string[] args)
        {


            Dog aa = new Dog();
         aa.sesyaphele();
             Animal bb = new Dog();
            // bb.MakeSound(); // hata veriyor bunun nedeni şudur = çünkü çalışan değişkenler ve metotlar Referance'ın içindekilerine erişebiliyor. Yani Referans ne ise onu kullanabilir c# onun kod bloğu içerisini görebiliriz...

            if(bb is Dog) // is ile bir nesne new Dog()'tan mı oluşturulmuş bunu görebiliriz... 
            {
                Dog cc = (Dog)bb; // ama bunun çözümü belli şunu yapabiliriz... Tip dönüşümü ile bu sorunu çözebiliriz.
                cc.sesyaphele();
            }


        }


    }
}

################################################################################################################################################################################################################################################

encapsulation demek verinin veya metotun class içerisinde örtülmesi demektir. private ile yapabiliriz. verielrin veya metotların korunması içindir. kaliteli program yazmak içindir.
  ortak olan yzılımcıdan ve kendimizden kontrolsüz erişimi engellemek için kullanırız....

                    Encapsulation, sınıfın içindeki verilerin ve metodların sınıf dışından gelen erişimlere karşı korunmasıdır. Bu, sınıfın iç detaylarının saklanarak, sadece belirlenen metodlar aracılığıyla dış dünyaya erişilebilmesini sağlar.

                    using System;

                    public class BankAccount
                    {
                        private string accountNumber;
                        private decimal balance;

                        public BankAccount(string accountNumber, decimal initialBalance)
                        {
                            this.accountNumber = accountNumber;
                            this.balance = initialBalance;
                        }

                        // Getter ve setter metotları aracılığıyla private alanlara erişim
                        public string AccountNumber
                        {
                            get { return accountNumber; }
                            set { accountNumber = value; }
                        }

                        public decimal Balance
                        {
                            get { return balance; }
                            private set { balance = value; }
                        }

                        // Para çekme işlemi
                        public void Withdraw(decimal amount)
                        {
                            if (amount > 0 && amount <= balance)
                            {
                                balance -= amount;
                                Console.WriteLine($"{amount:C} withdrawn. New balance: {balance:C}");
                            }
                            else
                            {
                                Console.WriteLine("Invalid withdrawal amount or insufficient funds.");
                            }
                        }

                        // Para yatırma işlemi
                        public void Deposit(decimal amount)
                        {
                            if (amount > 0)
                            {
                                balance += amount;
                                Console.WriteLine($"{amount:C} deposited. New balance: {balance:C}");
                            }
                            else
                            {
                                Console.WriteLine("Invalid deposit amount.");
                            }
                        }
                    }

                    class Program
                    {
                        static void Main()
                        {
                            // Encapsulation örneği
                            BankAccount myAccount = new BankAccount("123456789", 1000.00m);

                            // Getter ve setter kullanımı
                            Console.WriteLine($"Account Number: {myAccount.AccountNumber}");
                            myAccount.AccountNumber = "987654321";
                            Console.WriteLine($"New Account Number: {myAccount.AccountNumber}");

                            // Getter kullanımı
                            Console.WriteLine($"Balance: {myAccount.Balance:C}");

                            // Para çekme ve yatırma işlemleri
                            myAccount.Withdraw(500.00m);
                            myAccount.Deposit(200.00m);
                        }
                    }

...................................................................................................................................


    // property ile kapsülleme... 
    public class Bolum
    {

        private String bolumadi;

        public String GetBolumAdi()
        {

            return this.bolumadi;

        }

        public void SetBolumadi(string bolumadi)
        {

            if (bolumadi != null ) // buradaki bolumadi fonksiyona gelen bolumadi...
            {
                this.bolumadi = bolumadi;

            }
            else
            {
                this.bolumadi="null";
            }
          
        }

    }




...................................................................................................................................

   
    public class Bolum
    {

        private String bolumadi;

          public string Bolumdi
        {
            get { return bolumadi; } 
            set { 

                if (value.Equals("Programlama"))
                {

                    this.bolumadi = "boyle bir bolum yok..";

                }
                else
                {

                      bolumadi = value;
                }
            
            }
        } 


    }

    
...................................................................................................................................
            namespace appConsole
            {

                class Program {

                    static int deger = 0; // static olursa bir değer veya metot class'a özgü olur...
                    private string isim {  get; set; } // getter setterarı böyle kullanabiliriz...
                    private string id;
                    public string Id
                    {
                        get { return this.id; }
                        set { 

                            if (value == null) { 
                            this.id = "null";

                            }
                            else
                            {
                                this.id = value;
                            }

                                
                                ; }
                    }

                    public void yazdir() 
                    {
                        if (Program.deger == 3)
                        {

                            return; // return void bir metotu bitirmek içinde kullanılabilir...
                            
                        }

                        Program.deger++; // static değer değişimini class üzerinden yapıyoruz...
                        Console.WriteLine("\\"); // \ demek benden sonra gelen komut karakteri değil demek \\ ile biz \yazdırırız.. tek \ olursa " olarak kalır hata verir çünkü diğerine komut değilsin der ama o komut...
                        Program aa = new Program(); //  her seferinde yeni nesne oluşuyor...
                        aa.yazdir(); // recursive olarak çalışır...


                    }

                    public override string ToString()
                    {
                        return "SELAM KAHPE";
                    }

                    static void Main(string[] args)
                    {
                        Program aa = new Program(); // bir class içeriisnde kendi türünde nesne oluşturabiliriz... ve metotlarını değişkenlerini kullanabiliriz...
                        aa.isim = "aa";// burada set çalışır 
                        Console.WriteLine(aa.isim); // aa yazdırır... ve get çalışır... {get; set;} ile otomatik olarak getter setter ekleyebiliriz... 
                        Console.WriteLine(aa); // SELAM KAHPE
                        aa.yazdir();



                    }


                }
            }

..................................................................................................................................................................................................................................................


            using System;

            // Üst sınıf (superclass)
            public class Animal
            {
                // Üst sınıfa ait iki değişken
                protected string name;
                protected int age;

                // Üst sınıfın constructor'ı
                public Animal(string name, int age)
                {
                    this.name = name;
                    this.age = age;
                }

                // Üst sınıfa ait bir metot
                public void DisplayInfo()
                {
                    Console.WriteLine($"Name: {name}, Age: {age}");
                }
            }

            // Alt sınıf (subclass)
            public class Dog : Animal
            {
                // Alt sınıfa ait üçüncü değişken
                private string breed;

                // Alt sınıfın constructor'ı
                public Dog(string name, int age, string breed) 
                    : base(name, age) // Üst sınıfın constructor'ını çağırma super yerine :base(...) yapısı vardır... nnormalde super olur ve en üstte tanımlanır burada ise :base() ile en üstte olup olmama durumu ortadan kalkmış direkt olarak çalışır super() yani base()...
                {
                    this.breed = breed;
                }

                // Alt sınıfa ait kendi metodu
                public void DisplayBreed()
                {
                    Console.WriteLine($"Breed: {breed}");
                }

                // Alt sınıfa ait bir metot, üst sınıftan gelen metodu çağırma
                public new void DisplayInfo()
                {
                    base.DisplayInfo(); // Üst sınıfın metodu
                    Console.WriteLine($"Breed: {breed}");
                }
            }

            class Program
            {
                static void Main()
                {
                    // Alt sınıfın nesnesini oluşturma
                    Dog myDog = new Dog("Buddy", 3, "Golden Retriever");

                    // Alt sınıfın metotlarını çağırma
                    myDog.DisplayInfo();   // Üst sınıftan gelen metodu çağırma
                    myDog.DisplayBreed();  // Alt sınıfa ait metodu çağırma
                }
            }



################################################################################################################################################################################################################################################

interface sözleşme gibidir... metotları override edilmelidir.
interfaceler property barındılarabilir metotların tipini çalışma biçimini barındırabilirler...  int sayi{get;set;} gibi sonradan özelleştirmemiz lazım ama...
gövdeli metot olamaz. değişken tanımlanamaz.
constructor olamaz.
interface ile nesne üretilemez. ancak referance olabilir ama kendi metotlarına(tam emin değilim öyle herhalde)....
interfaceler kendisi arasında türetilebilir subinterface superinterface olayı vardır.
interfaceler genel olarak I ile başlarlar...
çoklu kalıtım interfaceler ile yarım yamalak sağlanırlar...
interfaceler erişim belirleyici almaz daima public'tir... public olmayan bir şey alamaz interface...
interface içerisinde static bir yapı kuramayız...
interfaceler parametreli metot imzası alabilir... void yazdir(string a, int 5); ...



............................................................................................................................................................................................................................................................................................
                C# dilinde, bir arayüz (interface), bir veya birden fazla sınıfın veya struct'ın belirli metotları, özellikleri ve olayları uygulamasını sağlayan bir türdür. İnterfaceler, çok sayıda türü ortak bir davranışa sahip olacak şekilde birleştirmek ve kodun daha esnek, modüler ve okunabilir olmasını sağlamak için kullanılır.

                Temel Arayüz Tanımı:
                Bir arayüz tanımı şu şekildedir:

        
                public interface ILogger
                {
                    // Metot tanımı
                    void Log(string message);

                    // Özellik tanımı
                    string LogName { get; set; }  // get ve setleri belirlememiz lazım ama...
                    
                    // Olay tanımı
                    event EventHandler LogEvent;
                }
                Bu örnekte, ILogger adında bir arayüz tanımlanmıştır. Bu arayüz, bir logger'ın (günlük kaydedici) temel davranışını tanımlar: Log metodu ile bir mesajı kaydetmek, LogName özelliği ile log adını almak ve LogEvent olayını kullanarak bir log olayını bildirmek.

                Arayüzü Uygulayan Bir Sınıf:
                Bir sınıf, bir arayüzü implements (uygular) anahtar kelimesiyle uygular. Örneğin:

            
                public class ConsoleLogger : ILogger
                {
                    // ILogger arayüzünden gelen metot
                    public void Log(string message)
                    {
                        Console.WriteLine($"Log: {message}");
                    }

                    // ILogger arayüzünden gelen özellik
                    public string LogName
                    {
                        get { return "ConsoleLogger"; }
                        set { /* Setter içeriği, gerektiğine göre uygulanabilir */ }
                    }

                    // ILogger arayüzünden gelen olay
                    public event EventHandler LogEvent;

                    // Başka metotlar, özellikler ve olaylar da eklenebilir.
                }
                Bu örnekte, ConsoleLogger sınıfı, ILogger arayüzünü uygular. Arayüzden gelen metot, özellik ve olaylar bu sınıf içinde gerçekleştirilir.


                Arayüz Kullanımı:
               
                class Program
                {
                    static void Main()
                    {
                        // ILogger arayüzü üzerinden nesne oluşturma
                        ILogger logger = new ConsoleLogger();

                        // Arayüz metotları kullanımı
                        logger.Log("Hello, Interface!");
                        Console.WriteLine($"LogName: {logger.LogName}");

                        // Arayüz olayına abone olma
                        logger.LogEvent += (sender, e) =>
                        {
                            Console.WriteLine("Log event triggered!");
                        };

                        // Arayüz olayını tetikleme (örnek amaçlı)
                        logger.LogEvent?.Invoke(null, EventArgs.Empty);
                    }
                }
                Bu örnekte, ILogger arayüzünü kullanarak bir ConsoleLogger nesnesi oluşturulmuş ve ardından arayüzün metotları, özellikleri ve olayları kullanılmıştır.

                Arayüzler, bir sınıfın birden fazla arayüzü uygulayabilmesine olanak tanır. Bu da çoklu kalıtımın sağladığı esneklik avantajlarını sunar. Ayrıca, interfaceler, kodun daha modüler olmasına ve kodun test edilebilirliğini artırmaya katkıda bulunur.
............................................................................................................................................................................................................................................................................................

    interface Idemo
    {
        void goster();

    }

    interface Iicerikler : Idemo
    {

        int sayi1 { get; set; }


    }

    class AA : Iicerikler
    {
        public int sayi1 { get { return sayi1; } set {sayi1 = value; } }

        public void goster()
        {
            Console.WriteLine("LETS GO...");

        }
    }

    // interfaceler kendi aralarında subinterface superinterface İlişkisi kurabilir. subinterface'i implement eden class superinterface'ide implement etmiş olur...



################################################################################################################################################################################################################################################

abstract olan bir metot subclass'ta override edilmeli edilmezse o classta abstract olur... çünkü gövdesiz metot vardır...
abstract metot varsa class'ta abstract'tır... kullanılma amacı override zorunluluğudur...

public abstract void Add();
public abstract void Delete(); 
public abstract void Update(); 
public abstract void Get(); 

gibi... bunun yerine interfacede kullanabilirdik...
eğer bir class abstract metot içeriyorsa ve interface implement edip tüm metotları override etmediyse abstract olur class...
static metot abstract olamaz...
abstract classlar private olamaz. public protected olabilir.
abstract classlar sealed anahtar kelimesi ile ifade edilemez...


                namespace appConsole
                {


                    abstract class Database
                    {
                        public abstract void Add();
                        public abstract void Delete();
                        public abstract void Update();
                        public abstract void Get();

                    }


                    class SQLserver : Database // extends edenler tüm metotları doldurur ve biz böylece override zorunluluğu sağlamış oluruz...
                    {
                        public override void Add()
                        {
                        }

                        public override void Delete()
                        {
                            
                        }

                        public override void Get()
                        {
                            
                        }

                        public override void Update()
                        {
                            
                        }
                    }

                    class MySql : Database
                    {
                        public override void Add()
                        {
                        }

                        public override void Delete()
                        {

                        }

                        public override void Get()
                        {

                        }

                        public override void Update()
                        {

                        }
                    }


                    class Program {

                        static void Main(string[] args)
                        {


                            MySql mySql = new MySql();
                            mySql.Add();
                            

                                
                        }

                    }

                }


##collectionS##############################################################################################################################################################################################################################################

                C# dilinde, bir sınıfın alanlarına erişimi kontrol etmek ve bu alanlara değer atamak için genellikle property'ler kullanılır. Property'ler, sınıfın dışındaki kodun sınıf içindeki verilere güvenli ve kontrol edilmiş bir şekilde erişmesini sağlar. Property'ler, genellikle sınıfın dışındaki kodun sınıfın içindeki verilere okuma ve yazma işlemleri gerçekleştirmesine izin verir.

                Temel Property Tanımı:
                Property, genellikle bir alanın okunması ve yazılmasını kontrol eden bir çift metottur. Aşağıda basit bir property tanımı örneği bulunmaktadır:

                public class Person
                {
                    // Private bir alan (field)
                    private string _name;

                    // Public bir property
                    public string Name
                    {
                        get { return _name; } // Okuma işlemi
                        set
                        {
                            if (!string.IsNullOrEmpty(value))
                            {
                                _name = value; // Yazma işlemi
                            }
                            else
                            {
                                Console.WriteLine("Name cannot be null or empty.");
                            }
                        }
                    }
                }
                Bu örnekte, Person sınıfında _name adında bir private alan ve Name adında bir public property bulunmaktadır. Name property'si hem okuma (get) hem de yazma (set) işlemlerini kontrol etmektedir.

                Property Kullanımı:
                Ardından, bu property'yi kullanmak için şu şekilde bir örnek yapabiliriz:


                class Program
                {
                    static void Main()
                    {
                        Person person = new Person();

                        // Property'yi kullanma
                        person.Name = "John"; // Yazma işlemi
                        Console.WriteLine($"Name: {person.Name}"); // Okuma işlemi
                    }
                }
                Bu örnekte, Person sınıfından bir nesne oluşturulmuş ve Name property'si hem yazılmış (set), hem de okunmuş (get). Property içinde yapılan kontrol, adın boş veya null olmamasını sağlar.

                Property'ler, nesne yönelimli programlamada sıkça kullanılır ve sınıfın dışındaki kodun sınıfın içindeki verilere güvenli bir şekilde erişmesine olanak tanır. Ayrıca, bir property'nin altındaki gerçek işlevselliği saklamak için metotlar içerebilirler.

                User
                c#da collectionsları detaylı şekilde anlatabilir misin
                ChatGPT
                Evet, tabii ki! C# dilinde, Collections (Koleksiyonlar) genel olarak gruplandırılmış verileri yönetmek için kullanılan veri yapılarıdır. .NET Framework içerisinde birçok farklı koleksiyon sınıfı bulunmaktadır. Bu koleksiyon sınıfları, verileri depolamak, sıralamak, filtrelemek ve genel olarak işlemek için kullanılır. İşte C# dilinde sıkça kullanılan bazı koleksiyon türleri:

                1. List<T>:
                List<T> sınıfı, dinamik bir dizi olarak düşünülebilir ve belirli bir türdeki öğeleri içerir.


                using System;
                using System.Collections.Generic;

                class Program
                {
                    static void Main()
                    {
                        // List<T> kullanımı
                        List<string> names = new List<string>();
                        
                        // Öğe ekleme
                        names.Add("Alice");
                        names.Add("Bob");
                        names.Add("Charlie");

                        // Öğeleri gezme
                        foreach (var name in names)
                        {
                            Console.WriteLine(name);
                        }
                    }
                }


                2. Dictionary<TKey, TValue>:
                Dictionary<TKey, TValue> sınıfı, anahtar-değer çiftleri içeren bir koleksiyondur.


                using System;
                using System.Collections.Generic;

                class Program
                {
                    static void Main()
                    {
                        // Dictionary<TKey, TValue> kullanımı
                        Dictionary<int, string> students = new Dictionary<int, string>();
                        
                        // Öğe ekleme
                        students.Add(1, "Alice");
                        students.Add(2, "Bob");
                        students.Add(3, "Charlie");

                        // Öğeleri gezme
                        foreach (var student in students)
                        {
                            Console.WriteLine($"Student ID: {student.Key}, Name: {student.Value}");
                        }
                    }
                }



                3. Queue<T>:
                Queue<T> sınıfı, birinci giren, birinci çıkan (First In First Out - FIFO) prensibiyle çalışan bir kuyruk yapısını temsil eder.


                using System;
                using System.Collections.Generic;

                class Program
                {
                    static void Main()
                    {
                        // Queue<T> kullanımı
                        Queue<string> queue = new Queue<string>();
                        
                        // Öğe ekleme
                        queue.Enqueue("Apple");
                        queue.Enqueue("Banana");
                        queue.Enqueue("Cherry");

                        // Öğeleri çıkarma
                        while (queue.Count > 0)
                        {
                            Console.WriteLine(queue.Dequeue());
                        }
                    }
                }



                4. Stack<T>:
                Stack<T> sınıfı, son giren, ilk çıkan (Last In First Out - LIFO) prensibiyle çalışan bir yığın yapısını temsil eder.


                using System;
                using System.Collections.Generic;

                class Program
                {
                    static void Main()
                    {
                        // Stack<T> kullanımı
                        Stack<string> stack = new Stack<string>();
                        
                        // Öğe ekleme
                        stack.Push("Apple");
                        stack.Push("Banana");
                        stack.Push("Cherry");

                        // Öğeleri çıkarma
                        while (stack.Count > 0)
                        {
                            Console.WriteLine(stack.Pop());
                        }
                    }
                }


..............................................................................................................................................................................................................................................................................................................................................................


        namespace appConsole
        { 

            class Program {

                static void Main(string[] args)
                {

                    ArrayList arraylist = new ArrayList();


                    referancemi(arraylist);
                    foreach(var item in arraylist)
                    {
                        Console.Write(item); // eeee  aaaa... yazdırdı...
                    }
                        
                }

                public static void referancemi(ArrayList a)
                {
                    a.Add("eeee");
                    a.Add("aaaa...");

                }


            }

        }

        // yani tıpkı diziler gibi System.collections ile çalışanlarda referanceler ile çalışırlar... bir metota ben onu yolladığımda onu karşılayanda referans ve yolladığımın referanceını karşılıyor böylece değişim olursa kalıcı değişim oluyor... 
        // arraylistler nesne alırlar... sayı vs gönderebiliriz ama c#da sayılar vs her şey zaten nesne mantığı ile çalışır. 
        // hem string hem int vss istenen nesneleri yollayabiliriz karmaşık şekilde tutabiliriz... yeterki nesne yolla... ama c#da zaten her veri nesne olarak geçiyor... her şey class'tan türüyor. ama heapta ve stack'te tutulanlar olarak ayrılıyorlar...



..............................................................................................................................................................................................................................................................................................................................................................
c#da string'de int gibi davranır... bir tek java ile fark odur...
..............................................................................................................................................................................................................................................................................................................................................................












####multithreading############################################################################################################################################################################################################################################

                    using System;
                    using System.Collections.Generic;
                    using System.Linq;
                    using System.Text;
                    using System.Threading.Tasks;
                    using System.Data.SQLite;
                    using System.Collections;
                    using System.Threading; // bunu çağırmak lazım... hem thread üretmek hemde sleep için...

                    namespace appConsole
                    { 

                        class Program {

                            static void Main(string[] args)
                            {

                                Thread mainThread = Thread.CurrentThread;
                                mainThread.Name = "Main Thread";
                                Console.WriteLine(mainThread.Name);

                                /*
                                CountDown();
                                CountUp();
                                
                                Main Thread
                    Time #1:10 Seconds
                    Time #1:9 Seconds
                    Time #1:8 Seconds
                    Time #1:7 Seconds
                    Time #1:6 Seconds
                    Time #1:5 Seconds
                    Time #1:4 Seconds
                    Time #1:3 Seconds
                    Time #1:2 Seconds
                    Time #1:1 Seconds
                    Time #1:0 Seconds
                    timer #1 is complete...
                    Time 21:0 Seconds
                    Time 21:1 Seconds
                    Time 21:2 Seconds
                    Time 21:3 Seconds
                    Time 21:4 Seconds
                    Time 21:5 Seconds
                    Time 21:6 Seconds
                    Time 21:7 Seconds
                    Time 21:8 Seconds
                    Time 21:9 Seconds
                    Time 21:10 Seconds
                    timer #2 is complete...


                                */ // Threadsiz kullanım bu şekilde sırası ile çalışır Thread kullanırsak eğer o zaman iş değişir.

                                Thread thread1 = new Thread(CountUp);
                                Thread thread2 = new Thread(CountDown);

                                thread1.Start(); // başlatır ve aşağı satıra geçirir kodu bu yüzden thread1 çalışırken thread2'de çalışmaya başlayabilir...
                                thread2.Start();

                                /*
                                Main Thread
                    Time 21:0 Seconds
                    Time #1:10 Seconds
                    Time #1:9 Seconds
                    Time 21:1 Seconds
                    Time #1:8 Seconds
                    Time 21:2 Seconds
                    Time #1:7 Seconds
                    Time 21:3 Seconds
                    Time #1:6 Seconds
                    Time 21:4 Seconds
                    Time 21:5 Seconds
                    Time #1:5 Seconds
                    Time 21:6 Seconds
                    Time #1:4 Seconds
                    Time #1:3 Seconds
                    Time 21:7 Seconds
                    Time #1:2 Seconds
                    Time 21:8 Seconds
                    Time 21:9 Seconds
                    Time #1:1 Seconds
                    Time 21:10 Seconds
                    Time #1:0 Seconds
                    timer #2 is complete...
                    timer #1 is complete...

                                
                                */






                                Console.ReadKey();


                            }

                            public static void CountDown()
                            {

                                for (int i = 10; i >= 0; i--)
                                {

                                    Console.WriteLine("Time #1:" + i + " Seconds");
                                    Thread.Sleep(1000); // 1000 milisaniye...

                                }
                                Console.WriteLine("timer #1 is complete...");
                            }

                            public static void CountUp()
                            {

                                for (int i = 0; i <= 10; i++)
                                {

                                    Console.WriteLine("Time 21:" + i + " Seconds");
                                    Thread.Sleep(1000); // 1000 milisaniye...

                                }
                                Console.WriteLine("timer #2 is complete...");
                            }


                        }


                        

                    }

// yani işleri metotlara bölerek biz threadlere metotları vererek işleri bölebiliriz. thread başlarsa direkt olarak çalışır ve program aşağı satırları okumaya başlar... o anda o thread'da çalışır halde kalır...



################################################################################################################################################################################################################################################

// Main sadece bir tane olur ve programın çalışması için gerekli olan o metottur ana metottur...
// C# dilinde bir uygulama sadece bir tane Main metodu içerebilir. Bu metot, programın başlangıç noktasını temsil eder ve programın çalışmasına başladığı yerdir. Main metodu, static olarak işaretlenmiş ve genellikle bir sınıf içinde yer alır.
// String ile string arasında bir fark yoktur... ikiside aynıdır referans bilmem ne vs vs... 

            bool dogrumu = false;

            while (dogrumu)
            {





            }
            if (dogrumu)
            {

                    
            }else if (dogrumu) { 
            
            
            }else { Console.WriteLine("FORD ");
            }

// değişkenler verileri tutan yapılardır. her sınıf bir blok içerisindedir.
// bir class içerisinde tanımlananlar aslında o class'a özgüdür...
// c#da değişkenler rakamla vs başlayamaz... metinsel ifadeler falan mantıklıdır. ve dikkat etmemiz gerekn bir nokta  class isimleri büyükle başlar fonkisyonlar vve değişkenler ise küçükle başlar yeni kelimede o kelimenin baş harfi büyür.
class: EmreAraba   metot: gitAraba() değişken: arabaMotor = 12; gibi...
// değişken bir class içerisinde kullanıldı ise tüm class ona erişebilir.

// stack ve heap dene iki bölge var bellekte ana bölgede ramle bellek arasında fark var stack ve heap olarak. değer tipliler stackte tutulur referance tipliler ise heap alanında tutulur sınıflara ait nesneler heapte tutulur.
// string dışındakiler stack'te tutulur. string ise heapte.

// sabit ve değişken farkı nedir... const mesela değişmez ve değeri tanımlanırken atanmalı.
          const int deger2 = 11;  gibi.
          int deger1 = 11; 
          deger1 = 12; // sabit değildir değişkendir const değilse... porgramda zamanla değişebilir.

// c# dilinde bir veriye double int float vs değer verilmediyse eğer o zaman 0 olur string ise null olur vs vs mesela class ürettik emre diye emre emre1; dedik emre1 nulldır. default olarak 0 veya null ataması yapılır...
//             int[] matris1 = new int[100]; dizi oluşturma böyle yapılır.

// string bir referans türüdür, yani değer tipleri gibi doğrudan değeri saklamaz. Bunun yerine bellekte bir referans saklar ve bu referans, metni içeren bellek bölgesini gösterir.
     

        public static int toplama(int a)
        {
            return a;
        }
        public static int toplama(int a,int b)
        {
            
            return a + b; 
        }
        // ikisinide aynı anda kullanabiliriz gönderilen verilere göre hangi metotun çalışacağını ise c# belirler buna method overloading denir...
        mesela toplama(5) dersem en üstteki çalışır toplama(10,8) dersen alttaki çalışır...



class isimler
{


    private int deger;
    private String name;
    private isimler isimlersonraki = null;  // burada mesela her nesne oluştuğunda otomatik olarak null olacak...

    
    public isimler(int deger, string name)
    {   
        this.deger = deger;
        this.name = name;
    }
         public isimler() // default constructor'dur bu mesela...   iki tane constructor var bunada constructor overloading denir... parametrelere göre hangisi çlaışacak c# belirler bunu
    {   
        
    }
     

}


// c# dilinde veri tipleri ilkel değildir. hepsi bir nesnedir.
// her sınıf soyut bir veri yapısıdır.
// /**/  buda uzun veri sistemi.
// common type sistem = ortak veri modeli.
// import yerine using kullanırız...

/*
            Console.Write("Kullanici adi giriniz: ");
            string isim = Console.ReadLine();
            Console.WriteLine(isim);

*/ consoldan veri alma böyle yapılır string için... 

// c# dilinde global değişken yoktur her veri bir class'a özgü olmalıdır. her metot her değişken bir class'a bağlı olmalıdır.
// değişkenler rakamlarla başlamaz arada boşluk olamaz para simgeleri olabilir ! & vs gibi karakterler olmaz.
// değişkenlerde iki tip vardır değer ve referance tipleri.  stack ve heap bölgeleri vardır bellekte.   ramda stack ve heap vardır.  referance tipleri heapte tutulur.   classla başlayan yapılar heapte tutulur string dışı değerler stackte tutulut değer tiplidir çünkü...
// charda aslında sayısal olarak tutar ama biz onu karakterlere çeviririz dil ile.

            Console.Write("");  // yazar ve alt satıra geçirmez...
            Console.WriteLine(""); // yazar ve alt satıra geçirir otomatik olarak \n eklenir...

            Console.Write( 14 + " " +  4); demek aslında append demek...  tüm değerleri string yapar eğer +'nın içerisinde string varsa ve sırası ile hepsini append eder...

string yazi1 = "emre" + 15; hata vermez... 15 string'e çevrilir ve + ile append edilir..
string yazi2 = 15; hata verir...   

// encapsulation demek nesnenin vcerilerine nesne.  şeklinde ulaşmayı private ile kısıtlamak demektir...     nesnenin verilerine nesnenin metotları ile ulaşmak kontrollü şekilde... getter setter kullanırız genel olarak. 



ctrl + class'ın üstüne tık ile içerisine gidebilir bilgileri görebiliriz...

..............................................................................................................................................................................................................................................................................................................................................................
            C# dilinde, bir sınıfın alanlarına erişimi kontrol etmek ve bu alanlara değer atamak için genellikle property'ler kullanılır. Property'ler, sınıfın dışındaki kodun sınıf içindeki verilere güvenli ve kontrol edilmiş bir şekilde erişmesini sağlar. Property'ler, genellikle sınıfın dışındaki kodun sınıfın içindeki verilere okuma ve yazma işlemleri gerçekleştirmesine izin verir.

            Temel Property Tanımı:
            Property, genellikle bir alanın okunması ve yazılmasını kontrol eden bir çift metottur. Aşağıda basit bir property tanımı örneği bulunmaktadır:

         
            public class Person
            {
                // Private bir alan (field)
                private string _name;

                // Public bir property
                public string Name
                {
                    get { return _name; } // Okuma işlemi
                    set
                    {
                        if (!string.IsNullOrEmpty(value))
                        {
                            _name = value; // Yazma işlemi
                        }
                        else
                        {
                            Console.WriteLine("Name cannot be null or empty.");
                        }
                    }
                }
            }
            Bu örnekte, Person sınıfında _name adında bir private alan ve Name adında bir public property bulunmaktadır. Name property'si hem okuma (get) hem de yazma (set) işlemlerini kontrol etmektedir.

            Property Kullanımı:
            Ardından, bu property'yi kullanmak için şu şekilde bir örnek yapabiliriz:

        
            class Program
            {
                static void Main()
                {
                    Person person = new Person();

                    // Property'yi kullanma
                    person.Name = "John"; // Yazma işlemi
                    Console.WriteLine($"Name: {person.Name}"); // Okuma işlemi
                }
            }
            Bu örnekte, Person sınıfından bir nesne oluşturulmuş ve Name property'si hem yazılmış (set), hem de okunmuş (get). Property içinde yapılan kontrol, adın boş veya null olmamasını sağlar.

            Property'ler, nesne yönelimli programlamada sıkça kullanılır ve sınıfın dışındaki kodun sınıfın içindeki verilere güvenli bir şekilde erişmesine olanak tanır. Ayrıca, bir property'nin altındaki gerçek işlevselliği saklamak için metotlar içerebilirler.

..............................................................................................................................................................................................................................................................................................................................................................

        C# dilinde iki stringin aynı referansı taşıyıp taşımadığını kontrol etmek için == operatörü değer karşılaştırması yapar, yani iki string'in içeriğini kontrol eder, referans karşılaştırması yapmaz. Yani == operatörü, stringlerin içeriğini kontrol eder.

        Örneğin:

        string isim1 = "emre";
        string isim2 = "emre";

        if (isim1 == isim2)
        {
            Console.WriteLine("İsimler eşittir.");
        }
        else
        {
            Console.WriteLine("İsimler eşit değildir.");
        }
        Yukarıdaki örnekte, isim1 ve isim2 string'leri aynı değeri taşıdığı için == operatörü true dönecektir.

        Ancak, C# dilinde referans karşılaştırması yapmak istiyorsanız object.ReferenceEquals metodunu kullanabilirsiniz:


        if (object.ReferenceEquals(isim1, isim2))
        {
            Console.WriteLine("İsimler aynı referansı taşıyor.");
        }
        else
        {
            Console.WriteLine("İsimler aynı referansı taşımıyor.");
        }
        Bu durumda, object.ReferenceEquals metodu, iki string'in aynı referansı taşıyıp taşımadığını kontrol eder. Ancak, genellikle string karşılaştırmalarında == operatörü daha yaygın olarak kullanılır.

..............................................................................................................................................................................................................................................................................................................................................................

string isim = "emre";
string isim2 = isim;  // buda emre olur ama referance yüüzden değil değer ataması yapılır burada. javadaki gibi değil..

        Araba araba1 = new Araba { Model = "Toyota" };
        Araba araba2 = araba1;

        araba1.Model = "Ford";

        Console.WriteLine(araba2.Model);  // Bu, "Ford" yazdırır çünkü class'lardan oluşan nesneler referancelerle çalışırlar...

..............................................................................................................................................................................................................................................................................................................................................................

    internal class Program
    {
        static void Main(string[] args)
        {

            class1 cs1 = new class1("aaa", "bbb", 111);

            degistir(cs1);
            Console.WriteLine(cs1.age); // bir yazdırdı...



        }

        public static void degistir(class1 b)
        {
            b.age = 1;
          
        }

    }

class'lar kendi oluşturduklarımız vs onlardan oluşan nesneler referanceleri ile çalışırlar... bu yüzden void metotta değişim oldu gönderdiğimiz nesnenin değeri kalıcı olarak değişti... bunun sebebi pointer mantığıdır. nesneler heap ve stack olacak şekilde referanslı veya referancesiz olarak saklanırlar. bizim oluşturduklarımız ile oluşanlarda referance mantığı işler...
classlar(kendimizin) ve arraylar referance mantığı ile çalışır diğerleri çalışsın istersek o zaman ref yapısını kullanırız...


..............................................................................................................................................................................................................................................................................................................................................................

break ve continue bağlı oldukları döngü için çalışırlar sadece bir döngü için çalışırlar...

for while do while hepsi için aynı neredeyse...

..............................................................................................................................................................................................................................................................................................................................................................

        static void Main(string[] args)
        {

            string[] isimler = new string[3];
            isimler[0] = "aaaa";
            isimler[1] = "bbbb";
            isimler[2] = "cccc";

            foreach (string i in isimler)   // önce tipi belirtiriz. sonra i deriz iterasyon yapacak yapıya. ve dönülecek yapı.
            {
                Console.WriteLine(i);
            }
        }

        // string yerine biz var yazabilirdik bir fark olmazdı ikiside çalışır...  
        // var = bu anahtar kelime ile değişken oluşturursak ve atamasını yaparsak var tarafından onun tipi belirlenir. pythondaki yapı ile aynı neredeyse...

C# programlama dilinde "var" bir değişkenin türünü belirlemeden önce, derleme zamanında türünün belirlenmesine izin veren bir anahtar kelimedir. "var" anahtar kelimesini kullanarak bir değişken tanımladığınızda, derleyici, değişkenin türünü sağlanan başlatma değerinden çıkarır.

Örneğin:

var sayi = 42; // sayi değişkeni int türünde bir değişkendir.
var metin = "Merhaba, Dünya!"; // metin değişkeni string türünde bir değişkendir.
Bu durumda, derleyici, sayi değişkenini int ve metin değişkenini string olarak anlar. Ancak, "var" kullanılarak tanımlanan değişkenlerin başlangıç değeri ile türü belli olmalıdır, çünkü derleyici, başlangıç değeri üzerinden türü çıkarır. Ayrıca, bir kez atanmış bir değişkenin türü değiştirilemez.
..............................................................................................................................................................................................................................................................................................................................................................





