Install-Package System.Data.SQLite   console manager kısmına yazarak SQLite kullanabiliriz... masaüstü uygulamaları için harika entity framework'te kullanabiliriz orm olarak destekler...
        SQLite NuGet Paketini Yükleme:
        Projenize SQLite ile çalışmak için System.Data.SQLite NuGet paketini ekleyin. Visual Studio kullanıyorsanız, "NuGet Package Manager Console" penceresini açıp aşağıdaki komutu kullanarak paketi yükleyebilirsiniz:

        bash
        Copy code
        Install-Package System.Data.SQLite
******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Form1 ff = new Form1();
         ff.ShowDialog();


          Console.WriteLine("merhababaaaaaa");
c# dilinde showDialog ile form açılıyor ama ben açıldıktan sonra alltaki yazıyıda yazdırsın istiyorum yani programın okuması orada takılı kalıyor ne yapmam lazım
ChatGPT
ShowDialog metodu, ilgili form kapatılana kadar kontrolü ele geçirir. Bu nedenle, ShowDialog metodundan sonra gelen kodlar, form kapandığında çalışır. Eğer formun üzerindeki işlemler tamamlandıktan sonra bir şeyler yapmak istiyorsanız, Form1 sınıfınızda bir olay (event) tanımlayarak bu olayı uygun bir durumda tetikleyebilirsiniz. Örneğin, formunuz kapatıldığında bir olay tetikleyerek ardından gelen kodları çalıştırabilirsiniz.

c#'da from uygulaması showDialog ile açıldıktan sonra o panel açık olduğu sürece alt satıra geçmez programın okuma imleci orada takılı kalır taki kapanana kadar...


************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
C# dilini daha ileri seviyede öğrenmek için aşağıdaki konulara odaklanabilirsiniz. Bu konular, C# programlamadaki ileri seviye konseptlere ve geliştirme tekniklerine odaklanmaktadır:

Nesne Yönelimli Programlama (OOP):
    C#'da nesne yönelimli programlama temel bir konsepttir. Sınıflar, nesneler, miras, soyut sınıflar, arayüzler, çoklu kalıtım gibi OOP konularını öğrenmek önemlidir.

İleri Seviye Dil Özellikleri:
    C#'daki en yeni dil özelliklerini anlamak ve kullanmak için çalışın. Örneğin, C# 8 ve sonraki sürümlerdeki özellikler arasında nullable reference types, pattern matching, switch expressions gibi konular bulunmaktadır.

LINQ (Language Integrated Query):
    LINQ, veri sorgulama ve manipülasyonu için kullanılan güçlü bir dil entegre sorgu aracıdır. LINQ kullanarak veri tabanlarına, koleksiyonlara ve diğer veri kaynaklarına sorgular yazmayı öğrenmek önemlidir.
Asenkron ve Paralel Programlama:
    Modern uygulamalar genellikle asenkron ve paralel programlama tekniklerini kullanır. async ve await anahtar kelimelerini kullanarak asenkron programlamayı, paralel programlamayı da inceleyerek çoklu iş parçacığı (multithreading) konularını anlamak önemlidir.

Exception Handling (İstisna Yönetimi):
    Hata işleme konusunu daha iyi anlamak için try, catch, finally bloklarını kullanma becerisi geliştirmek önemlidir.
Veri Tabanı Programlaması:
    Entity Framework veya Dapper gibi C# ile entegre veri tabanı erişim araçlarını öğrenmek ve kullanmak.
    
ASP.NET MVC veya ASP.NET Core:
    Web uygulamaları geliştirmek için ASP.NET MVC veya ASP.NET Core framework'ünü öğrenmek. MVC tasarım deseni, routing, middleware kavramlarına hakim olmak önemlidir.

Unit Testing (Birim Testleri):
    NUnit, xUnit veya MSTest gibi birim testi çerçeveleri kullanarak uygulamalarınızı test etmeyi öğrenmek. Test yazma, test odaklı geliştirme ve test otomasyonu konularına hakim olmak önemlidir.
Dependency Injection ve IoC (Inversion of Control):
    Uygulama bağımlılıklarını yönetmek için Dependency Injection (Bağımlılık Enjeksiyonu) ve IoC konularını anlamak ve uygulamak.

Git ve Source Control Sistemleri:

Git gibi versiyon kontrol sistemlerini kullanarak kodunuzu yönetmeyi öğrenmek.
Bu konuları öğrenmek ve uygulamak, C# dilindeki yeteneklerinizi daha da geliştirmenize yardımcı olacaktır. Ayrıca, projeler üzerinde çalışmak ve gerçek dünya uygulamaları geliştirmek de öğrenme sürecinizi hızlandıracaktır.

......................................................................................................................................................................................................................................................................................................................................................................................................

C# programlama dilinde, bellek yönetimi iki temel alanı içerir: stack (yığın) ve heap (örtü). Bu iki alan, programın çalışma zamanında verileri depolamak için kullanılır, ancak farklı özelliklere sahiptir.

Stack (Yığın):
Stack, programın çalışma zamanında yönetilen bir bellek alanıdır. Bu alanda veriler, sıralı bir şekilde depolanır ve bu verilere hızlı erişim sağlanır. Stack'te veri depolamak için kullanılan bellek alanı, genellikle yönetilen (managed) veri tipleri ve değer tipleri içindir. İşte stack'te tutulan bazı veri tipleri:

Değer Tipleri:

int, char, float, double, bool gibi temel veri tipleri.
struct tarafından tanımlanan yapılar.
Yerel Değişkenler:

Metot içerisinde tanımlanan değişkenler.
Metot Çağrıları:

Metot çağrıları ve metot çağrılarına ait yerel değişkenler.
Stack'te depolanan veriler, programın akışı içinde meydana gelen işlemlerle birlikte otomatik olarak tahsis edilir ve serbest bırakılır. Stack, veri tipleri için hızlı erişim sağlar, ancak boyutları genellikle sınırlıdır ve yaşam süreleri kısa olduğu için otomatik olarak serbest bırakılır.

Heap (Örtü):
Heap, programın çalışma zamanında yönetilen bir diğer bellek alanıdır. Heap'te depolanan veriler, daha uzun ömürlüdür ve belirli bir yaşam süresine sahiptir. Genellikle heap, dinamik olarak tahsis edilen ve serbest bırakılan bellek alanıdır. Heap'te tutulan bazı veri tipleri şunlardır:

Referans Tipleri:

class tarafından tanımlanan nesneler.
string gibi dinamik bellek tahsisi gerektiren türler.
Dinamik Bellek Tahsisi:

new anahtar kelimesi ile oluşturulan nesneler.
Heap'te depolanan veriler, programcı tarafından elle serbest bırakılmalıdır (örneğin, Dispose veya Close gibi yöntemler kullanılarak), aksi takdirde bu bellek sızıntılarına neden olabilir.

İki bellek alanı arasındaki temel farklar şunlardır:

Hız ve Erişim Süresi: Stack, hızlı bir erişim sağlar çünkü bellek alanı sıralıdır. Heap ise daha fazla işlem gerektirir ve dolayısıyla daha yavaş erişim sağlar.

Ömür ve Kapsam: Stack'te depolanan veriler genellikle kısa ömürlüdür ve otomatik olarak serbest bırakılır. Heap'te depolanan veriler daha uzun ömürlüdür ve programcı tarafından serbest bırakılmalıdır.

......................................................................................................................................................................................................................................................................................................................................................................................................


// blank solution boş bir çözüm ekranı açar...
// existing project ile projelerin benzer kısımlarını çekebiliriz...
// bazen framework sürüm farklılığından dolayı projeler çalışmayabilir buna dikkat etmek lazım...
// Sürümlerde üst olan hepsini kapsar ama 4.7.2   4.8 ile yazılmış olanı desteklemeyebilir. ama 4.8 kendinden alt olanları destekler.  
// nuget ile biz istersek dependies ekleyebiliriz entity framework gibi...
// c#da her veri wrapper classtır yani her ver bir nesnedir. bu yüzden her verinin metotlarını kullanabiliriz. mesela int a = 8; deriz a.equals vs kullanabiliriz...  eğer bir metotta yollayıp değerinin değişmesini falan istersek o zaman ref ile yollarız...
// static metot static main içinde çalışabilir static olmayan değer static içinde çalışmaz... static-static veya non-static - non-static olmalı...
// mesela bir class'ın oluşması için önce onun superclass'ı oluşmalı oluşurken default constructor çalışır....
degistir(ref a)
public void degisttir(ref int b) gibi...

c#da ilkel yapılar yoktur. her şey nesnedir... wrapper classtır aslında veriler.
            Console.WriteLine(int.MinValue);   // mesela direkt olarak int class'ının içindeki static MinValue değerini çağırabiliriz...  static olan değerleri ve metotları direkt olarak class ile kullanabiliriz...
            Console.WriteLine(int.MaxValue);

Console.WriteLine(int.MinValue + " EMRE"+ byte.MinValue+" FORD"+byte.MaxValue);
     + demek String'de ekleme yap demektir. böylece tüm değerler string'e döner ve işlem yapabiliriz...



            double say11 = 12.2;
            Console.WriteLine(say11);
            float say12 = (float)12.33;  // her noktalı değer aslında double'dir bizim atama yaparken float'a tip dönüşümü yapmamız lazım uppercasting yapmamız gerekiyor...
            Console.WriteLine(say12);




c#tada diğer dillerde olduğu gibi tüm veriler tanımlanır bir metot eğer bir değer dönderiyorsa o zaman tipinde karşılanır int sayi1 = sayigetir(); gibi.

Tam Sayı Veri Tipleri:

int: 32 bitlik işaretli tam sayı.
long: 64 bitlik işaretli tam sayı.
short: 16 bitlik işaretli tam sayı.
byte: 8 bitlik işaretli tam sayı.
sbyte: 8 bitlik işaretli tam sayı.

Ondalıklı Sayı Veri Tipleri:

float: 32 bitlik ondalıklı sayı.
double: 64 bitlik ondalıklı sayı.
decimal: 128 bitlik ondalıklı sayı.

Karakter Veri Tipleri:

char: 16 bitlik Unicode karakter.

Boolean Veri Tipi:

bool: Mantıksal (true veya false) değeri temsil eder.

Metinsel Veri Tipleri:

string: Metin verilerini tutan veri tipi...  
        Console.WriteLine(String.Format("{0} {1}",str1,str2));   böylede kullanabiliriz...
        .Length ile uzunluk alabiliriz...
        string aa = bb.Clone(); ile ise biz bb'nin içeriğini aa'ya atayabiliriz. 
        string.IsNullOrWhiteSpace(str1)   true false çevirir... boş değilse false çevirir mail adresi için falan kullanılır.

Object Veri Tipi:

object: Tüm diğer türlerin temel türüdür. Her türden bir nesneyi temsil edebilir.
Diziler:

int[], string[], vb.: Belirli bir türdeki elemanları içeren diziler.
Nullable Veri Tipleri:

int?, bool?, vb.: Nullable türler, değerlerin null olabileceği anlamına gelir.
Enumerations (Enum):

enum: Belirli bir türdeki sabit değerlerin adlarını içeren bir türdür.
Yapılar (Structures):

struct: Değer türleri olan, ancak sınıflar gibi davranabilen türler.
Sınıflar (Classes):

class: Referans türleri olan ve nesne tabanlı programlamanın temelini oluşturan türler.
Interface ve Arayüzler:

interface: Bir sınıfın uygulamasını zorlayan bir sözleşme sağlayan tür.

// oop demek encapsulation,polymorphism and inheritance demektir aslında...
// interfaceler aslında birer sözleşmelerdir böylece içerisindeki metotları override etmek zorunlu olur implement eden class tarafından...

################################################################################################################################################################################################################################################


            Console.WriteLine(Byte.MaxValue); // 255    256 vermeye çalışırsan Byte değere o zaman hata verir...
            Console.WriteLine(Byte.MinValue); // 0
            Console.WriteLine(long.MinValue); // -9223372036854775808
            Console.WriteLine(long.MaxValue); //   9223372036854775807
            Console.WriteLine(int.MaxValue); // 2147483647    32 bit 4 byte 2^^32 değer alır.
            Console.WriteLine(int.MinValue); // - 2147483648
            Console.WriteLine(long.MaxValue / int.MaxValue); // 4294967298
            Console.WriteLine(double.MinValue); //-1,79769313486232E+308
            Console.WriteLine(double.MaxValue); // 1,79769313486232E+308
            Console.WriteLine(ulong.MaxValue); // 18446744073709551615
            Console.WriteLine(ulong.MinValue); // 0
            Console.WriteLine(sbyte.MaxValue); // 127
            Console.WriteLine(sbyte.MinValue); // - 128
            Console.WriteLine(short.MaxValue); // 32767
            Console.WriteLine(short.MinValue); //-32768
            Console.WriteLine(ushort.MaxValue); //65535
            Console.WriteLine(ushort.MinValue); //0
            Console.WriteLine(uint.MaxValue); // 4294967295
            Console.WriteLine(uint.MinValue); // 0
            Console.WriteLine(decimal.MaxValue); // 79228162514264337593543950335     // 12 byte'dır noktadan sonra 28-29 basamak duyarı vardır...  doublede 15 16 basamak iken decimalde 28 29 böylece hassaslık çok artar...
            Console.WriteLine(decimal.MinValue); // -79228162514264337593543950335  
            Console.WriteLine(char.MinValue); // nulldan başlar
            Console.WriteLine(char.MaxValue); // ?'e kadar gider çok fazla karakterleri tutabilir. tüm dillerin alfabelerindeki harfleri tutabilir. 2 bytedir 16 bit...

bool true veya false alır mantıksal veridir... a == b demek (a == b)   bize true veya false döndürecek demektir    return a == b diyebiliriz a == b 'de true veya false dönecek zaten...

internal bir erişim belirleyicisidir ve C# dilinde bir sınıfın veya bir üyenin, yalnızca bulunduğu proje içinde erişilebilir olmasını sağlar. internal olarak işaretlenen bir sınıf veya üye, aynı derleme içindeki diğer sınıflar tarafından erişilebilir, ancak başka bir derleme tarafından erişilemez.

    "Aynı derleme" ifadesi, bir C# projesinde bir araya getirilen tüm kodun toplandığı ve derlendiği yapıyı ifade eder. Bir C# projesi, bir veya birden fazla sınıf ve dosyanın bir araya getirildiği bir "derleme" üretir. Bu derleme genellikle bir .dll (dinamik bağlantı kitaplığı) veya .exe (yürütülebilir dosya) uzantısına sahiptir.

    Bir C# projesindeki tüm sınıflar, yapılar, enum'lar, metotlar ve diğer üyeler, projenin derlenmiş çıktısı içinde bir araya getirilir. Bu çıktıya "derleme" denir. Eğer tüm bu kodlar aynı proje içinde yer alıyorsa, bu kodlar aynı derleme içindedir.

    Eğer bir sınıf veya üye internal olarak işaretlenmişse, bu, bu sınıfın veya üyenin sadece aynı derleme içindeki diğer kodlar tarafından erişilebileceği anlamına gelir. Yani, internal olarak işaretlenen bir sınıf veya üyenin erişilebilir olması için, bu sınıf veya üyenin bulunduğu proje içinde olması gerekmektedir.

    Aynı derleme içinde olmak, bir C# projesinin sınıflarının, üyelerinin ve diğer yapılarının bir araya getirildiği ve derlendiği fiziksel sınırları ifade eder. Eğer farklı projeler arasında kod paylaşımı yapmak istiyorsanız, bu durumu public veya başka bir erişim belirleyici ile yönetmeniz gerekir.


// her kesirli sayı doubledir float vs yapmak istersek o zaman tip dönüşümü yapmak lazım (float) 5.6   veya 5.6f  olarak
double sayi1 = 5/4;  1.0 olur   5 int 4 int spnuç int 1 olur double olunca 1.0 olur....    (double) 5 / 4 olsa 5.0 / 4 olur  o zaman 1.25 çıkar direkt olarak...

bölümde falan kesirli sayılarda kayıplar olabilir bunun için decimal kullanılır... hassas hesaplar için decimal kullanırız. bunu e ticaret sitelerinde vs kullanabiliriz...
     tip dönüşümlerinde kayıplar vs olabilir kesirlerden kaynaklı kayıplar olabilir bunun için decimal kullanırız hassas hesaplarda...

karakterler '' içeriisnde stringler ise "" içerisinde belirtilmelidir. pythona böyle bir fark yoktur mesela...
'' içerisinde tek bir karakter belirtilebilir.
"" olursa karakter dizisi içerebilir.

\ demek benden sonra gelecek olan bilgisayarın program komutu değil demektir.
          ana \n alt satır \t ise bir tab boşluk demektir.

c# büyük harf küçük harf ayrımı yapar int sayi1,Sayi1; yapabiliriz... yani farklı olacaktir ikiside...

*******CASTİNG büyük alandaki veri küçük alana geçemez geçecek olursa kayıplar olur ancak casting ile kayıplarla beraber yapmak mümkün. küçük veriyi büyük veri tipine sorunsuz dönüştürebiliriz. 
  mesela floatı doubleye sorunsuz atabiliriz.  ama doubleyi dönüşüm yapmadan atamayız atarsakta kayıplar olur veri kaybı olur.
  long inti sorunsuz alır veri kaybı olmadan ama tam tersi zor.
  intin long'a atanması implicit(istemsiz) dönüşümdür bir hata vermez.     
  longun int olması ise explicit döünüşümdür dönüşümü belirtmek lazım downcasting yapmak gerekir. 
  longu int yapmak için derleyiciyi ikna etmemiz lazım....
  c#da java gibi önce derlenir sonra yorumlanır.
  explicit yaparsak manuel yapmalıyız  double sayi1 = 18.8;    int sayi2 = (int)sayi1; gibi...


            Console.WriteLine(Convert.ToString(3.43));
            Console.WriteLine(Convert.ToInt64(3.43));
            int sayi12 = Convert.ToInt32("12");
            long sayi13 = Convert.ToInt64("1221");

Convert.ToTip   ile biz içerisine attığımız değeri istenen değere çeviririz. ve bu yapı isteneni return eder... int'e atama yapacaksak Convert.ToInt32(); kullanmamız lazım 
Convert.ToInt32() bu bize değer return edecek ve kullanacağız.



################################################################################################################################################################################################################################################

dizilerde veri tipleri aynı olur;
Array bir sınıftır

            int[] array = { 1, 2, 3, 4, 5, }; // burada direkt atama yapabiliriz... 
            int[] array2 = new int[10]; // burada ise 10 tane int değer alacak yer ayırırız ve otomatik olarak hepsi sıfır olur sayılarda ilk atama otomatik sıfırdır string ve class'larda ise nulldır.

Arraylerde referancelerla çalışır yani 
        public static void degistir(int[] a)
        {

            a[0] = 11;


        }   // buraya bir array gelirse ilk değeri 11 olacak kalıcı şekilde...  bunun nedeni arrayler aslında referancedir.

int[][] ab = new int[10][];  // burada 10 tane int dizisi olacak diyoruz... ikinci [] atamaya gerek yok ama atarsak sabit olarak onlarda o sayı kadar değer taşıyan int arrayler olacak... 
yani ab 10 tane int array taşıyan bir array'dir.  ab.length dersek 10 alırız...
int[][] ab = new int[10][6]; dersek eğer 10 tane 6 tane int değer taşıyan aarray vardır 6,6,6,6,6,6,6,6,6,6,6 olacak şekilde...

            int[][] ab = new int[10][];
            for (int i = 0; i < ab.Length; i++)
            {
                ab[i] = new int[9];
            }
            // bu şekilde ise 10 kere çalışır for ve her arraye bellekte yer ayırır her arrya 9 tane değer alabilir hale gelir.  bu yapı ile kapasiteleri farklı arraylerden oluşan matrisler kurabiliriz.

ab[1][1] = 100; diyerek direkt atama yapabiliriz...

mesela 10 kapasiteli bir array var 11.ciye atama yapmak istersek hata alırız.

string[] ise string değer taşıyan bir arraydir bu bir referancedir.

array[index]  ile istenen elemana ulaşırız. indexin arrayin boyutuna göre olması gerekir bu önemlidir.  yoksa hata verebilir.

int[,] demekte 2 boyutlu bir dizidir.
int[,,] ise 3 boyutlu demektir...

..........................................................................................

            int[][] aa = new int[10][];
            for (int i = 0; i < aa.Length; i++) {
                aa[i] = new int[9];
            }

            for (int i = 0;i < aa.Length; i++) { 
            for (int j = 0; j < aa[i].Length; j++)
                {
                    Console.Write(aa[i][j]);  // aa[i,j] de olabilir fark etmez... 

                }
                Console.WriteLine();

            }

int[,] aa = new int[2,3] yapabiliriz  3,3 eleman taşıyan bir matris olur böylece.
veya aa = {{1,1,1},{1,1,1}} yapabiliriz.

..................................................................................................

% kalan bulma... a += b ;  a'ya b eklenir -= çıkarır *= çarpar.    ++ tek arrttırma -- tek çıkarma     solda veya sağda olması önemli solda olursa önce değeri değişir sonra işleme dahil olur sağda olursa önce işleme dahil olur sonra değeri değişir.

(float) a / b    ile (float) a / (float) b arasında fark olabilir dikkat etmek lazım...

        C# dilinde, operatörler matematiksel işlemlerden mantıksal kontrol işlemlerine kadar birçok farklı kategoride bulunmaktadır. Ayrıca, operatörlerin öncelik sıralaması da önemlidir, çünkü bu sıralama ifadeyi değerlendirirken kullanılır.

        İşte C# dilinde kullanılan bazı temel operatörler ve öncelik sıralaması:

        Matematik Operatörleri:

        + (toplama)
        - (çıkarma)
        * (çarpma)
        / (bölme)
        % (mod alma)
        Artırma ve Azaltma Operatörleri:

        ++ (artırma)
        -- (azaltma)
        Atama Operatörleri:

        = (atama)
        +=, -=, *=, /=, %= (toplama, çıkarma, çarpma, bölme, mod ile atama)
        Mantıksal Operatörler:
        a /= 10; demek a'yı 10 böl çıkan değeri a'ya ata demek %= içinde aynısı geçerli diğerleri içinde geçerliler...


        && (ve - AND)
        || (veya - OR)
        ! (değil - NOT)
        () parantezlerin içinin önceliği var... buna dikkat etmek lazım.
        (a > b) && (b  < c)  önce sağ sol parantez sonuç return eder sonra && çalışır...
        Karşılaştırma Operatörleri:  True veta False ile çalışırlar.

        == (eşit)
        != (eşit değil)
        < (küçük)
        > (büyük)
        <= (küçük veya eşit)
        >= (büyük veya eşit)
        Bitwise Operatörler:

        & (ve)
        | (veya)
        ^ (XOR - özel veya)
        ~ (bütünleyen)
        << (sol kaydırma)
        >> (sağ kaydırma)
        Koşullu Operatör:

        ? : (koşullu ifade)   (koşul <= mesela) ? True halde return edilecek: False halde return edilecek;


            int a = 0, b = 1;
            string sonuc = (a == b) ? "esit" : "degil"; // True ise soldakini atar False ise sağdakini atar...
            Console.WriteLine(sonuc); // degil...

        Tip Dönüşüm Operatörleri:

        (tip) (dönüşüm operatörü)
        as (as operatörü)
        is (is operatörü)
        Operatörlerin öncelik sıralaması, bir ifadenin hangi operatörün önce değerlendirileceğini belirler. Öncelik sıralaması, matematiksel operatörlerin öncelikli olması, ardından karşılaştırma, mantıksal ve diğer operatörleri içerir. Ancak, ifadeyi açıklığa kavuşturmak için parantezler kullanılabilir. Örneğin, parantez içindeki ifadeler her zaman önceliklidir.


bir if else if else bloğunda sadece bir tanesi çalışır...  sırası ile okur ilk sağlanan koşula girer hiçbirisi çalışmazsa else çalışır. else olmasada olur...
int a = -10;
if(a > 0){

+

}else if(a == 0){

0

}else{

-

}


################################################################################################################################################################################################################################################

    internal class Program
    {
        static void Main(string[] args)
        {
            int sayi1 = 0;
            atamayap(ref sayi1);
            Console.WriteLine(sayi1);





        }

        public static void atamayap(ref int a)
        {

            a = Convert.ToInt32(Console.ReadLine());
        
        }


    } // sayıya atama yapan bir program...


static ile class'a bağlarız bir değeri veya metotu... static metot içerisinde static olmayan metot nesnesiz şekilde çalışamaz...
void geriye değer döndermez. bir metot kullanacaksak return yapacaksa ne türden yapacak belirlememiz lazım.

static int kucukharfsayisi(string s){

int aa = 0;

foreach(var i in s){    // foreach ile karakter karakter string üzerinde dönebiliriz...

if(char.IsLower(i)) aa++; 

}
return aa;
}



......................................................................................................................................................................................

        static void Main(string[] args)
        {

            yazdir(a: "TT",c:"YY",b:"GHGH");   // bu şekilde bir metota gönderilecek değerlerin hangisi tarafından karşılanmasını istediğimizi belirtebiliriz...

        }




        public static void yazdir(string a , string b, string c)
        {

            Console.WriteLine(a + " " + b + " " + c);

        }

        public static void yazdir(string a , string b)  // burada ise aynı tipte aynı isimde farklı parametreli metotlar ile metot overloading yapaarız ve program verilen değişkenlere göre kendisini en az yoran ve en uygun olanı çağırır...
        {

            Console.WriteLine(a + " " + b);

        }

......................................................................................................................................................................................

C# programlama dilinde metotlar, kodunuzu modülerleştirmenin ve tekrar kullanılabilirliği artırmanın önemli bir yolu olarak karşımıza çıkar. Metotlar, belirli bir görevi yerine getiren ve genellikle bir isimle çağrılabilen kod bloklarıdır. Bu yazıda, C# dilinde metotların nasıl tanımlandığı, kullanıldığı ve özelleştirildiği konularına detaylı bir şekilde odaklanacağız.

Metot Tanımı:
C# programlama dilinde bir metot, aşağıdaki gibi bir yapıda tanımlanır:

erişim_belirleyici dönüş_türü MetotAdı(parametre_listesi)
{
    // Metotun içeriği
}
Erişim Belirleyici (Access Modifier): Metodun ne kadar görünür olduğunu belirler. Örneğin, public, private, protected, internal gibi.

Dönüş Türü (Return Type): Metodun geri döndüğü değerin türünü belirtir. Eğer metot bir değer döndürmüyorsa void kullanılır.

Metot Adı: Metodu çağırırken kullanılacak ismi belirtir.

Parametre Listesi: Metotun içinde kullanılacak değerleri almak için kullanılır. Parametreler opsiyonel olabilir.

Örnek Bir Metot Tanımı:

public int Topla(int sayi1, int sayi2)
{
    int toplam = sayi1 + sayi2;
    return toplam;
}
Bu metot, iki tane int tipinde parametre alır (sayi1 ve sayi2), bu sayıları toplar ve sonucu int türünde geri döner.

Metot Kullanımı:
Bir metodu kullanmak için, öncelikle sınıfın bir örneğini oluşturmalı veya metot static olarak tanımlanmışsa sınıf adı üzerinden çağrılmalıdır.


// Metot çağrısı
int sonuc = Topla(5, 7);
Console.WriteLine("Toplam: " + sonuc);
Parametre Türleri ve Seçenekler:
Metotlara parametreler ile veri iletimi yapılır. Parametreler, değer türleri (int, float, char, vb.) veya referans türleri (class, array, interface, vb.) olabilir. Ayrıca, parametreler opsiyonel olabilir, varsayılan değerler atanabilir.


public void Yazdir(string metin, int tekrarSayisi = 1)
{
    for (int i = 0; i < tekrarSayisi; i++)
    {
        Console.WriteLine(metin);
    }
}
Bu metot, bir metni belirli bir sayıda ekrana yazdırmak için kullanılır. tekrarSayisi parametresi varsayılan olarak 1'e ayarlanmıştır, ancak metot çağrısı sırasında farklı bir değer atanabilir.

Overloading (Aşırı Yükleme):
Bir sınıf içinde aynı isme sahip fakat farklı parametre listelerine sahip birden fazla metot tanımlamak mümkündür. Bu duruma "overloading" denir.


public int Topla(int sayi1, int sayi2)
{
    return sayi1 + sayi2;
}

public double Topla(double sayi1, double sayi2)
{
    return sayi1 + sayi2;
}
Bu örnekte, Topla isimli iki farklı metot tanımlanmıştır. İlk metot int türünde, ikinci metot ise double türünde çalışır.




ref ve out Parametreleri:
ref ve out parametreleri, metotların değerleri dışarıdan değiştirmesine izin verir.


public void Arttir(ref int sayi)
{
    sayi++;
}

public void Bol(ref int bolen, int bolunen, out int bolum)
{
    bolum = bolen / bolunen;
}



params Parametresi:
params anahtar kelimesi, değişken sayıda parametre alabilen bir metot tanımlamak için kullanılır.


public int Topla(params int[] sayilar)
{
    int toplam = 0;
    foreach (int sayi in sayilar)
    {
        toplam += sayi;
    }
    return toplam;
}



static Metotlar:
Bir metot static olarak tanımlandığında, sınıf adı üzerinden çağrılabilir ve sınıfın bir örneği oluşturulmasına gerek yoktur.


public class Matematik
{
    public static int KareAl(int sayi)
    {
        return sayi * sayi;
    }
}

// Kullanım
int sonuc = Matematik.KareAl(4);
Bu örnekte, KareAl metodu static olarak tanımlanmış ve Matematik sınıfı üzerinden çağrılmıştır.

Lambda İfadeleri ile Kısa Metotlar:
C# 3.0 ve sonrasında lambda ifadeleri kullanarak kısa metotlar tanımlamak mümkündür.


Func<int, int, int> topla = (x, y) => x + y;
Console.WriteLine(topla(3, 4));
Bu örnekte, topla adında bir lambda ifadesi kullanılarak kısa bir toplama metodu tanımlanmıştır.




################################################################################################################################################################################################################################################

        namespace appConsole
        {


            public class MyName
            {
                




            }


            internal class Program
            {
                static void Main(string[] args)
                {
                    int sayi1 = 0;
                    atamayap(ref sayi1);
                    Console.WriteLine(sayi1);





                }

                public static void atamayap(ref int a)
                {

                    a = Convert.ToInt32(Console.ReadLine());
                
                }


            }
        }




################################################################################################################################################################################################################################################
    ref Anahtar Kelimesi:
    ref anahtar kelimesi, bir metoda argüman olarak geçirilen bir değişkenin, metot içinde değiştirilebileceğini belirtir. Bu, metot içinde değişen değerin, çağrıldığı yerdeki orijinal değişkeni etkileyebileceği anlamına gelir.

    
    public void Arttir(ref int sayi)
    {
        sayi++;
    }

    // Kullanım
    int sayi = 5;
    Arttir(ref sayi);
    Console.WriteLine(sayi); // 6
    Bu örnekte, Arttir metodu bir ref parametre alır ve bu parametre üzerinde yapılan değişiklikler, orijinal değişkeni etkiler.

    out Anahtar Kelimesi:
    out anahtar kelimesi, bir metot tarafından bir değer döndürülmesini sağlar. Ancak, out ile belirtilen bir parametre, metot çağrısı yapmadan önce başlatılmasına rağmen, metot içinde değer atanması gerekmez. out parametreleri, metottan birden fazla değeri döndürmek amacıyla da kullanılabilir.

  
    public void Bol(int bolen, int bolunen, out int bolum)
    {
        bolum = bolen / bolunen;
    }

    // Kullanım
    int bolum;
    Bol(8, 2, out bolum);
    Console.WriteLine(bolum); // 4
    Bu örnekte, Bol metodu out parametre kullanarak bir değeri döndürüyor. out parametreler, metottan değeri döndürmek için kullanıldıklarında, metotun içinde değer atanması zorunlu değildir.

    ref ve out Kullanımına İlişkin Noktalar:
    ref ve out parametreleri, metot çağrısı yapmadan önce başlatılmalıdır. out parametreleri özellikle metot içinde değer atanmasa bile başlatılmalıdır.

    ref ve out kullanımı, genellikle bir metotun birden fazla değeri değiştirmesi veya döndürmesi gerektiğinde tercih edilir.

    ref kullanımında, değer atanmış bir değişkenin referansı geçilir ve metot içinde değiştirilen değer, orijinal değişkeni etkiler.

    out kullanımında, metotun değeri döndürmesi gerektiğinde veya metotun içinde değer atanması gerektiğinde tercih edilir.

    Hem ref hem de out parametreleri, metotun başlığında belirtilen türde olmalıdır.

    Bu anahtar kelimeler, programlamada değerleri metotlar arasında aktarırken ve metotlardan değer alırken kullanılır ve C# dilinde esnek bir parametre geçirme ve döndürme mekanizması sağlar.
################################################################################################################################################################################################################################################

constructor yapıcı metotdur. çok önemlidir... constructor overloading yapabiliriz. istediğimiz parametreler ile çalışır hale getirebiliriz...

public olursa her yerden erişebilir... public'te erişim kısıtı yoktur.
protected ait olduğu sınıftan ve o sınıftan türetilen yerlerden erişilebilir.




            C# programlama dilinde, erişim belirleyicileri (access modifiers), bir sınıfın, üyenin (örneğin, bir alan, bir metot veya bir özellik) veya bir derlemenin başka kod bloklarından ne kadar görünür ve erişilebilir olduğunu belirten özel anahtar kelimelerdir. Erişim belirleyicileri, sınıfın, üyenin veya derlemenin erişilebilirliğini kontrol etmek için kullanılır ve bu sayede programın modülerliğini ve güvenliğini sağlar.
            C# dilinde beş temel erişim belirleyici bulunmaktadır:

            public:

            Herkes tarafından erişilebilir.
            Örneğin: public class Example { }


            private:

            Sadece tanımlandığı sınıf içerisinden erişilebilir.
            Örneğin: private int count;


            protected:

            Tanımlandığı sınıf ve bu sınıftan türetilmiş sınıflar tarafından erişilebilir. yani kalıtım almış sınıflar ve kendi sınıfı erişebilir bu metotlara ve değişkenlere... 
            Örneğin: protected void DoSomething() { }


            internal:

            Bulunduğu derleme içerisindeki herhangi bir sınıf tarafından erişilebilir.
            Örneğin: internal class InternalClass { }


            protected internal:
             
            Tanımlandığı sınıf, türetilmiş sınıflar ve bulunduğu derleme içerisindeki herhangi bir sınıf tarafından erişilebilir.
            Örneğin: protected internal string Name { get; set; }
               mesela bir class içinde protected bir değişken var kendi içeriisnde ve kalıtım alanların içerisinde çalışır bu protected metotlar ve değişkenler. başka bir class'ta nesne oluşturup'ta erişemeyiz. 
               private olursa eğer super kullanmadan erişemeyiz kalıtım devreye girerse. 

                                class class1
                                {

                                    protected string name = "emre";

                                }

                                class Program
                                {

                                    static void Main(string[] args)
                                    {

                                        Console.WriteLine();
                                        Console.WriteLine(aa.name); // hata verir. erişemeyiz...

                                    }

                                }


            Bu erişim belirleyicileri, sınıfların, üyelerin ve derlemelerin ne kadar görünür olduğunu kontrol etmek için kullanılır. Bu, bir kod tabanının iyi bir şekilde organize edilmesini, sınıfların ve üyelerin sadece gerekli yerlerden erişilebilir olmasını ve kodun güvenliğini sağlamak açısından önemlidir.

################################################################################################################################################################################################################################################

namespace appConsole
{
    class TTT
    {

        private int skor;
        public int Skor
        {
            
            get { return skor; } // get bloğu skor okunmak istediği zaman çalışır.
            set {  skor = value; } // set ise atama yapılmak istendiği zaman çalışır.

        }

    }
    class Program
    {

        static void Main(string[] args)
        {

            TTT aaa = new TTT();
            aaa.Skor = 1; // set çalışır. private değişkene atama yapar.
            Console.WriteLine(aaa.Skor); // get çalışır burada.  private skorun değerini döndürür...

        }


    }
}


.........................................................................................................................

    class Kisi
    {
        private int yas;
        private string dogumyeri;
        private string meslek;

        public int Yas { 

        get { return yas; }
            set { 
            

                if (value < 0)
                {

                    yas = 0;
                }
                else
                {
                    yas = value;
                }
            
            }
        
        }

        public string Dogumyeri
        {

             get { return dogumyeri; }
            set { dogumyeri = value;}

        }

        public string Meslek
        {

            get { return meslek; }
            set { meslek = value; }
        
        }



        public Kisi(int yas, string dogumyeri, string meslek)
        {
            this.yas = yas;
            this.dogumyeri = dogumyeri;
            this.meslek = meslek;
        }



    }


################################################################################################################################################################################################################################################

// properity olayı...


namespace appConsole
{
    class Kisi
    {
        public int yas {  get; set; }
        public string dogumyeri { get; set; } 
        public string meslek {  get; set; }

        public Kisi(int yas, string dogumyeri, string meslek)
        {
            this.yas = yas;
            this.dogumyeri = dogumyeri;
            this.meslek = meslek;
        }
    }


    class Program
    {

        static void Main(string[] args)
        {
            Kisi kisi1 = new Kisi(1,"b",meslek:"c");
            kisi1.yas++; kisi1.dogumyeri = "ist"; kisi1.meslek = "otomasyon";
            Console.WriteLine(kisi1.meslek);
            Console.WriteLine(kisi1.dogumyeri+" "+kisi1.yas);

        }


    }
}

################################################################################################################################################################################################################################################

            C# programlama dilinde, bellek yönetimi iki temel alanı içerir: stack (yığın) ve heap (örtü). Bu iki alan, programın çalışma zamanında verileri depolamak için kullanılır, ancak farklı özelliklere sahiptir.

            Stack (Yığın):
            Stack, programın çalışma zamanında yönetilen bir bellek alanıdır. Bu alanda veriler, sıralı bir şekilde depolanır ve bu verilere hızlı erişim sağlanır. Stack'te veri depolamak için kullanılan bellek alanı, genellikle yönetilen (managed) veri tipleri ve değer tipleri içindir. İşte stack'te tutulan bazı veri tipleri:

            Değer Tipleri:

            int, char, float, double, bool gibi temel veri tipleri.
            struct tarafından tanımlanan yapılar.
            Yerel Değişkenler:

            Metot içerisinde tanımlanan değişkenler.
            Metot Çağrıları:

            Metot çağrıları ve metot çağrılarına ait yerel değişkenler.
            Stack'te depolanan veriler, programın akışı içinde meydana gelen işlemlerle birlikte otomatik olarak tahsis edilir ve serbest bırakılır. Stack, veri tipleri için hızlı erişim sağlar, ancak boyutları genellikle sınırlıdır ve yaşam süreleri kısa olduğu için otomatik olarak serbest bırakılır.

            Heap (Örtü):
            Heap, programın çalışma zamanında yönetilen bir diğer bellek alanıdır. Heap'te depolanan veriler, daha uzun ömürlüdür ve belirli bir yaşam süresine sahiptir. Genellikle heap, dinamik olarak tahsis edilen ve serbest bırakılan bellek alanıdır. Heap'te tutulan bazı veri tipleri şunlardır:

            Referans Tipleri:

            class tarafından tanımlanan nesneler.
            string gibi dinamik bellek tahsisi gerektiren türler.
            Dinamik Bellek Tahsisi:

            new anahtar kelimesi ile oluşturulan nesneler.
            Heap'te depolanan veriler, programcı tarafından elle serbest bırakılmalıdır (örneğin, Dispose veya Close gibi yöntemler kullanılarak), aksi takdirde bu bellek sızıntılarına neden olabilir.

            İki bellek alanı arasındaki temel farklar şunlardır:

            Hız ve Erişim Süresi: Stack, hızlı bir erişim sağlar çünkü bellek alanı sıralıdır. Heap ise daha fazla işlem gerektirir ve dolayısıyla daha yavaş erişim sağlar.

            Ömür ve Kapsam: Stack'te depolanan veriler genellikle kısa ömürlüdür ve otomatik olarak serbest bırakılır. Heap'te depolanan veriler daha uzun ömürlüdür ve programcı tarafından serbest bırakılmalıdır.


// struct tanımlama ve kullanımı

struct node // struct demek yapı ismi node ise kullanılacak isim.   class'lara benzerler... classların nesneleri heap alanında tutulur referancelidir.  structlarınki ise stack alanında tutulur ilkel veriler gibi.
{ // metottda tanımlayabiliriz...

    public int deger;
    public String name;
    public void yazdir(){

Console.WriteLine("AAAAA"); // WriteLine alt satıra geçirir Write alt satıra geçirmez...

    }
}

public static void Main(String[] args){
            node node1 = new node();

            node1.name = "emre";
            node1.deger = 15;
}



################################################################################################################################################################################################################################################





################################################################################################################################################################################################################################################

// Main sadece bir tane olur ve programın çalışması için gerekli olan o metottur ana metottur...
// String ile string arasında bir fark yoktur... ikiside aynıdır referans bilmem ne vs vs... 

            bool dogrumu = false;

            while (dogrumu)
            {





            }
            if (dogrumu)
            {

                    
            }else if (dogrumu) { 
            
            
            }else { Console.WriteLine("FORD ");
            }

// değişkenler verileri tutan yapılardır. her sınıf bir blok içerisindedir.
// bir class içerisinde tanımlananlar aslında o class'a özgüdür...
// c#da değişkenler rakamla vs başlayamaz... metinsel ifadeler falan mantıklıdır. ve dikkat etmemiz gerekn bir nokta  class isimleri büyükle başlar fonkisyonlar vve değişkenler ise küçükle başlar yeni kelimede o kelimenin baş harfi büyür.
class: EmreAraba   metot: gitAraba() değişken: arabaMotor = 12; gibi...
// değişken bir class içerisinde kullanıldı ise tüm class ona erişebilir.

// stack ve heap dene iki bölge var bellekte ana bölgede ramle bellek arasında fark var stack ve heap olarak. değer tipliler stackte tutulur referance tipliler ise heap alanında tutulur sınıflara ait nesneler heapte tutulur.
// string dışındakiler stack'te tutulur. string ise heapte.

// sabit ve değişken farkı nedir... const mesela değişmez ve değeri tanımlanırken atanmalı.
          const int deger2 = 11;  gibi.
          int deger1 = 11; 
          deger1 = 12; // sabit değildir değişkendir const değilse... porgramda zamanla değişebilir.

// c# dilinde bir veriye double int float vs değer verilmediyse eğer o zaman 0 olur string ise null olur vs vs mesela class ürettik emre diye emre emre1; dedik emre1 nulldır. default olarak 0 veya null ataması yapılır...
//             int[] matris1 = new int[100]; dizi oluşturma böyle yapılır.

// string bir referans türüdür, yani değer tipleri gibi doğrudan değeri saklamaz. Bunun yerine bellekte bir referans saklar ve bu referans, metni içeren bellek bölgesini gösterir.
     

        public static int toplama(int a)
        {
            return a;
        }
        public static int toplama(int a,int b)
        {
            
            return a + b; 
        }
        // ikisinide aynı anda kullanabiliriz gönderilen verilere göre hangi metotun çalışacağını ise c# belirler buna method overloading denir...
        mesela toplama(5) dersem en üstteki çalışır toplama(10,8) dersen alttaki çalışır...



class isimler
{


    private int deger;
    private String name;
    private isimler isimlersonraki = null;  // burada mesela her nesne oluştuğunda otomatik olarak null olacak...

    
    public isimler(int deger, string name)
    {   
        this.deger = deger;
        this.name = name;
    }
         public isimler() // default constructor'dur bu mesela...   iki tane constructor var bunada constructor overloading denir... parametrelere göre hangisi çlaışacak c# belirler bunu
    {   
        
    }
     

}


// c# dilinde veri tipleri ilkel değildir. hepsi bir nesnedir.
// her sınıf soyut bir veri yapısıdır.
// /**/  buda uzun veri sistemi.
// common type sistem = ortak veri modeli.
// import yerine using kullanırız...

/*
            Console.Write("Kullanici adi giriniz: ");
            string isim = Console.ReadLine();
            Console.WriteLine(isim);

*/ consoldan veri alma böyle yapılır string için... 

// c# dilinde global değişken yoktur her veri bir class'a özgü olmalıdır. her metot her değişken bir class'a bağlı olmalıdır.
// değişkenler rakamlarla başlamaz arada boşluk olamaz para simgeleri olabilir ! & vs gibi karakterler olmaz.
// değişkenlerde iki tip vardır değer ve referance tipleri.  stack ve heap bölgeleri vardır bellekte.   ramda stack ve heap vardır.  referance tipleri heapte tutulur.   classla başlayan yapılar heapte tutulur string dışı değerler stackte tutulut değer tiplidir çünkü...
// charda aslında sayısal olarak tutar ama biz onu karakterlere çeviririz dil ile.

            Console.Write("");  // yazar ve alt satıra geçirmez...
            Console.WriteLine(""); // yazar ve alt satıra geçirir otomatik olarak \n eklenir...

            Console.Write( 14 + " " +  4); demek aslında append demek...  tüm değerleri string yapar eğer +'nın içerisinde string varsa ve sırası ile hepsini append eder...

string yazi1 = "emre" + 15; hata vermez... 15 string'e çevrilir ve + ile append edilir..
string yazi2 = 15; hata verir...   

// encapsulation demek nesnenin vcerilerine nesne.  şeklinde ulaşmayı private ile kısıtlamak demektir...     nesnenin verilerine nesnenin metotları ile ulaşmak kontrollü şekilde... getter setter kullanırız genel olarak. 



ctrl + class'ın üstüne tık ile içerisine gidebilir bilgileri görebiliriz...




..............................................................................................................................................................................................................................................................................................................................................................

        C# dilinde iki stringin aynı referansı taşıyıp taşımadığını kontrol etmek için == operatörü değer karşılaştırması yapar, yani iki string'in içeriğini kontrol eder, referans karşılaştırması yapmaz. Yani == operatörü, stringlerin içeriğini kontrol eder.

        Örneğin:

        string isim1 = "emre";
        string isim2 = "emre";

        if (isim1 == isim2)
        {
            Console.WriteLine("İsimler eşittir.");
        }
        else
        {
            Console.WriteLine("İsimler eşit değildir.");
        }
        Yukarıdaki örnekte, isim1 ve isim2 string'leri aynı değeri taşıdığı için == operatörü true dönecektir.

        Ancak, C# dilinde referans karşılaştırması yapmak istiyorsanız object.ReferenceEquals metodunu kullanabilirsiniz:


        if (object.ReferenceEquals(isim1, isim2))
        {
            Console.WriteLine("İsimler aynı referansı taşıyor.");
        }
        else
        {
            Console.WriteLine("İsimler aynı referansı taşımıyor.");
        }
        Bu durumda, object.ReferenceEquals metodu, iki string'in aynı referansı taşıyıp taşımadığını kontrol eder. Ancak, genellikle string karşılaştırmalarında == operatörü daha yaygın olarak kullanılır.

..............................................................................................................................................................................................................................................................................................................................................................

string isim = "emre";
string isim2 = isim;  // buda emre olur ama referance yüüzden değil değer ataması yapılır burada. javadaki gibi değil..

        Araba araba1 = new Araba { Model = "Toyota" };
        Araba araba2 = araba1;

        araba1.Model = "Ford";

        Console.WriteLine(araba2.Model);  // Bu, "Ford" yazdırır çünkü class'lardan oluşan nesneler referancelerle çalışırlar...

..............................................................................................................................................................................................................................................................................................................................................................

    internal class Program
    {
        static void Main(string[] args)
        {

            class1 cs1 = new class1("aaa", "bbb", 111);

            degistir(cs1);
            Console.WriteLine(cs1.age); // bir yazdırdı...



        }

        public static void degistir(class1 b)
        {
            b.age = 1;
          
        }

    }

class'lar kendi oluşturduklarımız vs onlardan oluşan nesneler referanceleri ile çalışırlar... bu yüzden void metotta değişim oldu gönderdiğimiz nesnenin değeri kalıcı olarak değişti... bunun sebebi pointer mantığıdır. nesneler heap ve stack olacak şekilde referanslı veya referancesiz olarak saklanırlar. bizim oluşturduklarımız ile oluşanlarda referance mantığı işler...
classlar(kendimizin) ve arraylar referance mantığı ile çalışır diğerleri çalışsın istersek o zaman ref yapısını kullanırız...


..............................................................................................................................................................................................................................................................................................................................................................

break ve continue bağlı oldukları döngü için çalışırlar sadece bir döngü için çalışırlar...

for while do while hepsi için aynı neredeyse...

..............................................................................................................................................................................................................................................................................................................................................................

        static void Main(string[] args)
        {

            string[] isimler = new string[3];
            isimler[0] = "aaaa";
            isimler[1] = "bbbb";
            isimler[2] = "cccc";

            foreach (string i in isimler)   // önce tipi belirtiriz. sonra i deriz iterasyon yapacak yapıya. ve dönülecek yapı.
            {
                Console.WriteLine(i);
            }
        }

        // string yerine biz var yazabilirdik bir fark olmazdı ikiside çalışır...  
        // var = bu anahtar kelime ile değişken oluşturursak ve atamasını yaparsak var tarafından onun tipi belirlenir. pythondaki yapı ile aynı neredeyse...

C# programlama dilinde "var" bir değişkenin türünü belirlemeden önce, derleme zamanında türünün belirlenmesine izin veren bir anahtar kelimedir. "var" anahtar kelimesini kullanarak bir değişken tanımladığınızda, derleyici, değişkenin türünü sağlanan başlatma değerinden çıkarır.

Örneğin:

var sayi = 42; // sayi değişkeni int türünde bir değişkendir.
var metin = "Merhaba, Dünya!"; // metin değişkeni string türünde bir değişkendir.
Bu durumda, derleyici, sayi değişkenini int ve metin değişkenini string olarak anlar. Ancak, "var" kullanılarak tanımlanan değişkenlerin başlangıç değeri ile türü belli olmalıdır, çünkü derleyici, başlangıç değeri üzerinden türü çıkarır. Ayrıca, bir kez atanmış bir değişkenin türü değiştirilemez.
..............................................................................................................................................................................................................................................................................................................................................................





