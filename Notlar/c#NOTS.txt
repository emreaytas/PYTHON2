Install-Package System.Data.SQLite   console manager kısmına yazarak SQLite kullanabiliriz... masaüstü uygulamaları için harika entity framework'te kullanabiliriz orm olarak destekler...
        SQLite NuGet Paketini Yükleme:
        Projenize SQLite ile çalışmak için System.Data.SQLite NuGet paketini ekleyin. Visual Studio kullanıyorsanız, "NuGet Package Manager Console" penceresini açıp aşağıdaki komutu kullanarak paketi yükleyebilirsiniz:

        bash
        Copy code
        Install-Package System.Data.SQLite
******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Form1 ff = new Form1();
         ff.ShowDialog();


          Console.WriteLine("merhababaaaaaa");
c# dilinde showDialog ile form açılıyor ama ben açıldıktan sonra alltaki yazıyıda yazdırsın istiyorum yani programın okuması orada takılı kalıyor ne yapmam lazım
ChatGPT
ShowDialog metodu, ilgili form kapatılana kadar kontrolü ele geçirir. Bu nedenle, ShowDialog metodundan sonra gelen kodlar, form kapandığında çalışır. Eğer formun üzerindeki işlemler tamamlandıktan sonra bir şeyler yapmak istiyorsanız, Form1 sınıfınızda bir olay (event) tanımlayarak bu olayı uygun bir durumda tetikleyebilirsiniz. Örneğin, formunuz kapatıldığında bir olay tetikleyerek ardından gelen kodları çalıştırabilirsiniz.

c#'da from uygulaması showDialog ile açıldıktan sonra o panel açık olduğu sürece alt satıra geçmez programın okuma imleci orada takılı kalır taki kapanana kadar...


************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
C# dilini daha ileri seviyede öğrenmek için aşağıdaki konulara odaklanabilirsiniz. Bu konular, C# programlamadaki ileri seviye konseptlere ve geliştirme tekniklerine odaklanmaktadır:

Nesne Yönelimli Programlama (OOP):
    C#'da nesne yönelimli programlama temel bir konsepttir. Sınıflar, nesneler, miras, soyut sınıflar, arayüzler, çoklu kalıtım gibi OOP konularını öğrenmek önemlidir.

İleri Seviye Dil Özellikleri:
    C#'daki en yeni dil özelliklerini anlamak ve kullanmak için çalışın. Örneğin, C# 8 ve sonraki sürümlerdeki özellikler arasında nullable reference types, pattern matching, switch expressions gibi konular bulunmaktadır.

LINQ (Language Integrated Query):
    LINQ, veri sorgulama ve manipülasyonu için kullanılan güçlü bir dil entegre sorgu aracıdır. LINQ kullanarak veri tabanlarına, koleksiyonlara ve diğer veri kaynaklarına sorgular yazmayı öğrenmek önemlidir.
Asenkron ve Paralel Programlama:
    Modern uygulamalar genellikle asenkron ve paralel programlama tekniklerini kullanır. async ve await anahtar kelimelerini kullanarak asenkron programlamayı, paralel programlamayı da inceleyerek çoklu iş parçacığı (multithreading) konularını anlamak önemlidir.

Exception Handling (İstisna Yönetimi):
    Hata işleme konusunu daha iyi anlamak için try, catch, finally bloklarını kullanma becerisi geliştirmek önemlidir.
Veri Tabanı Programlaması:
    Entity Framework veya Dapper gibi C# ile entegre veri tabanı erişim araçlarını öğrenmek ve kullanmak.
    
ASP.NET MVC veya ASP.NET Core:
    Web uygulamaları geliştirmek için ASP.NET MVC veya ASP.NET Core framework'ünü öğrenmek. MVC tasarım deseni, routing, middleware kavramlarına hakim olmak önemlidir.

Unit Testing (Birim Testleri):
    NUnit, xUnit veya MSTest gibi birim testi çerçeveleri kullanarak uygulamalarınızı test etmeyi öğrenmek. Test yazma, test odaklı geliştirme ve test otomasyonu konularına hakim olmak önemlidir.
Dependency Injection ve IoC (Inversion of Control):
    Uygulama bağımlılıklarını yönetmek için Dependency Injection (Bağımlılık Enjeksiyonu) ve IoC konularını anlamak ve uygulamak.

Git ve Source Control Sistemleri:

Git gibi versiyon kontrol sistemlerini kullanarak kodunuzu yönetmeyi öğrenmek.
Bu konuları öğrenmek ve uygulamak, C# dilindeki yeteneklerinizi daha da geliştirmenize yardımcı olacaktır. Ayrıca, projeler üzerinde çalışmak ve gerçek dünya uygulamaları geliştirmek de öğrenme sürecinizi hızlandıracaktır.

......................................................................................................................................................................................................................................................................................................................................................................................................

C# programlama dilinde, bellek yönetimi iki temel alanı içerir: stack (yığın) ve heap (örtü). Bu iki alan, programın çalışma zamanında verileri depolamak için kullanılır, ancak farklı özelliklere sahiptir.

Stack (Yığın):
Stack, programın çalışma zamanında yönetilen bir bellek alanıdır. Bu alanda veriler, sıralı bir şekilde depolanır ve bu verilere hızlı erişim sağlanır. Stack'te veri depolamak için kullanılan bellek alanı, genellikle yönetilen (managed) veri tipleri ve değer tipleri içindir. İşte stack'te tutulan bazı veri tipleri:

Değer Tipleri:

int, char, float, double, bool gibi temel veri tipleri.
struct tarafından tanımlanan yapılar.
Yerel Değişkenler:

Metot içerisinde tanımlanan değişkenler.
Metot Çağrıları:

Metot çağrıları ve metot çağrılarına ait yerel değişkenler.
Stack'te depolanan veriler, programın akışı içinde meydana gelen işlemlerle birlikte otomatik olarak tahsis edilir ve serbest bırakılır. Stack, veri tipleri için hızlı erişim sağlar, ancak boyutları genellikle sınırlıdır ve yaşam süreleri kısa olduğu için otomatik olarak serbest bırakılır.

Heap (Örtü):
Heap, programın çalışma zamanında yönetilen bir diğer bellek alanıdır. Heap'te depolanan veriler, daha uzun ömürlüdür ve belirli bir yaşam süresine sahiptir. Genellikle heap, dinamik olarak tahsis edilen ve serbest bırakılan bellek alanıdır. Heap'te tutulan bazı veri tipleri şunlardır:

Referans Tipleri:

class tarafından tanımlanan nesneler.
string gibi dinamik bellek tahsisi gerektiren türler.
Dinamik Bellek Tahsisi:

new anahtar kelimesi ile oluşturulan nesneler.
Heap'te depolanan veriler, programcı tarafından elle serbest bırakılmalıdır (örneğin, Dispose veya Close gibi yöntemler kullanılarak), aksi takdirde bu bellek sızıntılarına neden olabilir.

İki bellek alanı arasındaki temel farklar şunlardır:

Hız ve Erişim Süresi: Stack, hızlı bir erişim sağlar çünkü bellek alanı sıralıdır. Heap ise daha fazla işlem gerektirir ve dolayısıyla daha yavaş erişim sağlar.

Ömür ve Kapsam: Stack'te depolanan veriler genellikle kısa ömürlüdür ve otomatik olarak serbest bırakılır. Heap'te depolanan veriler daha uzun ömürlüdür ve programcı tarafından serbest bırakılmalıdır.

......................................................................................................................................................................................................................................................................................................................................................................................................


// blank solution boş bir çözüm ekranı açar...
// existing project ile projelerin benzer kısımlarını çekebiliriz...
// bazen framework sürüm farklılığından dolayı projeler çalışmayabilir buna dikkat etmek lazım...
// Sürümlerde üst olan hepsini kapsar ama 4.7.2   4.8 ile yazılmış olanı desteklemeyebilir. ama 4.8 kendinden alt olanları destekler.  
// nuget ile biz istersek dependies ekleyebiliriz entity framework gibi...
// c#da her veri wrapper classtır yani her ver bir nesnedir. bu yüzden her verinin metotlarını kullanabiliriz. mesela int a = 8; deriz a.equals vs kullanabiliriz...  eğer bir metotta yollayıp değerinin değişmesini falan istersek o zaman ref ile yollarız...
// static metot static main içinde çalışabilir static olmayan değer static içinde çalışmaz... static-static veya non-static - non-static olmalı...
// mesela bir class'ın oluşması için önce onun superclass'ı oluşmalı oluşurken default constructor çalışır....
degistir(ref a)
public void degisttir(ref int b) gibi...

c#da ilkel yapılar yoktur. her şey nesnedir... wrapper classtır aslında veriler.
            Console.WriteLine(int.MinValue);   // mesela direkt olarak int class'ının içindeki static MinValue değerini çağırabiliriz...  static olan değerleri ve metotları direkt olarak class ile kullanabiliriz...
            Console.WriteLine(int.MaxValue);

Console.WriteLine(int.MinValue + " EMRE"+ byte.MinValue+" FORD"+byte.MaxValue);
     + demek String'de ekleme yap demektir. böylece tüm değerler string'e döner ve işlem yapabiliriz...



            double say11 = 12.2;
            Console.WriteLine(say11);
            float say12 = (float)12.33;  // her noktalı değer aslında double'dir bizim atama yaparken float'a tip dönüşümü yapmamız lazım uppercasting yapmamız gerekiyor...
            Console.WriteLine(say12);




c#tada diğer dillerde olduğu gibi tüm veriler tanımlanır bir metot eğer bir değer dönderiyorsa o zaman tipinde karşılanır int sayi1 = sayigetir(); gibi.

Tam Sayı Veri Tipleri:

int: 32 bitlik işaretli tam sayı.
long: 64 bitlik işaretli tam sayı.
short: 16 bitlik işaretli tam sayı.
byte: 8 bitlik işaretli tam sayı.
sbyte: 8 bitlik işaretli tam sayı.

Ondalıklı Sayı Veri Tipleri:

float: 32 bitlik ondalıklı sayı.
double: 64 bitlik ondalıklı sayı.
decimal: 128 bitlik ondalıklı sayı.

Karakter Veri Tipleri:

char: 16 bitlik Unicode karakter.

Boolean Veri Tipi:

bool: Mantıksal (true veya false) değeri temsil eder.

Metinsel Veri Tipleri:

string: Metin verilerini tutan veri tipi...  
        Console.WriteLine(String.Format("{0} {1}",str1,str2));   böylede kullanabiliriz...
        .Length ile uzunluk alabiliriz...
        string aa = bb.Clone(); ile ise biz bb'nin içeriğini aa'ya atayabiliriz. 
        string.IsNullOrWhiteSpace(str1)   true false çevirir... boş değilse false çevirir mail adresi için falan kullanılır.

Object Veri Tipi:

object: Tüm diğer türlerin temel türüdür. Her türden bir nesneyi temsil edebilir.
Diziler:

int[], string[], vb.: Belirli bir türdeki elemanları içeren diziler.
Nullable Veri Tipleri:

int?, bool?, vb.: Nullable türler, değerlerin null olabileceği anlamına gelir.
Enumerations (Enum):

enum: Belirli bir türdeki sabit değerlerin adlarını içeren bir türdür.
Yapılar (Structures):

struct: Değer türleri olan, ancak sınıflar gibi davranabilen türler.
Sınıflar (Classes):

class: Referans türleri olan ve nesne tabanlı programlamanın temelini oluşturan türler.
Interface ve Arayüzler:

interface: Bir sınıfın uygulamasını zorlayan bir sözleşme sağlayan tür.

// oop demek encapsulation,polymorphism and inheritance demektir aslında...
// interfaceler aslında birer sözleşmelerdir böylece içerisindeki metotları override etmek zorunlu olur implement eden class tarafından...

################################################################################################################################################################################################################################################


            Console.WriteLine(Byte.MaxValue); // 255    256 vermeye çalışırsan Byte değere o zaman hata verir...
            Console.WriteLine(Byte.MinValue); // 0
            Console.WriteLine(long.MinValue); // -9223372036854775808
            Console.WriteLine(long.MaxValue); //   9223372036854775807
            Console.WriteLine(int.MaxValue); // 2147483647    32 bit 4 byte 2^^32 değer alır.
            Console.WriteLine(int.MinValue); // - 2147483648
            Console.WriteLine(long.MaxValue / int.MaxValue); // 4294967298
            Console.WriteLine(double.MinValue); //-1,79769313486232E+308
            Console.WriteLine(double.MaxValue); // 1,79769313486232E+308
            Console.WriteLine(ulong.MaxValue); // 18446744073709551615
            Console.WriteLine(ulong.MinValue); // 0
            Console.WriteLine(sbyte.MaxValue); // 127
            Console.WriteLine(sbyte.MinValue); // - 128
            Console.WriteLine(short.MaxValue); // 32767
            Console.WriteLine(short.MinValue); //-32768
            Console.WriteLine(ushort.MaxValue); //65535
            Console.WriteLine(ushort.MinValue); //0
            Console.WriteLine(uint.MaxValue); // 4294967295
            Console.WriteLine(uint.MinValue); // 0
            Console.WriteLine(decimal.MaxValue); // 79228162514264337593543950335     // 12 byte'dır noktadan sonra 28-29 basamak duyarı vardır...  doublede 15 16 basamak iken decimalde 28 29 böylece hassaslık çok artar...
            Console.WriteLine(decimal.MinValue); // -79228162514264337593543950335  
            Console.WriteLine(char.MinValue); // nulldan başlar
            Console.WriteLine(char.MaxValue); // ?'e kadar gider çok fazla karakterleri tutabilir. tüm dillerin alfabelerindeki harfleri tutabilir. 2 bytedir 16 bit...

bool true veya false alır mantıksal veridir... a == b demek (a == b)   bize true veya false döndürecek demektir    return a == b diyebiliriz a == b 'de true veya false dönecek zaten...

internal bir erişim belirleyicisidir ve C# dilinde bir sınıfın veya bir üyenin, yalnızca bulunduğu proje içinde erişilebilir olmasını sağlar. internal olarak işaretlenen bir sınıf veya üye, aynı derleme içindeki diğer sınıflar tarafından erişilebilir, ancak başka bir derleme tarafından erişilemez.

    "Aynı derleme" ifadesi, bir C# projesinde bir araya getirilen tüm kodun toplandığı ve derlendiği yapıyı ifade eder. Bir C# projesi, bir veya birden fazla sınıf ve dosyanın bir araya getirildiği bir "derleme" üretir. Bu derleme genellikle bir .dll (dinamik bağlantı kitaplığı) veya .exe (yürütülebilir dosya) uzantısına sahiptir.

    Bir C# projesindeki tüm sınıflar, yapılar, enum'lar, metotlar ve diğer üyeler, projenin derlenmiş çıktısı içinde bir araya getirilir. Bu çıktıya "derleme" denir. Eğer tüm bu kodlar aynı proje içinde yer alıyorsa, bu kodlar aynı derleme içindedir.

    Eğer bir sınıf veya üye internal olarak işaretlenmişse, bu, bu sınıfın veya üyenin sadece aynı derleme içindeki diğer kodlar tarafından erişilebileceği anlamına gelir. Yani, internal olarak işaretlenen bir sınıf veya üyenin erişilebilir olması için, bu sınıf veya üyenin bulunduğu proje içinde olması gerekmektedir.

    Aynı derleme içinde olmak, bir C# projesinin sınıflarının, üyelerinin ve diğer yapılarının bir araya getirildiği ve derlendiği fiziksel sınırları ifade eder. Eğer farklı projeler arasında kod paylaşımı yapmak istiyorsanız, bu durumu public veya başka bir erişim belirleyici ile yönetmeniz gerekir.


// her kesirli sayı doubledir float vs yapmak istersek o zaman tip dönüşümü yapmak lazım (float) 5.6   veya 5.6f  olarak
double sayi1 = 5/4;  1.0 olur   5 int 4 int spnuç int 1 olur double olunca 1.0 olur....    (double) 5 / 4 olsa 5.0 / 4 olur  o zaman 1.25 çıkar direkt olarak...

bölümde falan kesirli sayılarda kayıplar olabilir bunun için decimal kullanılır... hassas hesaplar için decimal kullanırız. bunu e ticaret sitelerinde vs kullanabiliriz...
     tip dönüşümlerinde kayıplar vs olabilir kesirlerden kaynaklı kayıplar olabilir bunun için decimal kullanırız hassas hesaplarda...

karakterler '' içeriisnde stringler ise "" içerisinde belirtilmelidir. pythona böyle bir fark yoktur mesela...
'' içerisinde tek bir karakter belirtilebilir.
"" olursa karakter dizisi içerebilir.

\ demek benden sonra gelecek olan bilgisayarın program komutu değil demektir.
          ana \n alt satır \t ise bir tab boşluk demektir.

c# büyük harf küçük harf ayrımı yapar int sayi1,Sayi1; yapabiliriz... yani farklı olacaktir ikiside...

*******CASTİNG büyük alandaki veri küçük alana geçemez geçecek olursa kayıplar olur ancak casting ile kayıplarla beraber yapmak mümkün. küçük veriyi büyük veri tipine sorunsuz dönüştürebiliriz. 
  mesela floatı doubleye sorunsuz atabiliriz.  ama doubleyi dönüşüm yapmadan atamayız atarsakta kayıplar olur veri kaybı olur.
  long inti sorunsuz alır veri kaybı olmadan ama tam tersi zor.
  intin long'a atanması implicit(istemsiz) dönüşümdür bir hata vermez.     
  longun int olması ise explicit döünüşümdür dönüşümü belirtmek lazım downcasting yapmak gerekir. 
  longu int yapmak için derleyiciyi ikna etmemiz lazım....
  c#da java gibi önce derlenir sonra yorumlanır.
  explicit yaparsak manuel yapmalıyız  double sayi1 = 18.8;    int sayi2 = (int)sayi1; gibi...


            Console.WriteLine(Convert.ToString(3.43));
            Console.WriteLine(Convert.ToInt64(3.43));
            int sayi12 = Convert.ToInt32("12");
            long sayi13 = Convert.ToInt64("1221");

Convert.ToTip   ile biz içerisine attığımız değeri istenen değere çeviririz. ve bu yapı isteneni return eder... int'e atama yapacaksak Convert.ToInt32(); kullanmamız lazım 
Convert.ToInt32() bu bize değer return edecek ve kullanacağız.



################################################################################################################################################################################################################################################

dizilerde veri tipleri aynı olur;
Array bir sınıftır

            int[] array = { 1, 2, 3, 4, 5, }; // burada direkt atama yapabiliriz... 
            int[] array2 = new int[10]; // burada ise 10 tane int değer alacak yer ayırırız ve otomatik olarak hepsi sıfır olur sayılarda ilk atama otomatik sıfırdır string ve class'larda ise nulldır.

Arraylerde referancelerla çalışır yani 
        public static void degistir(int[] a)
        {

            a[0] = 11;


        }   // buraya bir array gelirse ilk değeri 11 olacak kalıcı şekilde...  bunun nedeni arrayler aslında referancedir.

int[][] ab = new int[10][];  // burada 10 tane int dizisi olacak diyoruz... ikinci [] atamaya gerek yok ama atarsak sabit olarak onlarda o sayı kadar değer taşıyan int arrayler olacak... 
yani ab 10 tane int array taşıyan bir array'dir.  ab.length dersek 10 alırız...
int[][] ab = new int[10][6]; dersek eğer 10 tane 6 tane int değer taşıyan aarray vardır 6,6,6,6,6,6,6,6,6,6,6 olacak şekilde...

            int[][] ab = new int[10][];
            for (int i = 0; i < ab.Length; i++)
            {
                ab[i] = new int[9];
            }
            // bu şekilde ise 10 kere çalışır for ve her arraye bellekte yer ayırır her arrya 9 tane değer alabilir hale gelir.  bu yapı ile kapasiteleri farklı arraylerden oluşan matrisler kurabiliriz.

ab[1][1] = 100; diyerek direkt atama yapabiliriz...

mesela 10 kapasiteli bir array var 11.ciye atama yapmak istersek hata alırız.

string[] ise string değer taşıyan bir arraydir bu bir referancedir.

array[index]  ile istenen elemana ulaşırız. indexin arrayin boyutuna göre olması gerekir bu önemlidir.  yoksa hata verebilir.

int[,] demekte 2 boyutlu bir dizidir.
int[,,] ise 3 boyutlu demektir...

..........................................................................................

            int[][] aa = new int[10][];
            for (int i = 0; i < aa.Length; i++) {
                aa[i] = new int[9];
            }

            for (int i = 0;i < aa.Length; i++) { 
            for (int j = 0; j < aa[i].Length; j++)
                {
                    Console.Write(aa[i][j]);  // aa[i,j] de olabilir fark etmez... 

                }
                Console.WriteLine();

            }

int[,] aa = new int[2,3] yapabiliriz  3,3 eleman taşıyan bir matris olur böylece.
veya aa = {{1,1,1},{1,1,1}} yapabiliriz.

..................................................................................................

% kalan bulma... a += b ;  a'ya b eklenir -= çıkarır *= çarpar.    ++ tek arrttırma -- tek çıkarma     solda veya sağda olması önemli solda olursa önce değeri değişir sonra işleme dahil olur sağda olursa önce işleme dahil olur sonra değeri değişir.

(float) a / b    ile (float) a / (float) b arasında fark olabilir dikkat etmek lazım...

        C# dilinde, operatörler matematiksel işlemlerden mantıksal kontrol işlemlerine kadar birçok farklı kategoride bulunmaktadır. Ayrıca, operatörlerin öncelik sıralaması da önemlidir, çünkü bu sıralama ifadeyi değerlendirirken kullanılır.

        İşte C# dilinde kullanılan bazı temel operatörler ve öncelik sıralaması:

        Matematik Operatörleri:

        + (toplama)
        - (çıkarma)
        * (çarpma)
        / (bölme)
        % (mod alma)
        Artırma ve Azaltma Operatörleri:

        ++ (artırma)
        -- (azaltma)
        Atama Operatörleri:

        = (atama)
        +=, -=, *=, /=, %= (toplama, çıkarma, çarpma, bölme, mod ile atama)
        Mantıksal Operatörler:
        a /= 10; demek a'yı 10 böl çıkan değeri a'ya ata demek %= içinde aynısı geçerli diğerleri içinde geçerliler...


        && (ve - AND)
        || (veya - OR)
        ! (değil - NOT)
        () parantezlerin içinin önceliği var... buna dikkat etmek lazım.
        (a > b) && (b  < c)  önce sağ sol parantez sonuç return eder sonra && çalışır...
        Karşılaştırma Operatörleri:  True veta False ile çalışırlar.

        == (eşit)
        != (eşit değil)
        < (küçük)
        > (büyük)
        <= (küçük veya eşit)
        >= (büyük veya eşit)
        Bitwise Operatörler:

        & (ve)
        | (veya)
        ^ (XOR - özel veya)
        ~ (bütünleyen)
        << (sol kaydırma)
        >> (sağ kaydırma)
        Koşullu Operatör:

        ? : (koşullu ifade)   (koşul <= mesela) ? True halde return edilecek: False halde return edilecek;


            int a = 0, b = 1;
            string sonuc = (a == b) ? "esit" : "degil"; // True ise soldakini atar False ise sağdakini atar...
            Console.WriteLine(sonuc); // degil...

        Tip Dönüşüm Operatörleri:

        (tip) (dönüşüm operatörü)
        as (as operatörü)
        is (is operatörü)
        Operatörlerin öncelik sıralaması, bir ifadenin hangi operatörün önce değerlendirileceğini belirler. Öncelik sıralaması, matematiksel operatörlerin öncelikli olması, ardından karşılaştırma, mantıksal ve diğer operatörleri içerir. Ancak, ifadeyi açıklığa kavuşturmak için parantezler kullanılabilir. Örneğin, parantez içindeki ifadeler her zaman önceliklidir.


bir if else if else bloğunda sadece bir tanesi çalışır...  sırası ile okur ilk sağlanan koşula girer hiçbirisi çalışmazsa else çalışır. else olmasada olur...
int a = -10;
if(a > 0){

+

}else if(a == 0){

0

}else{

-

}


################################################################################################################################################################################################################################################

    internal class Program
    {
        static void Main(string[] args)
        {
            int sayi1 = 0;
            atamayap(ref sayi1);
            Console.WriteLine(sayi1);





        }

        public static void atamayap(ref int a)
        {

            a = Convert.ToInt32(Console.ReadLine());
        
        }


    } // sayıya atama yapan bir program...


static ile class'a bağlarız bir değeri veya metotu... static metot içerisinde static olmayan metot nesnesiz şekilde çalışamaz...
void geriye değer döndermez. bir metot kullanacaksak return yapacaksa ne türden yapacak belirlememiz lazım.

static int kucukharfsayisi(string s){

int aa = 0;

foreach(var i in s){    // foreach ile karakter karakter string üzerinde dönebiliriz...

if(char.IsLower(i)) aa++; 

}
return aa;
}



......................................................................................................................................................................................

        static void Main(string[] args)
        {

            yazdir(a: "TT",c:"YY",b:"GHGH");   // bu şekilde bir metota gönderilecek değerlerin hangisi tarafından karşılanmasını istediğimizi belirtebiliriz...

        }




        public static void yazdir(string a , string b, string c)
        {

            Console.WriteLine(a + " " + b + " " + c);

        }

        public static void yazdir(string a , string b)  // burada ise aynı tipte aynı isimde farklı parametreli metotlar ile metot overloading yapaarız ve program verilen değişkenlere göre kendisini en az yoran ve en uygun olanı çağırır...
        {

            Console.WriteLine(a + " " + b);

        }

......................................................................................................................................................................................

C# programlama dilinde metotlar, kodunuzu modülerleştirmenin ve tekrar kullanılabilirliği artırmanın önemli bir yolu olarak karşımıza çıkar. Metotlar, belirli bir görevi yerine getiren ve genellikle bir isimle çağrılabilen kod bloklarıdır. Bu yazıda, C# dilinde metotların nasıl tanımlandığı, kullanıldığı ve özelleştirildiği konularına detaylı bir şekilde odaklanacağız.

Metot Tanımı:
C# programlama dilinde bir metot, aşağıdaki gibi bir yapıda tanımlanır:

erişim_belirleyici dönüş_türü MetotAdı(parametre_listesi)
{
    // Metotun içeriği
}
Erişim Belirleyici (Access Modifier): Metodun ne kadar görünür olduğunu belirler. Örneğin, public, private, protected, internal gibi.

Dönüş Türü (Return Type): Metodun geri döndüğü değerin türünü belirtir. Eğer metot bir değer döndürmüyorsa void kullanılır.

Metot Adı: Metodu çağırırken kullanılacak ismi belirtir.

Parametre Listesi: Metotun içinde kullanılacak değerleri almak için kullanılır. Parametreler opsiyonel olabilir.

Örnek Bir Metot Tanımı:

public int Topla(int sayi1, int sayi2)
{
    int toplam = sayi1 + sayi2;
    return toplam;
}
Bu metot, iki tane int tipinde parametre alır (sayi1 ve sayi2), bu sayıları toplar ve sonucu int türünde geri döner.

Metot Kullanımı:
Bir metodu kullanmak için, öncelikle sınıfın bir örneğini oluşturmalı veya metot static olarak tanımlanmışsa sınıf adı üzerinden çağrılmalıdır.


// Metot çağrısı
int sonuc = Topla(5, 7);
Console.WriteLine("Toplam: " + sonuc);
Parametre Türleri ve Seçenekler:
Metotlara parametreler ile veri iletimi yapılır. Parametreler, değer türleri (int, float, char, vb.) veya referans türleri (class, array, interface, vb.) olabilir. Ayrıca, parametreler opsiyonel olabilir, varsayılan değerler atanabilir.


public void Yazdir(string metin, int tekrarSayisi = 1)
{
    for (int i = 0; i < tekrarSayisi; i++)
    {
        Console.WriteLine(metin);
    }
}
Bu metot, bir metni belirli bir sayıda ekrana yazdırmak için kullanılır. tekrarSayisi parametresi varsayılan olarak 1'e ayarlanmıştır, ancak metot çağrısı sırasında farklı bir değer atanabilir.

Overloading (Aşırı Yükleme):
Bir sınıf içinde aynı isme sahip fakat farklı parametre listelerine sahip birden fazla metot tanımlamak mümkündür. Bu duruma "overloading" denir.


public int Topla(int sayi1, int sayi2)
{
    return sayi1 + sayi2;
}

public double Topla(double sayi1, double sayi2)
{
    return sayi1 + sayi2;
}
Bu örnekte, Topla isimli iki farklı metot tanımlanmıştır. İlk metot int türünde, ikinci metot ise double türünde çalışır.




ref ve out Parametreleri:
ref ve out parametreleri, metotların değerleri dışarıdan değiştirmesine izin verir.


public void Arttir(ref int sayi)
{
    sayi++;
}

public void Bol(ref int bolen, int bolunen, out int bolum)
{
    bolum = bolen / bolunen;
}



params Parametresi:
params anahtar kelimesi, değişken sayıda parametre alabilen bir metot tanımlamak için kullanılır.


public int Topla(params int[] sayilar)
{
    int toplam = 0;
    foreach (int sayi in sayilar)
    {
        toplam += sayi;
    }
    return toplam;
}



static Metotlar:
Bir metot static olarak tanımlandığında, sınıf adı üzerinden çağrılabilir ve sınıfın bir örneği oluşturulmasına gerek yoktur.


public class Matematik
{
    public static int KareAl(int sayi)
    {
        return sayi * sayi;
    }
}

// Kullanım
int sonuc = Matematik.KareAl(4);
Bu örnekte, KareAl metodu static olarak tanımlanmış ve Matematik sınıfı üzerinden çağrılmıştır.

Lambda İfadeleri ile Kısa Metotlar:
C# 3.0 ve sonrasında lambda ifadeleri kullanarak kısa metotlar tanımlamak mümkündür.


Func<int, int, int> topla = (x, y) => x + y;
Console.WriteLine(topla(3, 4));
Bu örnekte, topla adında bir lambda ifadesi kullanılarak kısa bir toplama metodu tanımlanmıştır.




################################################################################################################################################################################################################################################

        namespace appConsole
        {


            public class MyName
            {
                




            }


            internal class Program
            {
                static void Main(string[] args)
                {
                    int sayi1 = 0;
                    atamayap(ref sayi1);
                    Console.WriteLine(sayi1);





                }

                public static void atamayap(ref int a)
                {

                    a = Convert.ToInt32(Console.ReadLine());
                
                }


            }
        }




################################################################################################################################################################################################################################################
    ref Anahtar Kelimesi:
    ref anahtar kelimesi, bir metoda argüman olarak geçirilen bir değişkenin, metot içinde değiştirilebileceğini belirtir. Bu, metot içinde değişen değerin, çağrıldığı yerdeki orijinal değişkeni etkileyebileceği anlamına gelir.

    
    public void Arttir(ref int sayi)
    {
        sayi++;
    }

    // Kullanım
    int sayi = 5;
    Arttir(ref sayi);
    Console.WriteLine(sayi); // 6
    Bu örnekte, Arttir metodu bir ref parametre alır ve bu parametre üzerinde yapılan değişiklikler, orijinal değişkeni etkiler.

    out Anahtar Kelimesi:
    out anahtar kelimesi, bir metot tarafından bir değer döndürülmesini sağlar. Ancak, out ile belirtilen bir parametre, metot çağrısı yapmadan önce başlatılmasına rağmen, metot içinde değer atanması gerekmez. out parametreleri, metottan birden fazla değeri döndürmek amacıyla da kullanılabilir.

  
    public void Bol(int bolen, int bolunen, out int bolum)
    {
        bolum = bolen / bolunen;
    }

    // Kullanım
    int bolum;
    Bol(8, 2, out bolum);
    Console.WriteLine(bolum); // 4
    Bu örnekte, Bol metodu out parametre kullanarak bir değeri döndürüyor. out parametreler, metottan değeri döndürmek için kullanıldıklarında, metotun içinde değer atanması zorunlu değildir.

    ref ve out Kullanımına İlişkin Noktalar:
    ref ve out parametreleri, metot çağrısı yapmadan önce başlatılmalıdır. out parametreleri özellikle metot içinde değer atanmasa bile başlatılmalıdır.

    ref ve out kullanımı, genellikle bir metotun birden fazla değeri değiştirmesi veya döndürmesi gerektiğinde tercih edilir.

    ref kullanımında, değer atanmış bir değişkenin referansı geçilir ve metot içinde değiştirilen değer, orijinal değişkeni etkiler.

    out kullanımında, metotun değeri döndürmesi gerektiğinde veya metotun içinde değer atanması gerektiğinde tercih edilir.

    Hem ref hem de out parametreleri, metotun başlığında belirtilen türde olmalıdır.

    Bu anahtar kelimeler, programlamada değerleri metotlar arasında aktarırken ve metotlardan değer alırken kullanılır ve C# dilinde esnek bir parametre geçirme ve döndürme mekanizması sağlar.
################################################################################################################################################################################################################################################

constructor yapıcı metotdur. çok önemlidir... constructor overloading yapabiliriz. istediğimiz parametreler ile çalışır hale getirebiliriz...

public olursa her yerden erişebilir... public'te erişim kısıtı yoktur.
protected ait olduğu sınıftan ve o sınıftan türetilen yerlerden erişilebilir.




            C# programlama dilinde, erişim belirleyicileri (access modifiers), bir sınıfın, üyenin (örneğin, bir alan, bir metot veya bir özellik) veya bir derlemenin başka kod bloklarından ne kadar görünür ve erişilebilir olduğunu belirten özel anahtar kelimelerdir. Erişim belirleyicileri, sınıfın, üyenin veya derlemenin erişilebilirliğini kontrol etmek için kullanılır ve bu sayede programın modülerliğini ve güvenliğini sağlar.
            C# dilinde beş temel erişim belirleyici bulunmaktadır:

            public:

            Herkes tarafından erişilebilir.
            Örneğin: public class Example { }


            private:

            Sadece tanımlandığı sınıf içerisinden erişilebilir.
            Örneğin: private int count;


            protected:

            Tanımlandığı sınıf ve bu sınıftan türetilmiş sınıflar tarafından erişilebilir. yani kalıtım almış sınıflar ve kendi sınıfı erişebilir bu metotlara ve değişkenlere... 
            Örneğin: protected void DoSomething() { }


            internal:

            Bulunduğu derleme içerisindeki herhangi bir sınıf tarafından erişilebilir.
            Örneğin: internal class InternalClass { }


            protected internal:
             
            Tanımlandığı sınıf, türetilmiş sınıflar ve bulunduğu derleme içerisindeki herhangi bir sınıf tarafından erişilebilir.
            Örneğin: protected internal string Name { get; set; }
               mesela bir class içinde protected bir değişken var kendi içeriisnde ve kalıtım alanların içerisinde çalışır bu protected metotlar ve değişkenler. başka bir class'ta nesne oluşturup'ta erişemeyiz. 
               private olursa eğer super kullanmadan erişemeyiz kalıtım devreye girerse. 

                                class class1
                                {

                                    protected string name = "emre";

                                }

                                class Program
                                {

                                    static void Main(string[] args)
                                    {

                                        Console.WriteLine();
                                        Console.WriteLine(aa.name); // hata verir. erişemeyiz...

                                    }

                                }


            Bu erişim belirleyicileri, sınıfların, üyelerin ve derlemelerin ne kadar görünür olduğunu kontrol etmek için kullanılır. Bu, bir kod tabanının iyi bir şekilde organize edilmesini, sınıfların ve üyelerin sadece gerekli yerlerden erişilebilir olmasını ve kodun güvenliğini sağlamak açısından önemlidir.

################################################################################################################################################################################################################################################

namespace appConsole
{
    class TTT
    {

        private int skor;
        public int Skor
        {
            
            get { return skor; } // get bloğu skor okunmak istediği zaman çalışır.
            set {  skor = value; } // set ise atama yapılmak istendiği zaman çalışır.

        }

    }
    class Program
    {

        static void Main(string[] args)
        {

            TTT aaa = new TTT();
            aaa.Skor = 1; // set çalışır. private değişkene atama yapar.
            Console.WriteLine(aaa.Skor); // get çalışır burada.  private skorun değerini döndürür...

        }


    }
}


.........................................................................................................................

    class Kisi
    {
        private int yas;
        private string dogumyeri;
        private string meslek;

        public int Yas { 

        get { return yas; }
            set { 
            

                if (value < 0)
                {

                    yas = 0;
                }
                else
                {
                    yas = value;
                }
            
            }
        
        }

        public string Dogumyeri
        {

             get { return dogumyeri; }
            set { dogumyeri = value;}

        }

        public string Meslek
        {

            get { return meslek; }
            set { meslek = value; }
        
        }



        public Kisi(int yas, string dogumyeri, string meslek)
        {
            this.yas = yas;
            this.dogumyeri = dogumyeri;
            this.meslek = meslek;
        }



    }


################################################################################################################################################################################################################################################

// properity olayı...


namespace appConsole
{
    class Kisi
    {
        public int yas {  get; set; }
        public string dogumyeri { get; set; } 
        public string meslek {  get; set; }

        public Kisi(int yas, string dogumyeri, string meslek)
        {
            this.yas = yas;
            this.dogumyeri = dogumyeri;
            this.meslek = meslek;
        }
    }


    class Program
    {

        static void Main(string[] args)
        {
            Kisi kisi1 = new Kisi(1,"b",meslek:"c");
            kisi1.yas++; kisi1.dogumyeri = "ist"; kisi1.meslek = "otomasyon";
            Console.WriteLine(kisi1.meslek);
            Console.WriteLine(kisi1.dogumyeri+" "+kisi1.yas);

        }


    }
}

################################################################################################################################################################################################################################################

            C# programlama dilinde, bellek yönetimi iki temel alanı içerir: stack (yığın) ve heap (örtü). Bu iki alan, programın çalışma zamanında verileri depolamak için kullanılır, ancak farklı özelliklere sahiptir.

            Stack (Yığın):
            Stack, programın çalışma zamanında yönetilen bir bellek alanıdır. Bu alanda veriler, sıralı bir şekilde depolanır ve bu verilere hızlı erişim sağlanır. Stack'te veri depolamak için kullanılan bellek alanı, genellikle yönetilen (managed) veri tipleri ve değer tipleri içindir. İşte stack'te tutulan bazı veri tipleri:

            Değer Tipleri:

            int, char, float, double, bool gibi temel veri tipleri.
            struct tarafından tanımlanan yapılar.
            Yerel Değişkenler:

            Metot içerisinde tanımlanan değişkenler.
            Metot Çağrıları:

            Metot çağrıları ve metot çağrılarına ait yerel değişkenler.
            Stack'te depolanan veriler, programın akışı içinde meydana gelen işlemlerle birlikte otomatik olarak tahsis edilir ve serbest bırakılır. Stack, veri tipleri için hızlı erişim sağlar, ancak boyutları genellikle sınırlıdır ve yaşam süreleri kısa olduğu için otomatik olarak serbest bırakılır.

            Heap (Örtü):
            Heap, programın çalışma zamanında yönetilen bir diğer bellek alanıdır. Heap'te depolanan veriler, daha uzun ömürlüdür ve belirli bir yaşam süresine sahiptir. Genellikle heap, dinamik olarak tahsis edilen ve serbest bırakılan bellek alanıdır. Heap'te tutulan bazı veri tipleri şunlardır:

            Referans Tipleri:

            class tarafından tanımlanan nesneler.
            string gibi dinamik bellek tahsisi gerektiren türler.
            Dinamik Bellek Tahsisi:

            new anahtar kelimesi ile oluşturulan nesneler.
            Heap'te depolanan veriler, programcı tarafından elle serbest bırakılmalıdır (örneğin, Dispose veya Close gibi yöntemler kullanılarak), aksi takdirde bu bellek sızıntılarına neden olabilir.

            İki bellek alanı arasındaki temel farklar şunlardır:

            Hız ve Erişim Süresi: Stack, hızlı bir erişim sağlar çünkü bellek alanı sıralıdır. Heap ise daha fazla işlem gerektirir ve dolayısıyla daha yavaş erişim sağlar.

            Ömür ve Kapsam: Stack'te depolanan veriler genellikle kısa ömürlüdür ve otomatik olarak serbest bırakılır. Heap'te depolanan veriler daha uzun ömürlüdür ve programcı tarafından serbest bırakılmalıdır.


// struct tanımlama ve kullanımı

struct node // struct demek yapı ismi node ise kullanılacak isim.   class'lara benzerler... classların nesneleri heap alanında tutulur referancelidir.  structlarınki ise stack alanında tutulur ilkel veriler gibi.
{ // metottda tanımlayabiliriz...

    public int deger;
    public String name;
    public void yazdir(){

Console.WriteLine("AAAAA"); // WriteLine alt satıra geçirir Write alt satıra geçirmez...

    }
}

public static void Main(String[] args){
            node node1 = new node();

            node1.name = "emre";
            node1.deger = 15;
}



################################################################################################################################################################################################################################################

c#da her şey class'lar içerisinde yer alır global değişken vs gibi bir şey yoktur...
string sınıf referance ile çalışır. bir metot onu değiştirebilsin istersek eğer o zaman ref ile göndermemiz gerekir ref ile karşılamamız gerekir.
string name; yaparsak name otomatik null olur... null ise "" dir...  ascii'daki 0...
string sınıfı System kütüphanesinin altında yer alır System.string olarak kullanabiliriz...
string s;  s.Length ile uzunluk alabiliriz...  s[0] s[1] ... ile istenen indexteki elemana ulaşabiliriz...


            foreach (var item in kisi1.meslek)
            {
                Console.Write(item + " ");
            } // foreach ile string üzerinde dönebiliriz...


string s = "emre";
string b = s.Clone(); // böylece içerik kopyalama yapabiliriz Clone() ile...
s == b True verir... içerik kıyaslaması yapar c# eğer referance karşılaştırması yapmak istersek o zaman string.ReferenceEquals(a,b); kullanırız.

Endswith(); ve StarsWtih() ile nasıl başayıp nasıl bittiğini görebiliriz...
.Indexof() ise arar yoksa -1 verir varsa başlangıç indexini verir...
LastIndexOf() ise sondan aramaya başlar...
Insert(index,"istenen"); ile ekleme yapabiliriz. return eder yeni metni... araya eklersek isteneni diğerleri sağa kayar... sağında kalanlar istenen araya girer yani...
SubString(index,index2); index dahil index2 dahil değil arada kalan metni return et demektir...
.Replace(eski,yeni); return eder kalıcı değişim değildir. eski ile yeniyi değiştirir...
.Remove(index,index2); return eder istenen aralıktaki şeyleri siler...

kullanılmayan değerler garbage collector tarafından silinir...

###ENUM#############################################################################################################################################################################################################################################

nesneleri numaralandırmak için kullanılırlar...


namespace appConsole
{
    class Kisi
    {
        public int yas {  get; set; }
        public string dogumyeri { get; set; } 
        public string meslek {  get; set; }

        public Kisi(int yas, string dogumyeri, string meslek)
        {
            this.yas = yas;
            this.dogumyeri = dogumyeri;
            this.meslek = meslek;
        }
    }





    class Program
    {

        enum Aylar  // veritabanınıda yer almasını istemediğimiz verileri static olarak tutar programda. public statictir.
        {
           Ocak,Şubat,Mart,Nisan,Mayıs,Haziran,Temmuz,Ağustos,Eylül,Ekim,Kasım,Aralık
        }

        enum SiparisDurumu : byte // byte ile sıralandır demektir...
        {

            Hazırlanıyor,Hazırlandı,Kargolandı

        }

        enum Meyveler : int  
        {
            Elma = 1,muz = 2,Çilek = 3

        }

        static void Main(string[] args)
        {

            byte a = (byte)Meyveler.muz;
            byte b = (byte)Meyveler.Elma;
            byte c = (byte)Meyveler.Çilek;
            Console.WriteLine("{0} {1} {2}",a , b , c);
            
            Console.Read();


        }


    }
}



################################################################################################################################################################################################################################################

            namespace appConsole
            {
            
                class Person
                {

                    public Person() // constructor....
                    {

                        Console.WriteLine(1 + " ");
                    }

                }

                class Person2 : Person // Person2 Persondan kalıtım almış oldu... Person superclass Person2 ise Subclass olur...
                {

                    public Person2() // constructor....
                    {

                        Console.WriteLine(2);
                    }

                }

                class Program { 

                    static void Main(string[] args)
                    {

                        Person2 person = new Person2();  // 1 2 yazdırır çünkü bir subclass'ın oluşabilmesi için superclass'ın default constructor'unun çalışması lazım... ve hatta önce değişkenler oluşur bir class'ta sonra metotlar. class'lar değişkenler ve metotlardan oluşurlar...
                        // superclass'un default constructoru(boş olan) çalışmadan bitmeden subclass oluşmaz...
                    }


                }
            }

...................................................................................................................................

    class Person3
    {
        string name;

        public void yazdir(string name)
        {
            Console.WriteLine(name); // metota gelen name'yi yazdırır... eğer metota gelenle nesnenin namesi farklı isimle tanımlanmış olsa name1,name2 olarak o zaman this. vs kullanmaya gerek kalmazdır... hangisi nesnenin hangisi metotun belirtmeye gerek olmazdı...
            Console.WriteLine(this.name); // nesnenin namesini yazdırır... 

        }
        
    }

...................................................................................................................................

        using System;

        // Birinci sınıf (kalıtım alınan sınıf)
        public class Animal
        {
            public void Eat()
            {
                Console.WriteLine("The animal is eating.");
            }
        }

        // Birinci arayüz
        public interface IMove
        {
            void Move();
        }

        // İkinci arayüz
        public interface ISound
        {
            void MakeSound();
        }

        // Sınıf, hem Animal sınıfından kalıtım alıyor hem de IMove ve ISound arayüzlerini uyguluyor.
        public class Dog : Animal, IMove, ISound // yani : karşısına kalıtım alınacak nesne ve interfaceler yazılırsa iş tamamlanmış oluyor...
        {
            public void Bark()
            {
                Console.WriteLine("Woof woof!");
            }

            public void Move()
            {
                Console.WriteLine("The dog is moving.");
            }

            public void MakeSound()
            {
                Console.WriteLine("Barking sound");
            }
        }

        class Program
        {
            static void Main()
            {
                // Dog sınıfından bir örnek oluşturup kullanım
                Dog myDog = new Dog();
                myDog.Eat();        // Animal sınıfından kalıtım alınan metodu kullanma
                myDog.Bark();       // Dog sınıfının kendi metodunu kullanma
                myDog.Move();       // IMove arayüzünden gelen metodu kullanma
                myDog.MakeSound();  // ISound arayüzünden gelen metodu kullanma
            }
        }

...................................................................................................................................

mesela bir class'ın birden fazla interfacesi var ve bunların metotlarını override etmedi o zaman o class abstract olur... abstract class'tan nesne üretilemez... eğer abstract class'tan türetilen bir sınıf override edilmemiş şeyleri yani hepsini override etmezse abstract olur... nesne oluşturulması için bir o yapıda en kötü ihtimalle abstract olmayan class'ta hepsinin(geriye doğru toplam) override edilmesi lazım

...................................................................................................................................

Polimorfizm, bir nesnenin farklı türlerde davranabilme yeteneğidir. C# dilinde polimorfizm, genellikle iki şekilde gerçekleştirilir: method overriding (metot ezme) ve arayüzler.

1. Method Overriding (Metot Ezme):
Polimorfizmin temel özelliklerinden biri method overriding'dir. Bu özellik, bir alt sınıfta, üst sınıfta tanımlanan bir metodun aynı imza (signature) ile tekrar tanımlanmasını ifade eder. Bu, üst sınıftan türetilen nesnelerin aynı ad ve parametrelerle farklı davranışlar sergilemesini sağlar.


        public class Animal
        {
            public virtual void MakeSound()  // virtual olması lazım eğer bir metot'un override edilebilir olması için...
            {
                Console.WriteLine("Animal makes a sound");
            }
        }

        public class Dog : Animal
        {
            public override void MakeSound() // override ile ise override ettiğimizi belirtiriz... böylece subclass'ın nesnesine özgü olacak metot...
            {
                Console.WriteLine("Dog barks");
            }
        }

        public class Cat : Animal
        {
            public override void MakeSound()
            {
                Console.WriteLine("Cat meows");
            }
        }

        class Program
        {
            static void Main()
            {
                Animal animal1 = new Dog();
                Animal animal2 = new Cat();

                animal1.MakeSound(); // Dog barks
                animal2.MakeSound(); // Cat meows
            }
        }

superclass subclass'larına referance olabilir mesela buradan köpekten golden türetelim o zaman Animal ona referance olabilirdi...

...................................................................................................................................

namespace appConsole
{

    public class Animal
    {
        public virtual void MakeSound()
        {
            Console.WriteLine("Animal makes a sound");
        }
    }

    public class Dog : Animal
    {
        public override void MakeSound()
        {
            
            Console.WriteLine("Dog barks");

        }

        public void sesyaphele()
        {
        
            Console.WriteLine("SES");

        }

    }

    public class Cat : Animal
    {
        public override void MakeSound()
        {
            Console.WriteLine("Cat meows");
        }
    }

    class Program { 

        static void Main(string[] args)
        {


            Dog aa = new Dog();
         aa.sesyaphele();
             Animal bb = new Dog();
            // bb.MakeSound(); // hata veriyor bunun nedeni şudur = çünkü çalışan değişkenler ve metotlar Referance'ın içindekilerine erişebiliyor. Yani Referans ne ise onu kullanabilir c# onun kod bloğu içerisini görebiliriz...

            if(bb is Dog) // is ile bir nesne new Dog()'tan mı oluşturulmuş bunu görebiliriz... 
            {
                Dog cc = (Dog)bb; // ama bunun çözümü belli şunu yapabiliriz... Tip dönüşümü ile bu sorunu çözebiliriz.
                cc.sesyaphele();
            }


        }


    }
}

################################################################################################################################################################################################################################################

encapsulation demek verinin veya metotun class içerisinde örtülmesi demektir. private ile yapabiliriz. verielrin veya metotların korunması içindir. kaliteli program yazmak içindir.
  ortak olan yzılımcıdan ve kendimizden kontrolsüz erişimi engellemek için kullanırız....

                    Encapsulation, sınıfın içindeki verilerin ve metodların sınıf dışından gelen erişimlere karşı korunmasıdır. Bu, sınıfın iç detaylarının saklanarak, sadece belirlenen metodlar aracılığıyla dış dünyaya erişilebilmesini sağlar.

                    using System;

                    public class BankAccount
                    {
                        private string accountNumber;
                        private decimal balance;

                        public BankAccount(string accountNumber, decimal initialBalance)
                        {
                            this.accountNumber = accountNumber;
                            this.balance = initialBalance;
                        }

                        // Getter ve setter metotları aracılığıyla private alanlara erişim
                        public string AccountNumber
                        {
                            get { return accountNumber; }
                            set { accountNumber = value; }
                        }

                        public decimal Balance
                        {
                            get { return balance; }
                            private set { balance = value; }
                        }

                        // Para çekme işlemi
                        public void Withdraw(decimal amount)
                        {
                            if (amount > 0 && amount <= balance)
                            {
                                balance -= amount;
                                Console.WriteLine($"{amount:C} withdrawn. New balance: {balance:C}");
                            }
                            else
                            {
                                Console.WriteLine("Invalid withdrawal amount or insufficient funds.");
                            }
                        }

                        // Para yatırma işlemi
                        public void Deposit(decimal amount)
                        {
                            if (amount > 0)
                            {
                                balance += amount;
                                Console.WriteLine($"{amount:C} deposited. New balance: {balance:C}");
                            }
                            else
                            {
                                Console.WriteLine("Invalid deposit amount.");
                            }
                        }
                    }

                    class Program
                    {
                        static void Main()
                        {
                            // Encapsulation örneği
                            BankAccount myAccount = new BankAccount("123456789", 1000.00m);

                            // Getter ve setter kullanımı
                            Console.WriteLine($"Account Number: {myAccount.AccountNumber}");
                            myAccount.AccountNumber = "987654321";
                            Console.WriteLine($"New Account Number: {myAccount.AccountNumber}");

                            // Getter kullanımı
                            Console.WriteLine($"Balance: {myAccount.Balance:C}");

                            // Para çekme ve yatırma işlemleri
                            myAccount.Withdraw(500.00m);
                            myAccount.Deposit(200.00m);
                        }
                    }

...................................................................................................................................


    // property ile kapsülleme... 
    public class Bolum
    {

        private String bolumadi;

        public String GetBolumAdi()
        {

            return this.bolumadi;

        }

        public void SetBolumadi(string bolumadi)
        {

            if (bolumadi != null ) // buradaki bolumadi fonksiyona gelen bolumadi...
            {
                this.bolumadi = bolumadi;

            }
            else
            {
                this.bolumadi="null";
            }
          
        }

    }




...................................................................................................................................

   
    public class Bolum
    {

        private String bolumadi;

          public string Bolumdi
        {
            get { return bolumadi; } 
            set { 

                if (value.Equals("Programlama"))
                {

                    this.bolumadi = "boyle bir bolum yok..";

                }
                else
                {

                      bolumadi = value;
                }
            
            }
        } 


    }

    
...................................................................................................................................
            namespace appConsole
            {

                class Program {

                    static int deger = 0; // static olursa bir değer veya metot class'a özgü olur...
                    private string isim {  get; set; } // getter setterarı böyle kullanabiliriz...
                    private string id;
                    public string Id
                    {
                        get { return this.id; }
                        set { 

                            if (value == null) { 
                            this.id = "null";

                            }
                            else
                            {
                                this.id = value;
                            }

                                
                                ; }
                    }

                    public void yazdir() 
                    {
                        if (Program.deger == 3)
                        {

                            return; // return void bir metotu bitirmek içinde kullanılabilir...
                            
                        }

                        Program.deger++; // static değer değişimini class üzerinden yapıyoruz...
                        Console.WriteLine("\\"); // \ demek benden sonra gelen komut karakteri değil demek \\ ile biz \yazdırırız.. tek \ olursa " olarak kalır hata verir çünkü diğerine komut değilsin der ama o komut...
                        Program aa = new Program(); //  her seferinde yeni nesne oluşuyor...
                        aa.yazdir(); // recursive olarak çalışır...


                    }

                    public override string ToString()
                    {
                        return "SELAM KAHPE";
                    }

                    static void Main(string[] args)
                    {
                        Program aa = new Program(); // bir class içeriisnde kendi türünde nesne oluşturabiliriz... ve metotlarını değişkenlerini kullanabiliriz...
                        aa.isim = "aa";// burada set çalışır 
                        Console.WriteLine(aa.isim); // aa yazdırır... ve get çalışır... {get; set;} ile otomatik olarak getter setter ekleyebiliriz... 
                        Console.WriteLine(aa); // SELAM KAHPE
                        aa.yazdir();



                    }


                }
            }

..................................................................................................................................................................................................................................................


            using System;

            // Üst sınıf (superclass)
            public class Animal
            {
                // Üst sınıfa ait iki değişken
                protected string name;
                protected int age;

                // Üst sınıfın constructor'ı
                public Animal(string name, int age)
                {
                    this.name = name;
                    this.age = age;
                }

                // Üst sınıfa ait bir metot
                public void DisplayInfo()
                {
                    Console.WriteLine($"Name: {name}, Age: {age}");
                }
            }

            // Alt sınıf (subclass)
            public class Dog : Animal
            {
                // Alt sınıfa ait üçüncü değişken
                private string breed;

                // Alt sınıfın constructor'ı
                public Dog(string name, int age, string breed) 
                    : base(name, age) // Üst sınıfın constructor'ını çağırma super yerine :base(...) yapısı vardır... nnormalde super olur ve en üstte tanımlanır burada ise :base() ile en üstte olup olmama durumu ortadan kalkmış direkt olarak çalışır super() yani base()...
                {
                    this.breed = breed;
                }

                // Alt sınıfa ait kendi metodu
                public void DisplayBreed()
                {
                    Console.WriteLine($"Breed: {breed}");
                }

                // Alt sınıfa ait bir metot, üst sınıftan gelen metodu çağırma
                public new void DisplayInfo()
                {
                    base.DisplayInfo(); // Üst sınıfın metodu
                    Console.WriteLine($"Breed: {breed}");
                }
            }

            class Program
            {
                static void Main()
                {
                    // Alt sınıfın nesnesini oluşturma
                    Dog myDog = new Dog("Buddy", 3, "Golden Retriever");

                    // Alt sınıfın metotlarını çağırma
                    myDog.DisplayInfo();   // Üst sınıftan gelen metodu çağırma
                    myDog.DisplayBreed();  // Alt sınıfa ait metodu çağırma
                }
            }



################################################################################################################################################################################################################################################

interface sözleşme gibidir... metotları override edilmelidir.
interfaceler property barındılarabilir metotların tipini çalışma biçimini barındırabilirler...  int sayi{get;set;} gibi sonradan özelleştirmemiz lazım ama...
gövdeli metot olamaz. değişken tanımlanamaz.
constructor olamaz.
interface ile nesne üretilemez. ancak referance olabilir ama kendi metotlarına(tam emin değilim öyle herhalde)....
interfaceler kendisi arasında türetilebilir subinterface superinterface olayı vardır.
interfaceler genel olarak I ile başlarlar...
çoklu kalıtım interfaceler ile yarım yamalak sağlanırlar...
interfaceler erişim belirleyici almaz daima public'tir... public olmayan bir şey alamaz interface...
interface içerisinde static bir yapı kuramayız...
interfaceler parametreli metot imzası alabilir... void yazdir(string a, int 5); ...



............................................................................................................................................................................................................................................................................................
                C# dilinde, bir arayüz (interface), bir veya birden fazla sınıfın veya struct'ın belirli metotları, özellikleri ve olayları uygulamasını sağlayan bir türdür. İnterfaceler, çok sayıda türü ortak bir davranışa sahip olacak şekilde birleştirmek ve kodun daha esnek, modüler ve okunabilir olmasını sağlamak için kullanılır.

                Temel Arayüz Tanımı:
                Bir arayüz tanımı şu şekildedir:

        
                public interface ILogger
                {
                    // Metot tanımı
                    void Log(string message);

                    // Özellik tanımı
                    string LogName { get; set; }  // get ve setleri belirlememiz lazım ama...
                    
                    // Olay tanımı
                    event EventHandler LogEvent;
                }
                Bu örnekte, ILogger adında bir arayüz tanımlanmıştır. Bu arayüz, bir logger'ın (günlük kaydedici) temel davranışını tanımlar: Log metodu ile bir mesajı kaydetmek, LogName özelliği ile log adını almak ve LogEvent olayını kullanarak bir log olayını bildirmek.

                Arayüzü Uygulayan Bir Sınıf:
                Bir sınıf, bir arayüzü implements (uygular) anahtar kelimesiyle uygular. Örneğin:

            
                public class ConsoleLogger : ILogger
                {
                    // ILogger arayüzünden gelen metot
                    public void Log(string message)
                    {
                        Console.WriteLine($"Log: {message}");
                    }

                    // ILogger arayüzünden gelen özellik
                    public string LogName
                    {
                        get { return "ConsoleLogger"; }
                        set { /* Setter içeriği, gerektiğine göre uygulanabilir */ }
                    }

                    // ILogger arayüzünden gelen olay
                    public event EventHandler LogEvent;

                    // Başka metotlar, özellikler ve olaylar da eklenebilir.
                }
                Bu örnekte, ConsoleLogger sınıfı, ILogger arayüzünü uygular. Arayüzden gelen metot, özellik ve olaylar bu sınıf içinde gerçekleştirilir.


                Arayüz Kullanımı:
               
                class Program
                {
                    static void Main()
                    {
                        // ILogger arayüzü üzerinden nesne oluşturma
                        ILogger logger = new ConsoleLogger();

                        // Arayüz metotları kullanımı
                        logger.Log("Hello, Interface!");
                        Console.WriteLine($"LogName: {logger.LogName}");

                        // Arayüz olayına abone olma
                        logger.LogEvent += (sender, e) =>
                        {
                            Console.WriteLine("Log event triggered!");
                        };

                        // Arayüz olayını tetikleme (örnek amaçlı)
                        logger.LogEvent?.Invoke(null, EventArgs.Empty);
                    }
                }
                Bu örnekte, ILogger arayüzünü kullanarak bir ConsoleLogger nesnesi oluşturulmuş ve ardından arayüzün metotları, özellikleri ve olayları kullanılmıştır.

                Arayüzler, bir sınıfın birden fazla arayüzü uygulayabilmesine olanak tanır. Bu da çoklu kalıtımın sağladığı esneklik avantajlarını sunar. Ayrıca, interfaceler, kodun daha modüler olmasına ve kodun test edilebilirliğini artırmaya katkıda bulunur.
............................................................................................................................................................................................................................................................................................

    interface Idemo
    {
        void goster();

    }

    interface Iicerikler : Idemo
    {

        int sayi1 { get; set; }


    }

    class AA : Iicerikler
    {
        public int sayi1 { get { return sayi1; } set {sayi1 = value; } }

        public void goster()
        {
            Console.WriteLine("LETS GO...");

        }
    }

    // interfaceler kendi aralarında subinterface superinterface İlişkisi kurabilir. subinterface'i implement eden class superinterface'ide implement etmiş olur...



################################################################################################################################################################################################################################################

abstract olan bir metot subclass'ta override edilmeli edilmezse o classta abstract olur... çünkü gövdesiz metot vardır...
abstract metot varsa class'ta abstract'tır... kullanılma amacı override zorunluluğudur...

public abstract void Add();
public abstract void Delete(); 
public abstract void Update(); 
public abstract void Get(); 

gibi... bunun yerine interfacede kullanabilirdik...
eğer bir class abstract metot içeriyorsa ve interface implement edip tüm metotları override etmediyse abstract olur class...
static metot abstract olamaz...
abstract classlar private olamaz. public protected olabilir.
abstract classlar sealed anahtar kelimesi ile ifade edilemez...


                namespace appConsole
                {


                    abstract class Database
                    {
                        public abstract void Add();
                        public abstract void Delete();
                        public abstract void Update();
                        public abstract void Get();

                    }


                    class SQLserver : Database // extends edenler tüm metotları doldurur ve biz böylece override zorunluluğu sağlamış oluruz...
                    {
                        public override void Add()
                        {
                        }

                        public override void Delete()
                        {
                            
                        }

                        public override void Get()
                        {
                            
                        }

                        public override void Update()
                        {
                            
                        }
                    }

                    class MySql : Database
                    {
                        public override void Add()
                        {
                        }

                        public override void Delete()
                        {

                        }

                        public override void Get()
                        {

                        }

                        public override void Update()
                        {

                        }
                    }


                    class Program {

                        static void Main(string[] args)
                        {


                            MySql mySql = new MySql();
                            mySql.Add();
                            

                                
                        }

                    }

                }


##collectionS##############################################################################################################################################################################################################################################

                C# dilinde, bir sınıfın alanlarına erişimi kontrol etmek ve bu alanlara değer atamak için genellikle property'ler kullanılır. Property'ler, sınıfın dışındaki kodun sınıf içindeki verilere güvenli ve kontrol edilmiş bir şekilde erişmesini sağlar. Property'ler, genellikle sınıfın dışındaki kodun sınıfın içindeki verilere okuma ve yazma işlemleri gerçekleştirmesine izin verir.

                Temel Property Tanımı:
                Property, genellikle bir alanın okunması ve yazılmasını kontrol eden bir çift metottur. Aşağıda basit bir property tanımı örneği bulunmaktadır:

                public class Person
                {
                    // Private bir alan (field)
                    private string _name;

                    // Public bir property
                    public string Name
                    {
                        get { return _name; } // Okuma işlemi
                        set
                        {
                            if (!string.IsNullOrEmpty(value))
                            {
                                _name = value; // Yazma işlemi
                            }
                            else
                            {
                                Console.WriteLine("Name cannot be null or empty.");
                            }
                        }
                    }
                }
                Bu örnekte, Person sınıfında _name adında bir private alan ve Name adında bir public property bulunmaktadır. Name property'si hem okuma (get) hem de yazma (set) işlemlerini kontrol etmektedir.

                Property Kullanımı:
                Ardından, bu property'yi kullanmak için şu şekilde bir örnek yapabiliriz:


                class Program
                {
                    static void Main()
                    {
                        Person person = new Person();

                        // Property'yi kullanma
                        person.Name = "John"; // Yazma işlemi
                        Console.WriteLine($"Name: {person.Name}"); // Okuma işlemi
                    }
                }
                Bu örnekte, Person sınıfından bir nesne oluşturulmuş ve Name property'si hem yazılmış (set), hem de okunmuş (get). Property içinde yapılan kontrol, adın boş veya null olmamasını sağlar.

                Property'ler, nesne yönelimli programlamada sıkça kullanılır ve sınıfın dışındaki kodun sınıfın içindeki verilere güvenli bir şekilde erişmesine olanak tanır. Ayrıca, bir property'nin altındaki gerçek işlevselliği saklamak için metotlar içerebilirler.

                User
                c#da collectionsları detaylı şekilde anlatabilir misin
                ChatGPT
                Evet, tabii ki! C# dilinde, Collections (Koleksiyonlar) genel olarak gruplandırılmış verileri yönetmek için kullanılan veri yapılarıdır. .NET Framework içerisinde birçok farklı koleksiyon sınıfı bulunmaktadır. Bu koleksiyon sınıfları, verileri depolamak, sıralamak, filtrelemek ve genel olarak işlemek için kullanılır. İşte C# dilinde sıkça kullanılan bazı koleksiyon türleri:

                1. List<T>:
                List<T> sınıfı, dinamik bir dizi olarak düşünülebilir ve belirli bir türdeki öğeleri içerir.


                using System;
                using System.Collections.Generic;

                class Program
                {
                    static void Main()
                    {
                        // List<T> kullanımı
                        List<string> names = new List<string>();
                        
                        // Öğe ekleme
                        names.Add("Alice");
                        names.Add("Bob");
                        names.Add("Charlie");

                        // Öğeleri gezme
                        foreach (var name in names)
                        {
                            Console.WriteLine(name);
                        }
                    }
                }


                2. Dictionary<TKey, TValue>:
                Dictionary<TKey, TValue> sınıfı, anahtar-değer çiftleri içeren bir koleksiyondur.


                using System;
                using System.Collections.Generic;

                class Program
                {
                    static void Main()
                    {
                        // Dictionary<TKey, TValue> kullanımı
                        Dictionary<int, string> students = new Dictionary<int, string>();
                        
                        // Öğe ekleme
                        students.Add(1, "Alice");
                        students.Add(2, "Bob");
                        students.Add(3, "Charlie");

                        // Öğeleri gezme
                        foreach (var student in students)
                        {
                            Console.WriteLine($"Student ID: {student.Key}, Name: {student.Value}");
                        }
                    }
                }



                3. Queue<T>:
                Queue<T> sınıfı, birinci giren, birinci çıkan (First In First Out - FIFO) prensibiyle çalışan bir kuyruk yapısını temsil eder.


                using System;
                using System.Collections.Generic;

                class Program
                {
                    static void Main()
                    {
                        // Queue<T> kullanımı
                        Queue<string> queue = new Queue<string>();
                        
                        // Öğe ekleme
                        queue.Enqueue("Apple");
                        queue.Enqueue("Banana");
                        queue.Enqueue("Cherry");

                        // Öğeleri çıkarma
                        while (queue.Count > 0)
                        {
                            Console.WriteLine(queue.Dequeue());
                        }
                    }
                }



                4. Stack<T>:
                Stack<T> sınıfı, son giren, ilk çıkan (Last In First Out - LIFO) prensibiyle çalışan bir yığın yapısını temsil eder.


                using System;
                using System.Collections.Generic;

                class Program
                {
                    static void Main()
                    {
                        // Stack<T> kullanımı
                        Stack<string> stack = new Stack<string>();
                        
                        // Öğe ekleme
                        stack.Push("Apple");
                        stack.Push("Banana");
                        stack.Push("Cherry");

                        // Öğeleri çıkarma
                        while (stack.Count > 0)
                        {
                            Console.WriteLine(stack.Pop());
                        }
                    }
                }


..............................................................................................................................................................................................................................................................................................................................................................


        namespace appConsole
        { 

            class Program {

                static void Main(string[] args)
                {

                    ArrayList arraylist = new ArrayList();


                    referancemi(arraylist);
                    foreach(var item in arraylist)
                    {
                        Console.Write(item); // eeee  aaaa... yazdırdı...
                    }
                        
                }

                public static void referancemi(ArrayList a)
                {
                    a.Add("eeee");
                    a.Add("aaaa...");

                }


            }

        }

        // yani tıpkı diziler gibi System.collections ile çalışanlarda referanceler ile çalışırlar... bir metota ben onu yolladığımda onu karşılayanda referans ve yolladığımın referanceını karşılıyor böylece değişim olursa kalıcı değişim oluyor... 
        // arraylistler nesne alırlar... sayı vs gönderebiliriz ama c#da sayılar vs her şey zaten nesne mantığı ile çalışır. 
        // hem string hem int vss istenen nesneleri yollayabiliriz karmaşık şekilde tutabiliriz... yeterki nesne yolla... ama c#da zaten her veri nesne olarak geçiyor... her şey class'tan türüyor. ama heapta ve stack'te tutulanlar olarak ayrılıyorlar...



..............................................................................................................................................................................................................................................................................................................................................................
c#da string'de int gibi davranır... bir tek java ile fark odur...
..............................................................................................................................................................................................................................................................................................................................................................


            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using System.Threading.Tasks;
            using System.Data.SQLite;
            using System.Collections;
            using System.Collections.Specialized;


            namespace appConsole
            { 

                class Program
                {
                    static void Main(string[] args)
                    {
                        
                        ArrayList arraylist = new ArrayList();
                        arraylist.Add(1);arraylist.Add(2);arraylist.Add(3);
                        foreach (int i in arraylist) {
                            Console.WriteLine(i);
                        }

                        Console.WriteLine(arraylist[1]); // 2. veriyi görebiliriz... arraylist[index] ile istenen veriyi get edebiliriz...
                        Console.WriteLine(arraylist.Capacity); // 3 eleman ekledik mesela kapasitesini 4 yaptı. yeni bir elemana yer bırakıyor hepp
                        Console.WriteLine(arraylist.Count); // 3 eleman var diyorr...



                        ArrayList arr = TTT(); // metot içerisinde bir arraylist referansı oluşur metot biter return eder ama referansı bellekte tutulduğu için garbage collector onu silmez...
                        
                        foreach (var item in arr)
                        {
                            Console.WriteLine(item);

                        }
                        arraylist.Add(11);
                        arraylist.Add((int) 1);
                        arraylist.Add((int) 2);
                        arraylist.Add((int) 3);
                        arraylist.Add(4);
                        arraylist.Sort(); // kalıcı değişim yapar önce küçükten büyüğe sıralayıp sonra return etmez..
                        arraylist.Reverse(); // terse çevirir...  kalıcı değişim yapar...


                        foreach(var i in arraylist)
                        {
                            Console.WriteLine(i);
                        }


                        Console.WriteLine("........");

                        StringCollection aaaa = ORN4();
                        foreach(var item in aaaa)
                        {
                            Console.WriteLine(item);
                        }


                        ORN5();
                        ORN6();
                        ORN7();
                        ORN8();
                        ORN9();





                    }

                    public static ArrayList TTT()
                    {


                        ArrayList arraylist = new ArrayList();
                        arraylist.Add((int)1);
                        arraylist.Add((int)2);
                            arraylist.Add((int)3);
                            arraylist.Add((int)4);
                            arraylist.Add((int)5);
                        return arraylist;
                    }


                    public static StringCollection ORN4()
                    {
                        StringCollection sc = new StringCollection(); // sadece string değerlerden oluşacaksa collection sadece string taşıyacaksa kullanmak mantılıdır...
                        // neden kullanırız çünkü  daha performanslıdır eğer hepsi String olacaksa veriler...

                        sc.Add("a");sc.Add("b");sc.Add("c");sc.Add("d");



                        return sc;


                    
                    }

                    static void ORN5()
                    {

                        StringDictionary stringDictionary = new StringDictionary(); // String değerler taşıyan bir yapı kurabiliriz... key ve value ilişkisi olur dict yapısı kurabiliriz böylecek...
                        stringDictionary.Add("a", "b");
                        stringDictionary.Add("c", "d");
                            stringDictionary.Add("e", "f");
                        
                        foreach(var item in stringDictionary.Keys) // a c e
                        {
                            Console.WriteLine(item);
                        }
                        foreach(var item in stringDictionary.Values) // b d f 
                        {
                            Console.WriteLine(item); 
                        }
                        Console.WriteLine(stringDictionary["a"]); // b
                        Console.WriteLine(stringDictionary["c"]); // d


                    }

                    public static void ORN6() // lifo... last int first out... yığın çamaşır yığını gibi...
                    {

                        Stack stack = new Stack();  
                        stack.Push("a");
                        stack.Push("b");
                            stack.Push("c");
                        while(stack.Count > 0)
                        {
                            Console.WriteLine(stack.Pop()); // c b a yazdırır...

                        }

                    }

                    public static void ORN7()
                    {

                        Queue queue = new Queue();
                        queue.Enqueue("a");
                            queue.Enqueue("b");
                            queue.Enqueue("c");
                        queue.Enqueue("d");

                        while (queue.Count > 0)
                        {

                            Console.WriteLine(queue.Dequeue()); // a b c d


                        }
                    }


                    public static void ORN8()
                    {
                        Hashtable hashtable = new Hashtable(); // object tiplerin hızla depolanmasını ve hızla çekilmesini sağlayan yapıdır... hız konusunda iyidir... dict mantığı kullanır...
                        hashtable.Add("a", "b");
                        hashtable.Add("c", "d");
                        hashtable["e"] = true;

                        foreach (var item in hashtable.Keys)
                        {
                            Console.WriteLine(item);


                        }
                        foreach (var item in hashtable.Values)
                        {
                            Console.WriteLine(item);


                        }

                        Console.WriteLine(hashtable["a"]);
                        Console.WriteLine(hashtable["c"]);

                    }


                    public static void ORN9()
                    {
                        Console.WriteLine("...................");
                        Dictionary<int,string> dictionary = new Dictionary<int,string>(); // int keyler ve string keyler olacak demektir... dict yapısı ve generic değildir tipi kendimiz belirleriz...
                        dictionary.Add(1, "emre");
                        dictionary.Add(2, "ford");
                        dictionary.Add(3, "bmw");

                        foreach (var item in dictionary)  // hem keyi hem value'yi elde edebiliriz...
                        {
                            Console.WriteLine(item.Key);
                            Console.WriteLine(item.Value);

                        }
                        Console.WriteLine(dictionary[1]); // keyi verir valueyi alabiliriz...
                        dictionary[1] = "MAX"; // kalıcı değişim sağlama yapabiliriz...
                        Console.WriteLine(dictionary[1]); // key ile valueyi aldık...
                        Console.WriteLine(dictionary.ContainsKey(45)); // yani 45 anahtarı var mı yok mu arama yapabiliriz true veya false döner burada false dönecek..
                        Console.WriteLine(dictionary.ContainsValue("bmw")); // bmw olan value var mı bakar ve vardır true döner tüm valueleri tarar aranan valueye göre true false döner...




                    }


                    class User
                    {            public int Id { get; set; }
                        public string FirstName { get; set; }
                        public string LastName { get; set; }

                        public override string ToString()
                        {
                            return Id + " " + FirstName + " " + LastName; // eğer bir Console.WriteLine() içerisine girerse bu class'tan türemiş nesne bu değeri return edecek yapı...
                        }
                    }

                    public static void ORN10()
                    {
                        
                        List<User> users = new List<User>();
                        users.Add(new User { Id = 1, FirstName = "emre", LastName = "aytas"}); // Property ile tanımlanmış ise class'ın değerleri new class{} gibi bir yapı ile atama yapabiliriz... 
                        users.Add(new User { Id = 2, FirstName = "TTT", LastName = "YYY" });
                        users.Add(new User { Id = 3, FirstName = "Ford",LastName = "Focus" });
                        Console.WriteLine(users.Contains(users[0])); // eğer içeriyorsa True verir yoksa false verir...
                        Console.WriteLine(users[0].ToString()); // böylede ToString kullanabiliriz...
                        Console.WriteLine(users[1]); // ToString metotu içeriğini return edecek...
                        


                        foreach (var item in users)
                        {

                            Console.WriteLine(item.Id + " "+ item.FirstName + " " + item.LastName);


                        }

                        List<User> users1 = new List<User>()
                        {
                        new User { Id = 1, FirstName = "emre", LastName = "aytas"},
                        new User { Id = 2,FirstName = "TTT", LastName = "YYY"},
                        new User { Id = 3, FirstName = "Ford",LastName = "Focus" }

                        }; // direkt olarak atama almış hali ile başlatabiliriz...
                        // buda gayet geçerli bir kullanım...

                        var yenikullanici = new User();
                        yenikullanici.Id = 1;
                        yenikullanici.FirstName = "memo";
                        yenikullanici.LastName = "awp";
                        users1.Add(yenikullanici);
                        users1.AddRange(users); // başka bir aynı tip değerler taşıyan list ekleyebiliriz...
                        Console.WriteLine(users1.Contains(yenikullanici)); // eğer varsa True yoksa False return eder...
                        Console.WriteLine(users1.Count); // buradan kaç eleman olduğunu görebiliriz...
                        var index = users1.IndexOf(yenikullanici); // hangi indexte ise getirir.. yoksa -1 verir...
                        var index1 = users.LastIndexOf(yenikullanici); // sondan okumaya başlar ve indexi getirir yoksa -1 getirir...
                        
                        users1.Insert(1, new User { Id = 5,FirstName = "emre",LastName = "Ford"}); // istediğimiz indexe ekleme yapabiliriz .Insert() ile kalıcı değişim yapar... 
                        Console.WriteLine($" users1 de yenikullanici {index}. indexte idi....");  // $"{AA} {BB}"   gibi bir şekilde kullanım yapabiliriz...



                    }


                }

            }

########################################################################################################################################################################################################################################################################################################################################################################################################################################################################################

hatanın en kötü ihtimalle Main içine düşmeden yakalanması gerekir... ve hiyerarşik şekilde dizilmeliidr hatalar... finally her zaman çalışır hata olsa da olmasa da... mesele try catch finally bir while içinde olsun tryde break görsün ona rağmen çalışır finally...
Exception ve error farklıdır... sistem hatalarının ve açıklarının yüzde 80i Exceptionlar yüüzden çöker...
finally genel olarak açık dosya ve veritabanı kapatmak için kullanılır...


                using System;
                using System.Collections.Generic;
                using System.Linq;
                using System.Text;
                using System.Threading.Tasks;

                namespace appConsole
                {
                    class class1
                    {

                        static void Main(string[] args)
                        {

                            while
                                (true)
                            {

                                try
                                {
                                    break;
                                }
                                catch (Exception ex)
                                {


                                }
                                finally // döngü break görse bile finally çalışır... ve sonra döngüden çıkılır...
                                {
                                    Console.WriteLine("aaaa");
                                }


                            } 

                            try
                            {
                                aaaa();
                            }catch (Exception ex)
                            {
                                Console.WriteLine(ex);
                            }
                            finally // 
                            {
                                Console.WriteLine("aaaa");
                            }




                        }


                        public static void aaaa()
                        {

                            throw new Exception("HELLO"); // throw new HataTürü(mesaj); yapısı ile hata fırlatabiliriz... 

                        }


                    }
                }


####multithreading############################################################################################################################################################################################################################################

                    using System;
                    using System.Collections.Generic;
                    using System.Linq;
                    using System.Text;
                    using System.Threading.Tasks;
                    using System.Data.SQLite;
                    using System.Collections;
                    using System.Threading; // bunu çağırmak lazım... hem thread üretmek hemde sleep için...

                    namespace appConsole
                    { 

                        class Program {

                            static void Main(string[] args)
                            {

                                Thread mainThread = Thread.CurrentThread;
                                mainThread.Name = "Main Thread";
                                Console.WriteLine(mainThread.Name);

                                /*
                                CountDown();
                                CountUp();
                                
                                Main Thread
                    Time #1:10 Seconds
                    Time #1:9 Seconds
                    Time #1:8 Seconds
                    Time #1:7 Seconds
                    Time #1:6 Seconds
                    Time #1:5 Seconds
                    Time #1:4 Seconds
                    Time #1:3 Seconds
                    Time #1:2 Seconds
                    Time #1:1 Seconds
                    Time #1:0 Seconds
                    timer #1 is complete...
                    Time 21:0 Seconds
                    Time 21:1 Seconds
                    Time 21:2 Seconds
                    Time 21:3 Seconds
                    Time 21:4 Seconds
                    Time 21:5 Seconds
                    Time 21:6 Seconds
                    Time 21:7 Seconds
                    Time 21:8 Seconds
                    Time 21:9 Seconds
                    Time 21:10 Seconds
                    timer #2 is complete...


                                */ // Threadsiz kullanım bu şekilde sırası ile çalışır Thread kullanırsak eğer o zaman iş değişir.

                                Thread thread1 = new Thread(CountUp);
                                Thread thread2 = new Thread(CountDown);

                                thread1.Start(); // başlatır ve aşağı satıra geçirir kodu bu yüzden thread1 çalışırken thread2'de çalışmaya başlayabilir...
                                thread2.Start();

                                /*
                                Main Thread
                    Time 21:0 Seconds
                    Time #1:10 Seconds
                    Time #1:9 Seconds
                    Time 21:1 Seconds
                    Time #1:8 Seconds
                    Time 21:2 Seconds
                    Time #1:7 Seconds
                    Time 21:3 Seconds
                    Time #1:6 Seconds
                    Time 21:4 Seconds
                    Time 21:5 Seconds
                    Time #1:5 Seconds
                    Time 21:6 Seconds
                    Time #1:4 Seconds
                    Time #1:3 Seconds
                    Time 21:7 Seconds
                    Time #1:2 Seconds
                    Time 21:8 Seconds
                    Time 21:9 Seconds
                    Time #1:1 Seconds
                    Time 21:10 Seconds
                    Time #1:0 Seconds
                    timer #2 is complete...
                    timer #1 is complete...

                                
                                */






                                Console.ReadKey();


                            }

                            public static void CountDown()
                            {

                                for (int i = 10; i >= 0; i--)
                                {

                                    Console.WriteLine("Time #1:" + i + " Seconds");
                                    Thread.Sleep(1000); // 1000 milisaniye...

                                }
                                Console.WriteLine("timer #1 is complete...");
                            }

                            public static void CountUp()
                            {

                                for (int i = 0; i <= 10; i++)
                                {

                                    Console.WriteLine("Time 21:" + i + " Seconds");
                                    Thread.Sleep(1000); // 1000 milisaniye...

                                }
                                Console.WriteLine("timer #2 is complete...");
                            }


                        }


                        

                    }

// yani işleri metotlara bölerek biz threadlere metotları vererek işleri bölebiliriz. thread başlarsa direkt olarak çalışır ve program aşağı satırları okumaya başlar... o anda o thread'da çalışır halde kalır...



################################################################################################################################################################################################################################################

// Main sadece bir tane olur ve programın çalışması için gerekli olan o metottur ana metottur...
// C# dilinde bir uygulama sadece bir tane Main metodu içerebilir. Bu metot, programın başlangıç noktasını temsil eder ve programın çalışmasına başladığı yerdir. Main metodu, static olarak işaretlenmiş ve genellikle bir sınıf içinde yer alır.
// String ile string arasında bir fark yoktur... ikiside aynıdır referans bilmem ne vs vs... 

            bool dogrumu = false;

            while (dogrumu)
            {





            }
            if (dogrumu)
            {

                    
            }else if (dogrumu) { 
            
            
            }else { Console.WriteLine("FORD ");
            }

// değişkenler verileri tutan yapılardır. her sınıf bir blok içerisindedir.
// bir class içerisinde tanımlananlar aslında o class'a özgüdür...
// c#da değişkenler rakamla vs başlayamaz... metinsel ifadeler falan mantıklıdır. ve dikkat etmemiz gerekn bir nokta  class isimleri büyükle başlar fonkisyonlar vve değişkenler ise küçükle başlar yeni kelimede o kelimenin baş harfi büyür.
class: EmreAraba   metot: gitAraba() değişken: arabaMotor = 12; gibi...
// değişken bir class içerisinde kullanıldı ise tüm class ona erişebilir.

// stack ve heap dene iki bölge var bellekte ana bölgede ramle bellek arasında fark var stack ve heap olarak. değer tipliler stackte tutulur referance tipliler ise heap alanında tutulur sınıflara ait nesneler heapte tutulur.
// string dışındakiler stack'te tutulur. string ise heapte.

// sabit ve değişken farkı nedir... const mesela değişmez ve değeri tanımlanırken atanmalı.
          const int deger2 = 11;  gibi.
          int deger1 = 11; 
          deger1 = 12; // sabit değildir değişkendir const değilse... porgramda zamanla değişebilir.

// c# dilinde bir veriye double int float vs değer verilmediyse eğer o zaman 0 olur string ise null olur vs vs mesela class ürettik emre diye emre emre1; dedik emre1 nulldır. default olarak 0 veya null ataması yapılır...
//             int[] matris1 = new int[100]; dizi oluşturma böyle yapılır.

// string bir referans türüdür, yani değer tipleri gibi doğrudan değeri saklamaz. Bunun yerine bellekte bir referans saklar ve bu referans, metni içeren bellek bölgesini gösterir.
     

        public static int toplama(int a)
        {
            return a;
        }
        public static int toplama(int a,int b)
        {
            
            return a + b; 
        }
        // ikisinide aynı anda kullanabiliriz gönderilen verilere göre hangi metotun çalışacağını ise c# belirler buna method overloading denir...
        mesela toplama(5) dersem en üstteki çalışır toplama(10,8) dersen alttaki çalışır...



class isimler
{


    private int deger;
    private String name;
    private isimler isimlersonraki = null;  // burada mesela her nesne oluştuğunda otomatik olarak null olacak...

    
    public isimler(int deger, string name)
    {   
        this.deger = deger;
        this.name = name;
    }
         public isimler() // default constructor'dur bu mesela...   iki tane constructor var bunada constructor overloading denir... parametrelere göre hangisi çlaışacak c# belirler bunu
    {   
        
    }
     

}


// c# dilinde veri tipleri ilkel değildir. hepsi bir nesnedir.
// her sınıf soyut bir veri yapısıdır.
// /**/  buda uzun veri sistemi.
// common type sistem = ortak veri modeli.
// import yerine using kullanırız...

/*
            Console.Write("Kullanici adi giriniz: ");
            string isim = Console.ReadLine();
            Console.WriteLine(isim);

*/ consoldan veri alma böyle yapılır string için... 

// c# dilinde global değişken yoktur her veri bir class'a özgü olmalıdır. her metot her değişken bir class'a bağlı olmalıdır.
// değişkenler rakamlarla başlamaz arada boşluk olamaz para simgeleri olabilir ! & vs gibi karakterler olmaz.
// değişkenlerde iki tip vardır değer ve referance tipleri.  stack ve heap bölgeleri vardır bellekte.   ramda stack ve heap vardır.  referance tipleri heapte tutulur.   classla başlayan yapılar heapte tutulur string dışı değerler stackte tutulut değer tiplidir çünkü...
// charda aslında sayısal olarak tutar ama biz onu karakterlere çeviririz dil ile.

            Console.Write("");  // yazar ve alt satıra geçirmez...
            Console.WriteLine(""); // yazar ve alt satıra geçirir otomatik olarak \n eklenir...

            Console.Write( 14 + " " +  4); demek aslında append demek...  tüm değerleri string yapar eğer +'nın içerisinde string varsa ve sırası ile hepsini append eder...

string yazi1 = "emre" + 15; hata vermez... 15 string'e çevrilir ve + ile append edilir..
string yazi2 = 15; hata verir...   

// encapsulation demek nesnenin vcerilerine nesne.  şeklinde ulaşmayı private ile kısıtlamak demektir...     nesnenin verilerine nesnenin metotları ile ulaşmak kontrollü şekilde... getter setter kullanırız genel olarak. 



ctrl + class'ın üstüne tık ile içerisine gidebilir bilgileri görebiliriz...

..............................................................................................................................................................................................................................................................................................................................................................
            C# dilinde, bir sınıfın alanlarına erişimi kontrol etmek ve bu alanlara değer atamak için genellikle property'ler kullanılır. Property'ler, sınıfın dışındaki kodun sınıf içindeki verilere güvenli ve kontrol edilmiş bir şekilde erişmesini sağlar. Property'ler, genellikle sınıfın dışındaki kodun sınıfın içindeki verilere okuma ve yazma işlemleri gerçekleştirmesine izin verir.

            Temel Property Tanımı:
            Property, genellikle bir alanın okunması ve yazılmasını kontrol eden bir çift metottur. Aşağıda basit bir property tanımı örneği bulunmaktadır:

         
            public class Person
            {
                // Private bir alan (field)
                private string _name;

                // Public bir property
                public string Name
                {
                    get { return _name; } // Okuma işlemi
                    set
                    {
                        if (!string.IsNullOrEmpty(value))
                        {
                            _name = value; // Yazma işlemi
                        }
                        else
                        {
                            Console.WriteLine("Name cannot be null or empty.");
                        }
                    }
                }
            }
            Bu örnekte, Person sınıfında _name adında bir private alan ve Name adında bir public property bulunmaktadır. Name property'si hem okuma (get) hem de yazma (set) işlemlerini kontrol etmektedir.

            Property Kullanımı:
            Ardından, bu property'yi kullanmak için şu şekilde bir örnek yapabiliriz:

        
            class Program
            {
                static void Main()
                {
                    Person person = new Person();

                    // Property'yi kullanma
                    person.Name = "John"; // Yazma işlemi
                    Console.WriteLine($"Name: {person.Name}"); // Okuma işlemi
                }
            }
            Bu örnekte, Person sınıfından bir nesne oluşturulmuş ve Name property'si hem yazılmış (set), hem de okunmuş (get). Property içinde yapılan kontrol, adın boş veya null olmamasını sağlar.

            Property'ler, nesne yönelimli programlamada sıkça kullanılır ve sınıfın dışındaki kodun sınıfın içindeki verilere güvenli bir şekilde erişmesine olanak tanır. Ayrıca, bir property'nin altındaki gerçek işlevselliği saklamak için metotlar içerebilirler.

..............................................................................................................................................................................................................................................................................................................................................................

        C# dilinde iki stringin aynı referansı taşıyıp taşımadığını kontrol etmek için == operatörü değer karşılaştırması yapar, yani iki string'in içeriğini kontrol eder, referans karşılaştırması yapmaz. Yani == operatörü, stringlerin içeriğini kontrol eder.

        Örneğin:

        string isim1 = "emre";
        string isim2 = "emre";

        if (isim1 == isim2)
        {
            Console.WriteLine("İsimler eşittir.");
        }
        else
        {
            Console.WriteLine("İsimler eşit değildir.");
        }
        Yukarıdaki örnekte, isim1 ve isim2 string'leri aynı değeri taşıdığı için == operatörü true dönecektir.

        Ancak, C# dilinde referans karşılaştırması yapmak istiyorsanız object.ReferenceEquals metodunu kullanabilirsiniz:


        if (object.ReferenceEquals(isim1, isim2))
        {
            Console.WriteLine("İsimler aynı referansı taşıyor.");
        }
        else
        {
            Console.WriteLine("İsimler aynı referansı taşımıyor.");
        }
        Bu durumda, object.ReferenceEquals metodu, iki string'in aynı referansı taşıyıp taşımadığını kontrol eder. Ancak, genellikle string karşılaştırmalarında == operatörü daha yaygın olarak kullanılır.

..............................................................................................................................................................................................................................................................................................................................................................

string isim = "emre";
string isim2 = isim;  // buda emre olur ama referance yüüzden değil değer ataması yapılır burada. javadaki gibi değil..

        Araba araba1 = new Araba { Model = "Toyota" };
        Araba araba2 = araba1;

        araba1.Model = "Ford";

        Console.WriteLine(araba2.Model);  // Bu, "Ford" yazdırır çünkü class'lardan oluşan nesneler referancelerle çalışırlar...

..............................................................................................................................................................................................................................................................................................................................................................

    internal class Program
    {
        static void Main(string[] args)
        {

            class1 cs1 = new class1("aaa", "bbb", 111);

            degistir(cs1);
            Console.WriteLine(cs1.age); // bir yazdırdı...



        }

        public static void degistir(class1 b)
        {
            b.age = 1;
          
        }

    }

class'lar kendi oluşturduklarımız vs onlardan oluşan nesneler referanceleri ile çalışırlar... bu yüzden void metotta değişim oldu gönderdiğimiz nesnenin değeri kalıcı olarak değişti... bunun sebebi pointer mantığıdır. nesneler heap ve stack olacak şekilde referanslı veya referancesiz olarak saklanırlar. bizim oluşturduklarımız ile oluşanlarda referance mantığı işler...
classlar(kendimizin) ve arraylar referance mantığı ile çalışır diğerleri çalışsın istersek o zaman ref yapısını kullanırız...


..............................................................................................................................................................................................................................................................................................................................................................

break ve continue bağlı oldukları döngü için çalışırlar sadece bir döngü için çalışırlar...

for while do while hepsi için aynı neredeyse...

..............................................................................................................................................................................................................................................................................................................................................................

        static void Main(string[] args)
        {

            string[] isimler = new string[3];
            isimler[0] = "aaaa";
            isimler[1] = "bbbb";
            isimler[2] = "cccc";

            foreach (string i in isimler)   // önce tipi belirtiriz. sonra i deriz iterasyon yapacak yapıya. ve dönülecek yapı.
            {
                Console.WriteLine(i);
            }
        }

        // string yerine biz var yazabilirdik bir fark olmazdı ikiside çalışır...  
        // var = bu anahtar kelime ile değişken oluşturursak ve atamasını yaparsak var tarafından onun tipi belirlenir. pythondaki yapı ile aynı neredeyse...

C# programlama dilinde "var" bir değişkenin türünü belirlemeden önce, derleme zamanında türünün belirlenmesine izin veren bir anahtar kelimedir. "var" anahtar kelimesini kullanarak bir değişken tanımladığınızda, derleyici, değişkenin türünü sağlanan başlatma değerinden çıkarır.

Örneğin:

var sayi = 42; // sayi değişkeni int türünde bir değişkendir.
var metin = "Merhaba, Dünya!"; // metin değişkeni string türünde bir değişkendir.
Bu durumda, derleyici, sayi değişkenini int ve metin değişkenini string olarak anlar. Ancak, "var" kullanılarak tanımlanan değişkenlerin başlangıç değeri ile türü belli olmalıdır, çünkü derleyici, başlangıç değeri üzerinden türü çıkarır. Ayrıca, bir kez atanmış bir değişkenin türü değiştirilemez.
..............................................................................................................................................................................................................................................................................................................................................................


































################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################

FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM FORM

form uygulamalarında static değerler ve arraylistler ile çalışmak gerekir çünkü form static değerlere ulaşabiliyor...
windows form() c# items olanı seçeriz...
.net 4.7.2 kullanacağız genel olarak...
// events kısmından ne gibi durumlarda ne gibi işlemler yapılacak bunu belirleyebiliriz...
this.Close(); ile açık olan form kapatılır... ve böylece normalde bekleyen kod okuma formda bekleyen okuma devam eder...

.Show() ile .ShowDialog() arasında şu fark vardır. geri döndürme izni yoktur biri kapanmadan diğerine geçişe izin vermez... 
  // bir form kapatılmadan diğer form'a geri dönülmesin istersek ShowDialog() kullanabiliriz geçiş olabilsin istersen .Show() kullanırız ve biter...

this.Hide() ile ilgili pencereyi gizleyebiliriz... arka planda çalışmaya devam eder form kapanmaz... uygulama çalışmaya devam etsin ama gizlensin istersek... mesela keylogger için...

form1.ActiveForm.Close() demek ise aktif olan formu kapa demek...

Application.Exit() komple uygulamayı kapatır...

form1.Text = "sol üstteki isim değişti...";
  veya this.Text = ".....";   ile geçerli olanın ismini değiştirebiliriz...

formun events kkısmında yapılan işleme göre aksiyon belirleyebiliriz... şimşek ikonlu olan events kısmı...

form'un load eventi çok önemli...



........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

C# Windows Forms uygulamalarında kullanılan birçok form olayı (event) bulunmaktadır. Her olay, belirli bir durumu, etkileşimi veya durumu işlemek üzere çağrılır. Aşağıda, yaygın olarak kullanılan bazı form olayları ve genel kullanım amaçları hakkında bilgi bulunmaktadır:

Load:

Form yüklendiğinde tetiklenir.
Form'un başlangıç durumuyla ilgili işlemler için kullanılır.

private void Form1_Load(object sender, EventArgs e)
{
    // Form yüklendiğinde yapılacak işlemler
}
Closing:

Form kapatılmadan önce tetiklenir.
Form kapatma işlemi iptal edilebilir.

private void Form1_FormClosing(object sender, FormClosingEventArgs e)
{
    // Form kapatılmadan önce yapılacak işlemler
    // e.Cancel = true; // Form kapatma işlemi iptal edilir
}
Closed:

Form kapandığında tetiklenir.
Form kapandığında yapılacak işlemler için kullanılır.

private void Form1_FormClosed(object sender, FormClosedEventArgs e)
{
    // Form kapandığında yapılacak işlemler
}
Activated:

Form, aktif duruma geldiğinde tetiklenir.
Formun kullanıcı tarafından etkileşime hazır olduğu durumlar için kullanılır.

private void Form1_Activated(object sender, EventArgs e)
{
    // Form aktif duruma geldiğinde yapılacak işlemler
}
Deactivate:

Form, pasif duruma geldiğinde tetiklenir.
Formun kullanıcı tarafından etkileşime kapandığı durumlar için kullanılır.

private void Form1_Deactivate(object sender, EventArgs e)
{
    // Form pasif duruma geldiğinde yapılacak işlemler
}
Resize:

Form boyutu değiştiğinde tetiklenir.
Formun boyutu değiştiğinde yapılacak işlemler için kullanılır.

private void Form1_Resize(object sender, EventArgs e)
{
    // Form boyutu değiştiğinde yapılacak işlemler
}
KeyDown ve KeyUp:

Bir tuşa basıldığında (KeyDown) veya serbest bırakıldığında (KeyUp) tetiklenir.
Klavye olaylarını yakalamak için kullanılır.

private void Form1_KeyDown(object sender, KeyEventArgs e)
{
    // Bir tuşa basıldığında yapılacak işlemler
}

private void Form1_KeyUp(object sender, KeyEventArgs e)
{
    // Bir tuş serbest bırakıldığında yapılacak işlemler
}
Bu olaylar, bir formun yaşam döngüsü, boyut değişiklikleri, klavye etkileşimleri ve formun kapatılması gibi birçok senaryoda kullanılır. Projeye bağlı olarak, farklı olaylar da kullanılabilir ve bu olaylar formun davranışını özelleştirmek için güçlü araçlar sunar.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

eğer from üzerine gelir çift ttıklarsak bu metot gelir kod kısmına. bu nedir form açılmadan önce çalışacak metottur mesela veritabanından verileri çekip listede yazdırmak için açılıdğında hazır olsun diye...
veya ekranda göstermek istediğimiz bir componenti gösterebilir veya gizleyebiliriz...

        private void Form1_Load(object sender, EventArgs e) // form yüklenirken çalışan metot mesela veritabanından ürünleri çekip açılıdığında gözüksün die hazır edebiliriz...
        {


        }   // form üstüne çift tıklayarak elde ederiz... veya form üzerinde sağtık + events kısmında önemli metotları işleyebiliriz...
        // events kısmında Load var oradan ne işlem yapılacağını belirleyebiliriz...  
        // events kısmı properties kısmında şimşek ikonu...

        // buda buton ekleyip üzerine çift tıklayınca ortaya çıkan detay... istediğimiz değerleri girebiliriz...

        private void button1_Click(object sender, EventArgs e)
        {


        }

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

        static void Main(string[] args)
        {
            Thread formThread = new Thread(() =>
            {
                // Formu başka bir thread üzerinde çalıştır
                new Form1().ShowDialog();
            });

            // Thread'i başlat
            formThread.Start();

            Console.WriteLine("LETS GOOO");





        }

// Thread ile form çalıştırma özelliği böylece form çalışır açık kalır ve sonrasında ise kod alt satıra geçer okumaya devam eder normalde c#da kod açık kalan form'da kapanana kadar kalır alt satıra geçebilir...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

            comboBox1.Items.Add("a");

            foreach (var item in comboBox1.Items)
            {
                Console.WriteLine(item);
            }

comboBox1 eleman ekleme ve elemanlarını yazdırma...  comboadi.Items ile elemanlara ulaşabiliriz. ve comboadi.Items.Add() ile ekleme yapabiliriz. bu özellik ile biz istersek 

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

form'un events kısmında Form closed kısmındaki eventler ile form kapatılırken ne olacağını seçebiliriz...

            MessageBox.Show("EKRAN KAPATILDI...");
            // bu şekilde bir messagebox kullanabiliriz.

MessageBox() kod okumasını kendinde tutar bu yüzden tamam'a basmadan alt satıra geçirmeme yapabilir bunun için Thread kullanmak zorunda kalabiliriz...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

toolbox kısmında timer var... interval kaç milisaniyede bir atacağını belirtir...

        using System;
        using System.Collections.Generic;
        using System.ComponentModel;
        using System.Data;
        using System.Drawing;
        using System.Linq;
        using System.Text;
        using System.Threading.Tasks;
        using System.Windows.Forms;

        namespace ConsoleApp2
        {
            public partial class Form3 : Form
            {
                public Form3()
                {
                    InitializeComponent();
                }

                private void Form3_Load(object sender, EventArgs e) // form başlarken işlem yapar...
                {
                    timer1.Enabled = true;
                    timer1.Interval = 500;


                }

                private void timer1_Tick(object sender, EventArgs e) // Enabled = true olursa sürekli olarak zamanlayıcısına göre çalışır...
                {

                    Random random = new Random(); // rastgele değer üretmemizi sağlar...
                    this.BackColor = Color.FromArgb(random.Next(0,255), random.Next(0, 255), random.Next(1, 255));

                }

                private void Form3_KeyDown(object sender, KeyEventArgs e) 
                {

                    if(e.KeyCode == Keys.F4) // eğer f4 tuşuna basılırsa kapanacak...
                    {
                        this.Close();
                    }
                
                }

                private void Form3_KeyUp(object sender, KeyEventArgs e)
                {

                    if (e.KeyCode == Keys.Escape) // eğer f4 tuşuna basılırsa kapanacak...
                    {
                        MessageBox.Show("FORM KAPATILACAK", "UYARI!"); // ilki mesaj diğeri ise başlık messagebox için...
        ;                this.Close();
                    }



                }

                private void button1_Click(object sender, EventArgs e)
                {
                    DialogResult sonuc;
                    sonuc = MessageBox.Show("ÇIKMAK İSTER MİSİN", "UYARI",MessageBoxButtons.OKCancel);

                    if(sonuc == DialogResult.OK)
                    {
                        this.Close();
                    }

                } // diyaloğa göre ok veya cancel dedik dönen sonuca göre işlem yapabiliriz. ok mu bastı cancel mi?
            }
        }


........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

        private void button2_Click(object sender, EventArgs e)
        {

            if (MessageBox.Show("ÇIKMAK İSTER MİSİN", "UYARI", MessageBoxButtons.OKCancel,MessageBoxIcon.Error) == DialogResult.OK) 
            {
                this.Close();

            }


        }

// uyarı penceresi açar iconlu bir biçimce ve ok veya cancele basmaya göre işlem yapabiliriz...
// groupbox ile gruplama yapabiliriz...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................


namespace ConsoleApp2
{
    static class Program
    {

        public static ArrayList arrayList = new ArrayList();
        static void Main(string[] args)
        {

            Thread formThread = new Thread(() =>
            {
                // Formu başka bir thread üzerinde çalıştır
                new Form1().ShowDialog();
            });

            // Thread'i başlat
            formThread.Start();


        }
    }
}

// projenin başlayacağı class'ın staticc olması iyidir. ve şayet static değerler static arraylistler vs ile işlem yapmak önemlidir ki formlar bu verilere ulaşabilsin.


........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

int x = 1;
int y = 2;
(y,x) = (x,y); //  arka planda üç değişkenle işlem yapar aslında ama burada üçüncü değişken kullanmayız...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................



        private void domainUpDown1_SelectedItemChanged(object sender, EventArgs e)
        {

            for (int i = 0; i < 50; i++)
            {
                domainUpDown1.Items.Add(FontFamily.Families[i].Name); // içerisine nesne vermek lazım... sistemdeki fontlardan 50 tanesini domainupdowna ekledik.
               
            }

            domainUpDown1.Wrap = true; // liste sonunda ilk veya son öğeye ilerle...


        }

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

tarih ve saat seçimi için datetimepicker kullanırız..
Textbox'ta multiline izni verirsek satır satır yazma yapabilir...

        private void dateTimePicker2_ValueChanged(object sender, EventArgs e)
        {
            textBox1.Text ="İki tarih arasındaki gün: " + (dateTimePicker2.Value - dateTimePicker1.Value).Days.ToString();


        }

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

        private void button1_Click(object sender, EventArgs e)
        {
            if (!string.IsNullOrWhiteSpace(textBox2.Text))
            {
                int sayi = (int)Convert.ToUInt32(textBox2.Text);
                progressBar1.Maximum = sayi;
                for (int i = 0; i < sayi; i++)
                {
                    progressBar1.Value = i;

                }


            }
            else MessageBox.Show("SAYİ GİRNİZ...", "UYARİ");


        }

progressbar aslında ne kadar yüklendi yükleniyor eventi için kullanılır...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
menustrip ile biz istersek üst kısımdaki dosya vs vs işlemleri yapan barı ekleyebiliriz...
contextMenustrip sağ tık işlemleri için kullanılır sağ tık deriz ve istenen işlemleri yaptırabiliriz mesela kes kopyala yapıştır vs vs... contextMenustrip kısmından seçmemiz lazım ama bunun için... oreadan istenen menustrip'i seçeriz ve işlem yapabiliriz...
richtextBox ve metotları önemli...
toolstrip ekler üç noktaya sağ tıklar sonra insert standart items dersek sürekli kullanılan kısımları bize getirir...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................


    C# Windows Forms uygulamalarında TrackBar kontrolü, kullanıcının bir aralıktaki değeri seçmesine izin veren bir kontrol olarak kullanılır. İşte TrackBar kullanımına dair basit bir örnek:

    TrackBar Eklemek:

    Visual Studio'da bir form tasarımını açın.
    Araç Kutusu'nda "TrackBar" kontrolünü formunuza sürükleyip bırakarak ekleyin.
    TrackBar'ın özelliklerini (Name, Minimum, Maximum, Value vb.) tasarım zamanında veya kod içinde ayarlayabilirsiniz.
    Olay (Event) Eklemek:

    TrackBar'da değer değiştikçe bir olaya tepki verebilirsiniz. Bu genellikle Scroll veya ValueChanged olaylarıdır.
    Kod İle Olaya Tepki Verme:

    Aşağıda, bir TrackBar kontrolünün ValueChanged olayına tepki veren basit bir örnek bulunmaktadır.


    using System;
    using System.Windows.Forms;

    namespace TrackBarExample
    {
        public partial class Form1 : Form
        {
            public Form1()
            {
                InitializeComponent();
            }

            private void trackBar1_ValueChanged(object sender, EventArgs e)
            {
                // TrackBar'ın değeri değiştiğinde yapılacak işlemler
                int selectedValue = trackBar1.Value;
                label1.Text = "Selected Value: " + selectedValue.ToString();
            }
        }
    }
    Yukarıdaki örnekte, ValueChanged olayı kullanılarak TrackBar kontrolünün değeri her değiştiğinde label1 kontrolü güncellenir.

    Tasarım Zamanında Olay Ekleme:
    Visual Studio tasarım görünümünde, TrackBar kontrolüne sağ tıklayın.
    Özellikler penceresinden Events (Olaylar) sekmesine geçin.
    ValueChanged olayına çift tıklayarak olaya tepki verecek bir metot oluşturun.
    Oluşturulan metotun içine istediğiniz kodu ekleyebilirsiniz.
    Bu örnekte, ValueChanged olayına tepki vererek TrackBar'ın değerini bir Label kontrolüne yazdık. Bu temel bir örnek olup, TrackBar kontrolü kullanımını daha fazla özelleştirebilir ve ihtiyacınıza göre uyarlayabilirsiniz.

trackBar1.Minimum = 10;trackBar1.Maximum = 25;trackBar1.TickFrequency = 2;
 // min max artış belirleyebiliriz...
  
scroll diye bir eventi vardır... aktif etmek için dizayn modunda üzerine çift tıklarız ve işlem yapar böylece...

bir ekran üzerinde birden fazla ekran kullanabilelim istersek eğer o zaman tabcontrol kullanabiliriz... işimizi kolaylaştırır...
             tabControl1.SelectedTab = tabPage2; // ikinci taba geçer burada...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................


        private void button2_Click(object sender, EventArgs e)
        {
            OpenFileDialog.Title = "RESİM SECİNİZ...";
            // OpenFileDialog.ShowDialog();
            openFileDialog1.Filter = "(*.jpg)|*.jpg|(*.png)|*.png"; // sadece png ve jpg olanlar gelecek... sadece resim seçimi yapabilmek için kullanırız...
            OpenFileDialog1.FilterIndex = 1; 
            if (OpenFileDialog.ShowDialog() == DialogResult.OK)
            {
                pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;
                pictureBox1.Image = Image.FromFile(OpenFileDialog.FilaName);
               

            }



        }

butona basınca resim seçeceğiz ve resmi göstereceğiz...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................





........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................





################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################

SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL SQL
sql server microsoftun veritabanı sistemi... çok fazla kullanılır...
azure bir bulut sistemidir. buluta sql server koyarız ve global olarak herkes kullanabilir...
express web üzerinde ve küçük sunucularda çalışan ve uygulamaları geliştirmek ve üretmek için ideal olan bir sürümdür...
   devoloper ile express arasında kapasite farkı var ama çok önemli değil...

tools-> options -> all languages -> general-> word wrap ve line numbers önemli aktifleştir... word wrap taşarsa alt satıra geçirir komutta sorguda kopma olmaz... 

Visual studioda iş yükleri kısmında veri depolama ve işleme seçersek visual studio sql server kurar bize... sistemimize kurar bunu...

server type database engine ise veritabanı motoru yöneteceğiz demektir...

mesela sql server'ı pythonda javada vs kullanmak istersek bağlayıcı kullanmamız gerekebilir...

servername kısmına . veya (localhost) yazarak local veya tam sürüme bağlanabiliriz...
canlı bir sunucudaki veritabanına erişeceksek eğr o zaman server name kısmına ip adresi gireriz...
authentication kısmında sql server authentication yazarsak eğer login işlemlerini yapmmaız gerekir canlı sunucuya bağlanmak içindir...

server name kısmına (localhost) yazarak biz local sunucuya bağlanabiliriz.
log dosyası üzerinde yapılan tüm işlemler kaydedilir...

new database kısmında veritabanı max mb olduğunda ne yapılsın bunu belirleyebiliriz... mesela 64 mb olduğunda 64 mb 64 mb büyüt veya in percent ile yüzde kaç kaç büyüyeceğini belirleyebiliriz..
    Maximum file size belirlersek eğer mesela 100 mb dedik 100 mb olursa database o zaman daha fazla büyüme deriz databaseye...

database diagram demek ilişkisel tablolar arasındaki ilişkileri gösterir...

sql'de ingilizce karakter kullanamaya dikkat edin...

execute demek işlemleri uygula demek mesela insert vs değişim yaparsak lazım olur.

column demek kolon demek...
    bigint büyük değer alabilen int... 
    text metin dosyası var string yerine.
    bit demek 0 1 
    char veri tipi char array yapısı kurabiliriz char(10) ile mesela Unicode desteği yok.  char(10) dersek sürekli bellekte 10luk yer kaplar...
    nchar(10) başında n harfi olan veriler Unicode(tüm alfabeler çince arapça japonca vs vs) desteklidir. uluslararası tüm alfabeleri destekler demektir...
    varchar(50)  verinin boyutu kadar yer kaplar. 8000 maks karakter tutar... mesela isim yaparsak bazıları 5 harfli bazıları 8 kalan kısmı doldurma içindeki veri kadr alan kapla dersek.
    nvarchar(50) mesela varchar gibi ama Unicode desteği var...  dinamiktir varchar...
    text = belirtilenden az veri girilse bile girilen kadar yer tutar ne kadat gönderirseniz o kadar alan alır ama tabiki üst sınırı var ama yüksek...
    ntext = text ile aynı ama Unicode destekli...
    varchar(MAX) dersek (MAX demek alan sınırı yok istediğin kadar veri verebilirsin demektir...)

    başında n olan veriler Unicode destekli...

allow nulls tikli olursa null olabilir demektir id tiksiz olmalı...
bir tablonun üzerine gelir sağtık design dersek dizayn edebiliriz kolon ekleyip çıkarabiliriz vs vs...

table sağtık add table ile tablo ekleme yapabiliriz...
tablonun üzerinde sağtık edit top 200 rows dersek kendimiz eleman ekleyebiliriz...
tablo sağtık Select 1000 ilk 1000 satırı getir demek... bize sql kodunu otomatik verir...


bir sql dosyasına yükleme ekleme falan yaparsak eğer ne olur = tıpkı bir txtde tutulduğu gibi harddiskte yani bellekte kalıcı olarak tutulur böylece pc kapansa sistem kapansada veriler o .sql dosyasında .db dosyasında tutulur... fiziksel olarak saklanmaya başlar.

identity column olursa eğer otomatik artan olur mesela id...

............................................................................................................................................................................................................................................................................................................................................................................................................................................

PRIMARY key olan sutunların kombinasyonu aynı olamaz  unique olursa bir kolon o kolonda her değer farklı olmaz zorundadır...
PRIMARY key olan bir sutunda hiçbir değer null olamaz. unique null olabilir ama sadece bir tane null olabilir o sutunda.

    Primary Key (Birincil Anahtar):

    Birincil anahtar, bir tablodaki kayıtları benzersiz bir şekilde tanımlayan bir sütundur.
    Her birincil anahtar değeri eşsiz olmalıdır ve NULL değer içeremez.
    Bir tabloda sadece bir tane birincil anahtar tanımlanabilir.
    Birincil anahtar, veritabanındaki diğer tablolarla ilişkilendirilerek referans alınabilir.
    Örnek bir birincil anahtar tanımı:

    CREATE TABLE Customers (
        CustomerID INT PRIMARY KEY,
        FirstName VARCHAR(50),
        LastName VARCHAR(50)
    );
    Yukarıdaki örnekte CustomerID sütunu birincil anahtardır.

    Unique Key (Benzersiz Anahtar):

    Benzersiz anahtar, bir tablodaki kayıtları benzersiz bir şekilde tanımlayan bir sütundur.
    Bir benzersiz anahtar değeri eşsiz olmalıdır, ancak birincil anahtarın aksine NULL değer içerebilir.
    Bir tabloda birden fazla benzersiz anahtar tanımlanabilir.
    Bir benzersiz anahtar, birincil anahtara alternatif olarak kullanılabilir, ancak birden fazla benzersiz anahtar tanımlanabilir.
    Örnek bir benzersiz anahtar tanımı:


    CREATE TABLE Products (
        ProductID INT PRIMARY KEY,
        ProductCode VARCHAR(20) UNIQUE,
        ProductName VARCHAR(100)
    );
    Yukarıdaki örnekte ProductCode sütunu benzersiz bir anahtar olarak tanımlanmıştır.

    Her iki anahtar türü de veritabanı tasarımında veri bütünlüğünü sağlamak ve veri tekrarını önlemek için kullanılır. Birincil anahtar genellikle bir tablonun ana tanımlayıcısı olarak kullanılırken, benzersiz anahtarlar ise belirli bir sütunu benzersiz bir hale getirmek için kullanılır.

............................................................................................................................................................................................................................................................................................................................................................................................................................................

SQL'de VARCHAR ve TEXT veri tipleri, metin tabanlı verileri depolamak için kullanılır, ancak bazı farklılıkları vardır. İşte bu iki veri tipi arasındaki temel farklar:

Depolama Boyutu:

VARCHAR: Sabit bir maksimum karakter uzunluğunu belirtir, ancak gerçek veri uzunluğuna göre boyut alır. Örneğin, VARCHAR(255) ifadesi en fazla 255 karakterlik bir metni depolar, ancak gerçek metin boyutuna göre değişir.
TEXT: TEXT veri tipi, değişken karakter uzunluğu olan büyük miktardaki metin verisini depolamak için kullanılır. Genellikle çok büyük metin verilerini depolamak için kullanılır ve bir sınırlama olmadan büyük miktarda metni destekler.
Endeksleme:

VARCHAR: İndeksleme için kullanılabilir ve genellikle daha etkili bir arama performansı sunabilir.
TEXT: Eskiden beri bu tip alanlar üzerinde indeksleme sınırlıydı, ancak modern SQL Server sürümleri (örneğin SQL Server 2005 ve sonrası) bu konuda daha fazla esneklik sunar.
Karakter Seti ve Kollasyon:

VARCHAR: Karakter seti ve kollasyon belirtilerek oluşturulabilir, bu da metin sıralama ve karşılaştırma kurallarını belirlemenizi sağlar.
TEXT: Genellikle, bu tip bir alanın üzerinde karakter seti ve kollasyon belirtilmez. Ancak, modern veritabanı sistemlerinde bu belirtilmesi mümkün olabilir.
Veri Uzunluğu ve Performans:

VARCHAR: Uzunluğu belirtilmiş bir VARCHAR alanı, depolanan verinin gerçek uzunluğu kadar yer kaplar. Bu, bellek kullanımını optimize edebilir.
TEXT: Genellikle, çok büyük metin verilerini depolamak için kullanılır, ancak VARCHAR'a kıyasla daha fazla bellek kullanabilir.
Veri Manipülasyonu ve Fonksiyonlar:

VARCHAR: Metin manipülasyonu ve fonksiyonları daha esnek bir şekilde destekler.
TEXT: Bazı durumlarda, TEXT alanlarında çalışırken bazı metin manipülasyon fonksiyonları veya işlemleri VARCHAR alanlara göre daha karmaşık olabilir.
Özetle, VARCHAR ve TEXT veri tipleri arasındaki temel farklar, depolama boyutu, endeksleme, karakter seti ve kollasyon belirleme, veri uzunluğu ve performansla ilgilidir. Hangi veri tipini kullanacağınız, projenizin ihtiyaçlarına ve veri kullanım senaryolarına bağlı olacaktır. Çoğu durumda, VARCHAR tercih edilir, ancak büyük metin verileri için TEXT de uygun bir seçenektir.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................


    Microsoft SQL Server, farklı işletim sistemleri üzerinde çalışabilen bir veritabanı yönetim sistemidir. SQL Server, şu işletim sistemlerinde desteklenir:

    Windows İşletim Sistemleri:

    Microsoft SQL Server, öncelikle Windows işletim sistemleri üzerinde çalışmak üzere tasarlanmıştır. Bu işletim sistemleri arasında Windows Server ve Windows Desktop sürümleri bulunmaktadır.
    Örneğin, Windows Server 2019, Windows Server 2016, Windows 10, Windows 8.1 gibi işletim sistemleri desteklenir.
    Linux İşletim Sistemi:

    SQL Server 2017 sürümü ve sonrası, Linux işletim sistemlerini de desteklemektedir. Bu, Linux tabanlı sistemlerde SQL Server kullanma imkanı sağlar.
    Örneğin, Ubuntu, Red Hat Enterprise Linux (RHEL), SUSE Linux Enterprise Server (SLES) gibi Linux dağıtımları desteklenir.
    Docker Üzerinde Çalışma:

    SQL Server, Docker konteyner teknolojisi üzerinde de çalışabilir. Bu, SQL Server'ı çeşitli ortamlarda hızlı bir şekilde dağıtmak ve yönetmek için kullanışlıdır.
    Bu çeşitlilik, SQL Server'ın farklı ortamlarda ve altyapılarda kullanılabilmesini sağlar. Ancak, her SQL Server sürümü her işletim sistemini desteklemez. Bu nedenle, kullanmak istediğiniz SQL Server sürümünün belirli bir işletim sistemini destekleyip desteklemediğini kontrol etmek önemlidir. SQL Server'ın resmi belgeleri ve Microsoft'un web sitesi, desteklenen işletim sistemleri hakkında güncel bilgi sağlar.


........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

        T-SQL (Transact-SQL), Microsoft SQL Server veritabanı yönetim sistemleri için özel olarak tasarlanmış bir sorgu ve programlama dilidir. T-SQL, SQL (Structured Query Language) dilini temel alır, ancak SQL diline ek olarak bir dizi Microsoft özelliği ve genişletmesi içerir. SQL Server üzerinde veritabanı işlemlerini yönetmek, sorguları çalıştırmak, depolamak ve iş mantığı uygulamak için kullanılır.

        T-SQL, aşağıdaki gibi temel özelliklere sahiptir:

        Sorgu Dili:

        T-SQL, SQL dilinin bir genişletmesi olarak kullanılır. Temel SQL sorguları ile birlikte T-SQL, veritabanı üzerinde çeşitli işlemleri gerçekleştirmek için kullanılır.
        Saklı Prosedürler ve Fonksiyonlar:

        T-SQL, saklı prosedürler ve fonksiyonlar oluşturmak ve bu nesneleri veritabanında depolamak için kullanılır. Bu, daha karmaşık işlemleri gerçekleştirmek ve tekrar kullanılabilir kod blokları oluşturmak için önemlidir.
        Veritabanı Yönetimi:

        T-SQL, veritabanı yönetimi için kullanılır. Veritabanı, tablo oluşturma, indeksleme, güncelleme, silme gibi işlemleri gerçekleştirmek ve veritabanı nesnelerini yönetmek için T-SQL sorguları kullanılır.
        Triggers (Tetikleyiciler):

        T-SQL, veritabanında belirli olaylar gerçekleştiğinde otomatik olarak çalışan tetikleyiciler oluşturmak için kullanılır. Bu, belirli bir tablo üzerinde yapılan işlemlere tepki verme yeteneği sağlar.
        Transact-SQL İfadeleri:

        T-SQL, transaktions (işlemler) yönetimi için ifadeler içerir. İşlemleri başlatma, kaydetme, geri alma ve işlemleri yönetme yeteneği sunar.
        T-SQL, özellikle Microsoft SQL Server üzerinde kullanıldığı için, SQL Server özelliklerini ve fonksiyonlarını destekler. Ancak, standart SQL sorgularının çoğunu da içerir. T-SQL, SQL Server veritabanı yönetim sistemi içinde kullanılmak üzere tasarlanmış olmasına rağmen, başka veritabanı yönetim sistemlerinde (örneğin, Azure SQL Database, Azure Synapse Analytics, SQL Server on Linux) sınırlı bir şekilde desteklenebilir.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
1. Veritabanı Oluşturma:

CREATE DATABASE MyDatabase;
2. Kullanılacak Veritabanını Seçme:

USE MyDatabase;
3. Tablo Oluşturma:

CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    Department VARCHAR(50)
);
4. Veri Eklemek:

INSERT INTO Employees (EmployeeID, FirstName, LastName, Department)
VALUES (1, 'John', 'Doe', 'IT');
5. Veri Sorgulama:

SELECT * FROM Employees;
6. Koşullu Sorgulama:

SELECT * FROM Employees WHERE Department = 'IT';
7. Veri Güncelleme:

UPDATE Employees SET Department = 'HR' WHERE EmployeeID = 1;
8. Veri Silme:


DELETE FROM Employees WHERE EmployeeID = 1;
9. Düzenlenmiş Sorgu:

SELECT FirstName, LastName FROM Employees WHERE Department = 'HR' ORDER BY LastName DESC;
10. Toplam veya Ortalama Alma:

SELECT COUNT(*) AS TotalEmployees FROM Employees;
SELECT AVG(EmployeeID) AS AvgEmployeeID FROM Employees;
Bu temel SQL sorguları, bir veritabanı oluşturmak, tablo eklemek, veri eklemek, sorgulamak, güncellemek, silmek ve çeşitli analitik işlemleri gerçekleştirmek için kullanılabilir. Gerçek projelerde, sorgular daha karmaşık olabilir ve JOIN, GROUP BY gibi daha gelişmiş SQL özellikleri kullanılabilir. SQL Server belgeleri ve kaynakları, daha fazla bilgi ve öğrenme kaynakları sağlayabilir.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
    
    SELECT [id]
        ,[adi]
        ,[soyadi]
        ,[email]
        ,[telefon]
        ,[katildigiEgitim]
        ,[EvAdresi]
    FROM [emre].[dbo].[Ogrenciler];

    select kolonlar veya * from db.table;     * demek tüm demektir...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

sql sorguları büyük küçük harfe duyarlı değildir.  select * from ogrenciler ile select * from OGRENCILER arasında fark yok inglizce karakterlre dikkat etmek lazım sadece.
tools -> options ->  word wrap ok dersek eğer ekranın dışına çıkarsa sorfu o zaman alt saıta geçirir.   line numbers ok dersek satır numaralarını görebiliriz.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

/*

bu karakterler ile çoklu satır yapabiliriz. 
sql komutları kullanım amaçlarına göre 3 kategoriye ayrılırlar.
1- ddl(data definition language) -> temel olarak bir veritabanın  tablolalarının fonksiyonlarının vs vs oluştutulmasını sağlayan yapıdır.    create table drop table vs vs... tablo database silmek için drop ama veri silmek için delete kullanırız.

2- dml(data manipulation language) -> veri girmek silmek güncellemek için kullanılan yapı... CRUD   create read update delete işlemleri. yani
3- dcl(data control language) -> veritabanı kulanıcısı ile ilgili işlem yetkileri ayarı vs vs...
    mesela sadece select yapabilsin insert yapamasın gibi...
*/

-- ile /**/ yorum satırlarıdır sqlde.
... pythonda #   ile """  """  ''' ''' vardır... 


            Veritabanı işlemleri sırasında kullanılan komutlar farklı kategorilere ayrılabilir. En yaygın üç kategori Data Definition Language (DDL), Data Manipulation Language (DML) ve Data Control Language (DCL) olarak bilinir. İşte bu kategorilerin açıklamaları:

            Data Definition Language (DDL):

            DDL, veritabanı yapısını tanımlamak ve değiştirmek için kullanılan komutları içerir.
            DDL komutları, tablo oluşturma, değiştirme ve silme gibi veritabanı nesnelerini tanımlamak için kullanılır.
            DDL komutları, veritabanı şemasını (schema) oluşturmak ve değiştirmek için kullanılır.
            Örnek DDL komutları:

            CREATE TABLE: Yeni bir tablo oluşturur.
            ALTER TABLE: Mevcut bir tabloyu değiştirir.
            DROP TABLE: Bir tabloyu siler.
            Data Manipulation Language (DML):

            DML, veritabanında saklanan verileri sorgulamak, eklemek, güncellemek ve silmek için kullanılan komutları içerir.
            DML komutları, veri manipülasyonunu gerçekleştirmek için kullanılır ve veritabanındaki kayıtları etkiler.
            Örnek DML komutları:

            SELECT: Veri sorgulama ve getirme işlemleri için kullanılır.
            INSERT: Yeni veri eklemek için kullanılır.
            UPDATE: Mevcut veriyi güncellemek için kullanılır.
            DELETE: Veriyi silmek için kullanılır.
            Data Control Language (DCL):

            DCL, veritabanı kullanıcılarının erişim haklarını kontrol etmek için kullanılan komutları içerir.
            DCL komutları, kullanıcıların veritabanı nesnelerine (tablo, görünüm, prosedür vb.) erişimini kontrol etmek için kullanılır.
            Örnek DCL komutları:

            GRANT: Kullanıcılara belirli erişim hakları verir.
            REVOKE: Kullanıcılardan belirli erişim haklarını kaldırır.
            Bu kategoriler, veritabanı yönetimi ve güvenliği için temel yapı taşlarını oluşturur. DDL, veritabanı nesnelerini tanımlar; DML, veritabanındaki verileri işler; ve DCL, veritabanı güvenliğini yönetir.

mesela sqlserver ile uygulama ile işlem yapsakta arka planda sql komutları çalışıyor veritabanı ile otomasyon olarka sql ile haberleşiyor.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

create database OrnekDb;  // veritaban oluşturmak için kullanırız iki kere üst üste kullanırsak verir. çünkü oluşturulmuşun üstüne aynısı oluşmaz.

IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = 'OrnekDb')
BEGIN
    EXEC('CREATE DATABASE OrnekDb;');
END;

-- database oluştur eğer varsa bu isimde atla demektir...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
alter database ornekdb modify name = ornekdatabase;    -- veritabanının ismini değiştirmek için kullanırız alter demek db ve table üzerinde güncelleme yap demektir... modify kelimesi şarttır.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
drop database ismi;  -- ile biz table veya db silebilir ve bağlantıdan silebiliriz...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
use dbismi;
create table tablename(verismi veritürü, verisimi veritürü...);    -- önce verinin ismi sonra türü kullanılır... 
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
create database ornekdb
go 
use ornekdb1 
go 
create table Personel(id int, adi varchar(50), soyadi varchar(50)); -- bu duurumda veriler null olabilir demek bunun önüne geçmek için not null deriz.

-- go ile bir sonraki satıra geç diyebiliriz...   create database ornekdb ile oluşturduk db go ile bir sonraki işleme geç dedik use ornekdb dedik seçili db o olsun dmeek... go dedik sonra diğer işleme geç demek tablo oluşturduk... önce verinin ismi soonra türü programlamalardan farklı bir yapısı var.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

create database ornekdb
go  -- benden önceki işlemi bitir sonra diğer işleme geç demek
use ornekdb1 
go 
create table Personel(id int not null, adi varchar(50) not null, soyadi varchar(50) not null, Email nvarchar(50) null); -- null demesek bile otomatik olarak null olabilir ibaresi koyacak allow nulls izni verecek...

-- null dedik diye veriler null olmaz... istersek null olabilir boş bırakılabilir satırda...
-- Email için nvarchar(50) kullan...

....SONRADAN TABLODA DEĞİŞİKLİK YAPMA....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

use ornekdatabase;
go
alter table Personel add Email nvarchar(50); 

-- bir kolon ekledik...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

use ornekdatabase;
go
alter table Personel alter column Email nvarchar(40);

-- alter ile tabloda değişim yapacağız dedik alter column ile kolonda güncelleme ypacağız dedik sonra ise değişecek halini girdik.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

use ornekdatabase;
go
alter table Personel alter column id int not null;

-- kolonda değişiklik ve not null ekledik boş geçilemez hiçbir satırda dedik aslında.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

use ornekdatabase;
go
alter table Personel drop column Email;
-- burada tablodaki kolonu silebiliriz... komple o kolon düşer.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

use ornekdatabase;
go
insert into Personel(id,adi,soyadi) values(1,'merco','ford');
insert into Personel values(1,'merco','ford'); -- tüm sütünların değerlerini göndermemiz gerekir bu yapıda... null olmasını istediğimizin değerini null veerebiliriz. mesela soyadi null deriz.
go
insert into Personel(id,adi) values(1,'BMW');

select * from Personel;

-- burada şu olur insert into tablo(ekleme yapılacak kolonlar ) istediğimiz sıra ile ama values sırası ile aynı olur atama sırası 
-- insert into Personel values(1,'merco','ford') yaparsak tüm kolonları alır sırası ile ekleme yapar values ile... varsayılan kolonlar üzerinden işlem yapar.
-- insert into Personel(id,adi) values(1,'BMW');   burada ise sırası ile atama alacak olan kolonların ismini gireriz ve sonrasında alacak değerlerini ama şu var null olabilenleri yazmayabiliriz not null koşulu olanları girmemiz lazım...

insert into Personel(id,adi) values(1,'BMW');
-- burada soyadi null olur...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

use ornekdatabase;
go
update Personel set adi = 'ferrari' where adi = 'emre'; --   update ile var olan veriler üzerinde işlem yaparız.
-- set demek neler değişecek değişince ne gelsin yeni olarak deriz. where kısmını yazmazsak hepsi ferrari olur true kabul eder.
-- where adi = 'emre' and soyadi = 'aytas' dersek adi emre soyadi aytas olan birisinin ismi ferrari olur...
-- where kısmı önemlidir yoksa hepsi aynı değeri alır set ne belirlediyse.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

use ornekdatabase;
go
delete from Personel where id = 1;

-- delete from tablename where id = 1;    where olmadanda olabilir.
-- eğer where olmazsa true kabul eder her satırı siler..
-- delete silerken komple satırı siler.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

use ornekdatabase;
go
--  backup yani yedek alma...

backup database ornekdatabase to disk = 'C:\\Users\emreaornekdbyedek.bak';
-- to disk demek diske al demek 
-- sonra = der ve bir dizin gireriz.
-- .bak yedek databasenin uzantısıdır.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
use ornekdatabase;
go

Truncate table Personel; -- neden kullanılır çünkü silme işlemini çok hızlı gerçekleştirir ve veriler geri gelemez şekilde silinir...
select * from Personel;
-- Truncate table tabloismi demek tablodaki tüm verileri sil demektir...
drop table Personel;
-- drop table tabloismi demek tabloyu dbden sil dmektir.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

    create database Bilisim;
    go
    use Bilisim;
    go
    create table Bolumler(bolumno int not null,bolumadi nvarchar(50) null, primary key(bolumno));
    -- en son primary key alanı oluşturduk ve içerisine pk olacak olan sutunların isimlerini girdik...
    go
    create table 
    Calisanlar
    (tcno nvarchar(11) not null,
    adi nvarchar(50) not null,
    bolumno int,
    cinsiyet nchar(1),
    primary key(tcno), -- primary key(....) içerisinde biz primary key olacak olan verileri belirleyebiliriz.
    foreign key(bolumno) references bolumler(bolumno)      -- foreign key demek yabancı anahtar demek ikincilde denebilir. başka bir tablodaki alanla bu tablodaki alanı ilişkilendiricez demektir.
    -- foreign keyler ile tabloların ortak noktalarını belirleriz... böylece aslında bellekte fazladan yer kaplamamasını ve daha kullanılabilir olmasını sağlarız.
    );

    go

    create table 
    Urunler(

    urunno int not null,
    urunadi nvarchar(50) not null,
    urunsayisi int null,
    urunfiyati decimal(18,2),-- decimal(18,2) 18 basamağa kadar ve 2 basamak küsürat alabilen demektir float vs yerine decimal kullanılır hassastır iyidir. 
    bolumno int not null,
    primary key(urunno),
    foreign key(bolumno) references bolumler(bolumno) -- foreign key(bağlantı alacak olan sutunadı) references referansverecektablo(referans alınacak sutunuismi)
    -- mesela burada bolumno'yu bolumlerdeki bolumno ile ilişkilendirdik... eğer bolumlerdeki bolum nosu olmayan bir bolumno gieresek urunlere hata verir ilişkili olması lazım...
    );

    go

    create table -- her veriyi , ile ayırırız  create table isim(, , , ); yapısı kullanırız
    Satislar(
    satisno int not null,
    urunno int not null,
    calisantcno nvarchar(11) null,
    miktar int null,
    fiyat decimal(18,2),
    tarih date null,
    primary key(satisno),
    foreign key(urunno) references Urunler(urunno),
    foreign key(calisantcno) references Calisanlar(tcno) -- foreign key tanımladık iki tane alt alta -- calisantcno eldeki tablo references Calisanlar(tcno) referenceseten sonrası başka tablodan gelecek demektir.

    );

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................


/*
--T -SQL
sql dildir ama veritbanlarına göre değişim olmuştur. t-sql sqlserver için...
döngüler if else blokları vs vs aslında t-sql kısmına girer... bu t-sql'i biz oraclede kullanamayız onun için p-sql var...

--T-sqlde değişken kullanımı
   * değişkenler türkçe karakter ve boşlukla başlayamaz.
   * değişken isimleri harf ile başlayıp rakam ile bitebilir _ alabilir
   * select insert vs vs sql'in komutları değişken isimleri olamaz. 
   * değişken isimleri @ @@ ## # $ ile başlayamaz isimlendirmede...
   * değişken isimlerinde büyük küçük harf öenmsiz sql büyük küçük harf duyarlı değil.
   * değişken tanımlama declare komutu ile yapılır

*/

-- Değişken oluşturmab
declare @Bolumno int; -- değişkenler bu yapı ile tanımlanırlar...
declare @Bolumadi nvarchar(50);
-- Değişkenlere değer atama
set @Bolumno = 5;
set @Bolumadi = 'Veritabani programlama'; -- sqlde string değerleri '' içeriisnde tanımlarız  "" içeriisnde değil...
-- Değişkenleri Yazdırma
print @Bolumno;
print @Bolumadi;


........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
use Bilisim;

declare @Bolumler2 table(
    bolumno int,
	bolumadi nvarchar(50)

);

insert into @bolumler2 values(1,'Veritabani'); -- Tsqldede insert into @tablename(kolonlar) values(....);
insert into @bolumler2 values(2,'Programlama');
insert into @bolumler2 values(3,'yazılım');

select * from @Bolumler2; -- select * veya kolon isimleri from table name istersek where ekleyebiliriz...

/*  ...TSQLDE İF ELSE İF ELSE YAPISI KULLANIMI...  */

declare @Urunsayisi varchar(50); -- değişken tanımladık...
select @Urunsayisi = COUNT(*) from urunler where (urunfiyati < 200); -- değişkene değer atanacak count(*) tüm satırlar aranacak nereden urunlerden where fiyatı 200den az olanları alacağız.
if (@Urunsayisi > 0) -- eğer ürün sayısı 0dan fazla ise yazdırma yapar..
print 'fiyati 200 tlden az + ' + @urunsayisi + ' urun vardır...'; -- string append mantığı var...
else 
print 'fiyati 200 tlden az urun yoktur...'

select * from urunler;

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

    use Bilisim;
    select adi,cinsiyet = case cinsiyet
    when 'e' then 'Erkek'
    when 'k' then 'Kadin'
    end 
    from calisanlar;

-- burada olan şu select adi,cinsiyet olarak almadık...  cinsiyet = case cinsiyet when e ise then yani sonra Erkek yaparak getir o kolondaki dğeri demek...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

--tsqlde while yapısı...

use Bilisim;
declare @sayac int;
declare @toplam int;
set @sayac = 1; -- set ile atama yaparız bir değişkene...
set @toplam = 0;
while (@sayac <= 100)  --while içerisinde () koşul belirleriz.
begin -- {} mantığıdır... begin ve end  begin { olur } ise end

   set @toplam = @toplam + @sayac;
   set @sayac = @sayac + 1;
   if(@toplam > 300) break; -- eğer @toplam değişkeni büyükse 300denbu döngüyü kır demektir.
   else continue; -- eğer koşul sağlanmıyorsa devam et demektir.

end

print @sayac;
print @toplam;

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

-- GOTO KULLANIMI...
use Bilisim;

declare @sayac int; -- değişken tanımlama
declare @toplam int;
set @sayac = 1; -- set ile atama yaparız bir değişkene...
set @toplam = 0;
	basla:    -- : koyunca sql bunun bir komut olduğunu anlar basla adlı bir komut ürettik aslında.
		  set @toplam = @toplam + @sayac;
		  set @sayac = @sayac + 1;
		 if(@sayac <= 100)
		 goto basla;
print @sayac;
print @toplam;

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
-- HATA DENETİMİ...
use Bilisim;
select * from sys.messages; -- sistemdeki hataları görebiliriz. bunu yazdırınca hataların nedenlerini idlerini vs görebiliriz. sistem üzerindeki hataları görürüz.
@@error -- en son oluşan hatayı elde edebiliriz.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
        İşte SQL Server'da hata yönetimi için kullanılan bazı araçlar:



        TRY-CATCH Blokları:

        TRY-CATCH blokları, SQL Server'da hata yönetimi için kullanılan temel yapıdır. Bir TRY bloğu içindeki kodu denersiniz ve herhangi bir hata olursa CATCH bloğu çalıştırılır.

        BEGIN TRY
            -- Potansiyel hata oluşturan kod
            SELECT 1 / 0;
        END TRY
        BEGIN CATCH
            -- Hata durumunda yapılacaklar
            PRINT 'Hata oluştu: ' + ERROR_MESSAGE();
        END CATCH;




        RAISERROR Fonksiyonu:

        RAISERROR fonksiyonu, belirli bir hata durumunu tetiklemek ve hata mesajını döndürmek için kullanılır.

        BEGIN TRY
            IF (1 = 1)
                RAISERROR('1 eşittir 1', 16, 1);
        END TRY
        BEGIN CATCH
            PRINT 'Hata oluştu: ' + ERROR_MESSAGE();
        END CATCH;




        THROW İfadesi (SQL Server 2012 ve sonrası):

        THROW ifadesi, bir hata durumunu tetiklemek için kullanılır ve RAISERROR fonksiyonuna benzer şekilde çalışır. SQL Server 2012 ve sonraki sürümlerde kullanılabilir.

        BEGIN TRY
            IF (1 = 1)
                THROW 50000, '1 eşittir 1', 1;
        END TRY
        BEGIN CATCH
            PRINT 'Hata oluştu: ' + ERROR_MESSAGE();
        END CATCH;



        @@ERROR ve @@ROWCOUNT Değişkenleri:

        @@ERROR ve @@ROWCOUNT sistem değişkenleri, en son sorguda oluşan hata kodunu ve etkilenen satır sayısını içerir. Bu değişkenler hata durumlarını kontrol etmek için kullanılabilir.

        SELECT 1 / 0;
        IF @@ERROR <> 0
            PRINT 'Hata oluştu: ' + CONVERT(VARCHAR, @@ERROR);
        Bu mekanizmalar, SQL Server'da hata yönetimi için kullanılabilir. Hata durumlarına uygun şekilde yanıt vererek, uygulamanın hatayı ele almasını ve gerektiğinde geri bildirim sağlamasını sağlayabilirsiniz
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
-- HATA DENETİMİ...
use Bilisim;
select * from sys.messages; -- sistemdeki hataları görebiliriz. bunu yazdırınca hataların nedenlerini idlerini vs görebiliriz. sistem üzerindeki hataları görürüz.
begin try -- try içerisinde hata çıkabilir kodları yazarız...
   select 4/0;  -- burada hata verecek catch kısmına gidecek sistem...
end try
begin catch
   select ERROR_NUMBER() as 'hata numarasi', -- select demek return demektir aslında getirir...
   ERROR_SEVERITY() as 'hata düzeyi',
   ERROR_STATE() as 'hata durumu',
   ERROR_LINE() as 'hatanın satırı',
   ERROR_MESSAGE() as 'Olusan hata'-- as ile isimlendirme yapabiliriz.
end catch
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

-- COMMİT VE ROLLBACK... tablolarda yapmış olduğumuz silme güncelleme başarısız olursa işlemi geri almak için kullanılır...
-- eğer hata olur try catch ile geri alma işlemi yapabiliriz...
use Bilisim;
-- standart başarılı işlemde kullanımı...
select * from calisanlar;
select * from bolumler;
begin
    
	begin try

		begin tran  -- transaction islemini baslat...
			update calisanlar set adi = 'ali riza' where tcno = '123456789';
			update  bilisim set bolumadi = 'Ev aletleri' where bolumno = 3;
		commit tran -- ve işlemleri işle tabloya... başlatılan tran'ı işle demek...

	end try


	begin catch
	 -- tran ya da transaction yazabiliriz.  
	  rollback transaction  -- yukarıdaki sql komutlarından herhangi birinde bir hata olursa eğer o zaman başlatılan işlemi ve işlenen değişiklikleri geri al demektir... eğer birinde bir hata olursa diğerlerinide geri al... ya hepsini işle ya da hiçbirini böylece veri bütünliğü sağlanır.
	    --bir işlemde hata olursa tran içerisndeki tüm değişiklikleri geri alır.

	  print 'HATA OLUŞTU VE TÜM İŞLEMLER GERİ ALINDI...'
	end catch 

end

-- transaction ile biz bir bölge belirleriz aslında begin ve end içerisinde böylece veri bütünlüğü sağlarız ya hepsi üzerinde işlem yapılır güncellenir veya silinir ya da hiçbir şey yapılmaz.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

-- SQL CONSTRAİNTS(KISITLAYICILAR...)
-- veritabanının bütünlüğünü sağlamak için kullanılan mantıksal sınırlamalara kısıt denir.
-- veritabanına hatalı girişleri engellemek için kullanılır...  mesela boş geçilemez deriz bir sutuna sonradan ama boş olan vardır o zaman hata verir gibi bunlara dikkat etmek lazım. ya eski verileri sileceğiz veya kısıta uymayan yerleri güncelleyeceğiz... 
			  --check kontrol kısıtlayıcısı: tablodaki bir sutunun hangi tür verileri alabileceğini vs belirleriz sutun null alabilir mi alamaz mı belirleriz.
         --Kısıtlayıcı çeşitleri
		      --primary key: null olamaz. kombinasyonlar farklı olmalıdır.
			  --unique: null değer alabilir ama tüm değerler birbirinden farklı olmadılır tcno gibi değerler vs vss... satır bütünlüğü içi kullanılır. 

use Bilisim;

ALTER TABLE calisanlar ADD CONSTRAINT UQ_Email UNIQUE (tcno);  -- tcno kolonuna UQ_Email adında bir unique key ekledik...


........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

    SQL Server'de CHECK kısıtlaması, bir sütunun değerlerini belirli bir koşula göre kontrol etmek için kullanılır. Bu koşul, belirli bir mantıksal ifade veya fonksiyon olabilir. CHECK kısıtlaması, belirtilen koşulu sağlayan değerlerin sütuna eklenmesine izin verirken, koşulu sağlamayan değerlerin eklenmesini engeller.

    İşte CHECK kısıtlamasının nasıl kullanılacağına dair bir örnek:
      -- tablodaki bir sutunun hangi tipten verileri alacağı hangi değerler aralığında olacak belirleyebiliriz.
    CREATE TABLE Ogrenciler (
        OgrenciID INT PRIMARY KEY,
        Ad NVARCHAR(50),
        Soyad NVARCHAR(50),
        DogumTarihi DATE,
        Cinsiyet CHAR(1),
        CONSTRAINT CHK_Cinsiyet CHECK (Cinsiyet IN ('E', 'K'))
    );
    Bu örnekte, Ogrenciler adında bir tablo oluşturduk. Tablonun Cinsiyet adlı sütunu için CHECK kısıtlaması ekledik. Bu kısıtlama, Cinsiyet sütununa sadece 'E' (Erkek) veya 'K' (Kadın) değerlerinin eklenmesine izin verir. Başka bir deyişle, sütuna 'E' veya 'K' dışında bir değer eklemeye çalışırsanız, bir hata alırsınız.

    CHECK kısıtlaması, tablo oluşturulurken veya tabloya bir sütun eklenirken tanımlanabilir. Ayrıca, mevcut bir tabloya ALTER TABLE ifadesi ile sütun eklendikten sonra da CHECK kısıtlaması eklenebilir.



    İşte mevcut bir tabloya sütun eklendikten sonra CHECK kısıtlamasının nasıl eklenileceğine dair bir örnek:

    ALTER TABLE Ogrenciler
    ADD CONSTRAINT CHK_Yas CHECK (DATEDIFF(YEAR, DogumTarihi, GETDATE()) >= 18);
    Bu örnekte, Ogrenciler tablosuna DogumTarihi adında bir sütun ekledikten sonra, CHECK kısıtlamasıyla bu sütuna sadece 18 yaşından büyük öğrencilerin eklenebilmesini sağladık. Bu kısıtlama, GETDATE() fonksiyonunu kullanarak mevcut tarihi alır ve DogumTarihi sütunundaki doğum tarihinden yıllara çevirir. Sonuç olarak, öğrencinin yaşını kontrol eder ve sadece 18 yaşından büyük öğrencilerin eklenebilmesine izin verir.

alter table Urunler add constraint CKtc check (urunfiyati > 0);   -- örnek olarak ekleme cktc check kısıtının ismi... o constraint'in ismi...
     -- bir hata fırlatır burada böylece...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

    SQL Server'da tetikleyiciler (triggers), belirli bir olayın gerçekleştiği durumlarda otomatik olarak çalışan saklı prosedürlerdir. Genellikle bir tabloya yapılan ekleme (INSERT), güncelleme (UPDATE) veya silme (DELETE) gibi işlemler sonrasında tetiklenirler. Tetikleyiciler, bu olayları algıladıklarında belirli bir işlemi gerçekleştirmek için kullanılır.

    Tetikleyiciler, veritabanı tutarlılığını sağlamak, iş akışını otomatikleştirmek, veri denetimini yapmak veya işlem takibini gerçekleştirmek gibi çeşitli amaçlar için kullanılabilir.

    İşte bir örnek:


    CREATE TRIGGER trgAfterInsert
    ON TabloAdi
    AFTER INSERT
    AS
    BEGIN
        -- Eklenecek yeni kayıt bilgilerini al
        DECLARE @ID INT;
        SELECT @ID = inserted.ID FROM inserted;

        -- Yapılacak işlem (örneğin, bir log tablosuna ekleme yapma)
        INSERT INTO LogTablosu (Islem, Tarih) VALUES ('Yeni kayıt eklendi', GETDATE());
    END;
    Bu örnekte, TabloAdi adındaki bir tabloya yeni bir kayıt eklenmesinden sonra çalışacak bir tetikleyici oluşturduk. Tetikleyici, AFTER INSERT (ekleme işleminden sonra) olarak belirlendi. Tetikleyicinin içinde, yeni eklenen kaydın ID değeri alınıyor ve bu bilgi kullanılarak bir log tablosuna yeni bir kayıt ekleniyor. Bu şekilde, her yeni ekleme işlemi gerçekleştiğinde bir log kaydı oluşturulmuş olur.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
-- TRİGGERS -- tetikleyici oluşturabilmek için veritabanının programcıya izin vermesi lazım izni olan işlem yapabilir diğer işlemlerde olduğu gibi.
         --Kısıtlayıcı çeşitleri
		      --primary key: null olamaz. kombinasyonlar farklı olmalıdır.
			  --unique: null değer alabilir ama tüm değerler birbirinden farklı olmadılır tcno gibi değerler vs vss... satır bütünlüğü içi kullanılır. 
			  --check kontrol kısıtlayıcısı: tablodaki bir sutunun hangi tür verileri alabileceğini vs belirleriz sutun null alabilir mi alamaz mı belirleriz.
			  --triggersler(tetikleyiciler) bir işlem yapıldıktan sonra başka işlemi tetiklemek için kullanılırlar...
			       --mssqlde iki çeşit triggers vardır.  1- ardı sıra tetikleyiciler. bir işlem bittikten sonra başka işlem tetikleme
				                                       --2- yerine tetikleyiciler. tetikleyiciyi çağıran eylem çağrılınca devreye girer... thread mantığı...
                                               -- insert tetikleyicisi: tabloya kayıt eklendiğinde tetiklenir.
											   -- delete tetikleyicisi: tablodan veri silinince tetiklenir.
											   -- update triggers: güncelleme olunca tetiklenir.

-- yeni bir tetikleyici oluşturmak için create trigger
-- var olan triggeri güncellemek için ise alter trigger kullanırız.

CREATE TRIGGER  -- trigger olutur dedik.
uruntrigger on urunler after insert as -- urunlere'e ekleme olduktan sonra çalış. ismi uruntrigger olacak...
declare @inturunsayisi int select @inturunsayisi = (select urunsayisi from inserted); -- declare ile bir değişken oluşturduk. from inserted demek eklenen veri demek
if @inturunsayisi is null -- eğer urunsayısı null ise..
update Urunler set urunsayisi = 1 where Urunler.urunno = (select urunno from inserted); -- urunsayisini değiştir 1 yap... 
-- nereden urunno eklenen urunno ile aynı olan... demek select urunno return et urunno demek... from inserted demek eklenenden urunnoyu return et demek..
-- eklenen urunnosu null ise bir veri eklerken o zaman şu olur urunsayisi 1 olur otomatik olarak. böylece null geçilmez urunsayisi.

insert into Urunler(urunno,urunadi,urunfiyati,bolumno) values(121,'dfd',122,3); -- burada ürünsayısını null yaptık ama trigger sayesinde 1 olacak... 
-- çünkü eğer null olursa onu sen otomatik olarak 1 ata triggeri girdik.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

create trigger urunlersilmetrigger on urunler
for delete -- sile olduğu zaman çalışacak olan trigger...
as
declare @inturunsayisi int
select @inturunsayisi = (select urunsayisi from deleted); -- silinen değeri al... urunsayisi değerini al silinen satırdan ve @inturunsayisina ata. 
if @inturunsayisi > 1
begin 

rollback tran 
raisError('urun sayisi 1den fazla...',11,1); -- hata fırlat deriz eğer silinen ürünün sayısı 1den fazla ise.

end

select * from Urunler;

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

-- update tetikleyicisi...
create trigger updatetrigger on urunler 
for update 
as 
raisError('indirim yapılan urun sayisi',11,1,@@rowcount); -- @@rowcount demek. etkilenen satır sayısını getirir... 
return

update urunler set urunfiyati = urunfiyati - 10 where urunfiyati > 100; 
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................


-- TSQLDE STORED PROCEDURE(SAKLI YORDAM) VE FONKSİYON KULLANIMI...  stored prosedürler programlability klasorunde saklanırlar stored procesured klasörunde saklanırlar. stored procesured derlenmiş bir şekilde veritabanında tutulduğu için çok hızlı çalışır normal bir sql komutuna göre... crud işlemleri vs daha hızlı hale getirebiliriz bunlar derlenmiş halde sistemde dururlar böylece daha hızlı çalışırlar. işlemleri metot haline getirerek aynı işlemi tek metotla kodları tekrar yazmadan kullanılabilir hale getirir.

-- STORED PROCEDURE(SAKLI YORDAM) VE FONKSİYON arasında farklar vardır... programlability klasöründe metotlar ve stored precedureler ayrı tutulurlar farkları vardır. mesela max adlı metot en yuksek değeri getirir. hazır olan fonksiyonlardır substring gibidirler. stored precedureler genel olarak hızlı crud için kullanılır.

	-- kullanıcı tanımlı fonksiyonların içerisinde herhangi bir yerde where/having/ select vb kullanılabilirken saklı yordam kullanılamaz. ayrıca saklı yordamda metotlar çağrılabilirken fonksiyon içeriisnde saklı yordam çağrılamaz. çünkü stored precedureceler static ama metotlar değiller. sp > func

	-- kullanıcı tanımlı metot(kendi yazacağımız metot) mutlaka bir tablo veya sayılı değer döndürmelidir. döndürdüğü tablo değeri, diğer tablolar ile join vb. yapmak için kullanılabilir. saklı yordamların mutlaka değer döndürmeleri gerekmez.
	
	-- saklı yordamlarda veri işleme (select/ update / delete ) komutları çalışabilirken kullanıcı tarafından yazılmış metotlar bu işlemleri yapamaz...

	-- saklı yordam içinde try catch ile hata ayıklama yapabiliriz ama metot(kendi yazdığımız)larda try catch kullanamayız.
	
	-- saklı yordam hareket yönetemi varken kullanıcı tarafından yazılmış metotlarda bu mümkün değil.
	
	-- stored precesured derlenmiş halde tutulurken metotlar çalışma zamanında derlenir çalıştırılırlar.

-- bilişim veritabanı tabloları hakkında bilgi veren sistem stored precedured'i çalıştırdık...
exec sp_tables -- bir saklı yordamı exec ve SPismi ile çalıştırabiliriz...
	
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
--YENİ STORED PRECESURED(saklı yordam) OLUŞTURMA... create ile oluştururuz.   join ile iki veya daha fazla tabloyu birleştiririz...
create proc sp_calisanbolum  -- create proc ismi
as
begin -- as beginden sonra işlem yaptıracağız.
select bolumler.bolumadi,Calisanlar.adi bolumler from Bolumler join -- join demek tabloları birleştir demek. from table1 join table2 on demek ne ile birleşecek demek on bolumler.bolumno = calisanlar. bolumno   satır satır bolumnoları aynı olanlar birleşecek...
Calisanlar on bolumler.bolumno = Calisanlar.bolumno;
end

-- ekleyince database'nin programlability klasörüne yerleşir.
exec sp_calisanbolum      ile biz bu stored procesured'i kullanabiliriz.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

-- ürün listeleyen saklı yordam...
create proc sp_urunlistele
(@urunsayisiparametresi int)   -- biz dışarıdan veri göndereceğiz bunun karşılığıdır...  (@urunsayisiparametresi int = 0) dese idik eğer o zaman şu olurdu default olarak sıfır alırdı exec sp_urunlistele  olarak çağırdığımızda ürün sayısı 0dan fazla olanları getirirdi sistem.
as 
begin
select * from urunler where urunsayisi > @urunsayisiparametresi;
end
  
exec sp_urunlistele 15;  -- çalıştırması ise böyle. exec SPadi varsa paramatresi...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

alter proc sp_urunlistele --alter demek var olan sp'yi değiştir demektir.
(@urunsayisiparametresi int = 0)   -- biz dışarıdan veri göndereceğiz bunun karşılığıdır...   = 0 demek default olarak 0 alsın eğer veri göndermezsek demektir.
as 
begin
select * from urunler where urunsayisi > @urunsayisiparametresi;
end

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

-- insert işlemi için proc kullanımı...
create proc spbolumekle
(@ad1 nvarchar(50)) 
as 
begin 
insert into Bolumler(bolumadi) values(@ad1); -- sadece bolumadina değer ekleme yapacağız burada...
end




........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
-- insert işlemi için proc kullanımı...
alter proc spbolumekle
(@int1 int ,@ad1 nvarchar(50)) 
as 
begin 
insert into Bolumler(bolumno,bolumadi) values(@int1,@ad1); -- sadece bolumadina değer ekleme yapacağız burada...
end

exec spbolumekle 7,'emreford'; ile ise kkullanırız...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

otomatik artmayı sağlamak için kullanırız.

identity specification'u true yaparsak eğer o zaman otomatik olarak artan yaparız....
identity increment = nereden başlayacak... 
identity seed kaçar kaçar artacak demektir.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................


-- delete işlemi için precosured...
create proc spUsatisSil
(@urunfiyati decimal(18,2))
as 
begin
delete from Satislar where fiyat < @urunfiyati;
end

exec spusatissil 100.33;      -- ile çağırabiliriz.

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

--stored procedures ile güncelleme...
create proc spurunfiyatguncelle(@artismiktari float)
as
begin 
update Urunler set urunfiyati = urunfiyati + urunfiyati * @artismiktari / 100;
end

-- istenen yüzde kadar artırır...

exec spurunfiyatguncelle 15;        ile çalıştırırız mesela. 
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

-- FONKSİYONLAR, c#da vs benzer yapıdadır... iki tip metot var. kullanıcı tipi tek bir tip döndürür oda tablo veya değerdir diğeri ise sql metotlarıdır. create ile üretiriz drop ile düşürürüz metotları.

create function urunadet(@urunadi nvarchar(50))
returns int -- int bir değer dönmek demektir.
as begin 

declare @inturunadedi int

set @inturunadedi = (select urunsayisi from Urunler where urunadi = @urunadi);
return @inturunadedi;
end

-- fonksiyonlar programlability klasorundeki functions klasörüne gider.

select dbo.urunadet('Mouse') as 'klavye adeti' -- as ile isimlendirme yapabiliriz alias demektir.
-- bu yapı ilede metotları kullanabiliriz...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

create function fncalisanlistele() -- metot tanımlaması () demek metot demektir her zamanki gibi...
returns table -- tablo dönecek demektir... tablolarda nesneler gibi kullanılır.
as 
return select * from Calisanlar

select * from dbo.fncalisanlistele()   -- bir tablo döner dbo.fncalisanlistele()...
-- böylece yazdırmasını yaparız.. tüm sutunları yazdırır tüm satırlarıda...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

-- fonskiyon güncelleme...
alter function fncalisanlistele(@cinsiyet nchar(1)) -- metot tanımlaması () demek metot demektir her zamanki gibi...
returns table -- tablo dönecek demektir... tablolarda nesneler gibi kullanılır.
as 
return select * from Calisanlar where cinsiyet = @cinsiyet;

select * from fncalisanlistele('e'); -- şeklinde de çağırabiliriz...

-- metot silme. tablo db function vs silme drop ile yapılır...
drop function fncalisanlistele;
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

içi verilerle dolu bir veritabanı bulalım... northwind database yazarız googleye ve indiririz...
instnwnd.sql   .sql uzantısı ile bunu indiririz githubdan... https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs
sonra bu sql'i açarız ve çalıştırırız bunun sayesinde içi verilerle dolu bir db oluşur.


........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

select * from table1; her satırı getirir ve her kolonu   select name,surname from table1 ise istenen kolonları name surname ve tüm satırları getirir...

select productname as ürünadi, unitprice as ürünfiyatı, unitstock * unitprice as toplamdeger from prodcuts p  -- p prodcuts'u artık p ile kullanabiliriz...  * ile çarpma işlemi yapabiliriz...
     productname as ürünadi  -- bu kolonu getir ama ürünadi ismi ile getir kolon ismi o olsun demek...
      unitstock * unitprice as toplamdeger    -- unitstock ile tane fiytını çarp ve toplam değer kolonunda getir demektir...  sayısal işlemlar yapabiliriz sayısal değrler üzerinde...

-- TOPLAMA
select 10 + 8 as islemsonucu; -- 18 getirir     islem sonucu kolonunda 18 değeri getirir...

--ÇIKARMA
select 10 - 8 as cikarma;  2 değerini cikarma kolonu içerisinde getirir.
-- select aslında return etmek mantığı kullanılır...

--çarpma
select 9 * 2 as carpma;  as kullanmazsak no name column kolonu içerisinde getirir değeri...

-- BÖLME 
select 34 / 18 as bolmesonucu; 

--MODULA
select 16 % 2 is modula; kalanı getirir modula kolonunda...


........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
-- karşılaştırma operatörleri
-- EŞİTTİR 
select * from products where price = 18;
-- BÜYÜKTÜR
select * from products where price > 18;
-- KÜÇÜKTÜR 
select * from products where price < 18; 
-- BÜYÜK EŞİTTİR
select * from products where price >= 18; 
--KÜÇÜK EŞİTTİR
select * from products where price <= 18; 
-- EŞİT DEĞİLDİR
select * from products where price <> 18;  -- eşit değildir operatorleri <> demektir...

--birden fazla koşul...
select name1,surname1 from products where price > 100 and categoryid = 1; -- iki şartta sağlanmalıdır... 
select name1,surname1 from products where price > 100 or categoryid = 1; -- ikisinden birisi tutsa yeter.

-- Select Top ifadesi     üstten belirli sayıda satır getirir...

select top (50) proid,proname from  products;  -- top (sayi) ekleriz selectten sonra en üstteki sayi kadar satırı getirir.
select top (50) proid,proname from  products where price <> 100;

-- order by ile sıralama...

select * from products order by stock asc ; -- default olarak asc zaten küçükten büyüğe sıralar. asc yazmsadakta olurdu...
select proid,proname from products order by stock desc; -- büyükten küçüğe sıralama yapabiliriz.

-- like ile arama filtrelem yapma.
select proid,proname from products where productname like 'a%';  -- a ile başlayanlar demek...
select * from products where productname like 'abs%'; -- abs ile başlayan isimleri getir...
select * from products where productname like '%abs'; -- abs ile bitenleri getir demektir...
select * from products where productname like '%ab'; -- ab ile bitenleri getir demektir... 
select proid,proname from products where productname like '%abs%' -- içinde abs geçenleri getir demektir
select proid,proname from products where contanctname like '_r%'; -- ikinci karakteri r ile başlayanları getirir.
select * from products where productname like '%r_'; -- sondan ikinci karakteri r olanlar ı getir demektir.
select * from products where productname like 'a__%' -- adı a ile başlayan ve en az 3 karakter olan kayıtları getir demektir.
select * from products where productname like '%___a'; -- adı a ile biten ve en az 4 karakter olan kayıtları getir demektir.
select * from products where productname like 'a%b' -- a ile başlayan ve b ile biten kayıtları getirir...
select * from products where productname like 'ab%cd' -- ab ile başlyan ve cd ile biten kaytılatrı getirir.
select * from products where productname not   like '%a' --  a ile bitmeyen kayıtları getirir not like dedik cunku....
select * from products where productname not   like 'em%' -- em ile baslamayanları getirir...

-- SQL IN,NOT IN OPERATORU...
select * from products where country in ('UK','germany','brazil') -- () içerisinde birden fazla seçeneğimiz varsa or or yerine bunu kullanırız
select * from products where country not in ('UK','germany','brazil') -- () içine girilenler harici satırları getirir...birden fazla seçenek için kullanılır...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// alttaki ikisi lazım data ile işlem yapabilmek için...
using System.Data; // veritabanı ile işlemler yapabilmek için...
using System.Data.SqlClient; // veritabanına bağlanabilmek için kullanılır

namespace ado.net
{


    class ProductDAL
    {
        SqlConnection _connection =  new SqlConnection(@"server=EMREAYTAS\SQLEXPRESS; initial catalog = UrunYonetimi; Integrated security = True"); // sql bağlanyısını sağlamak için kullanılır. bir connection string gireriz...
        // initial catalog = veritabanı ismi... ilişkili veritabanı demektir.
        // Integrated security = True ... kendi pcmizde bağlanacağımız için bana veritabanına baplanabilmek için kullanıcı adı ve parola sorma dedik... ama eğer web uygulaması yapacaksak herkes erişemesin diye farklı olacak...
        

        
       void connectionKontrol()
        {

            if (_connection.State == ConnectionState.Closed) // eğer bağlantı kapalı ise açacak açıksa ellemeyecek...  
            {
                _connection.Open(); // eğer kapalı(ConnectionState.Closed) ise açacak bağlantı sağlayacak...

            }

        }

       public void addProduct(Product product) // Product nesnesi gelecek demektir...
        {
            connectionKontrol(); // bağlantının kesin açılması için kullanırız...
            SqlCommand command = new SqlCommand("insert into Products values(@UrunAdi,@UrunFiyati,@StokMiktari)",_connection); // sql komutu göndericez demektir...    bağlantı ve komut gönderdik...
            // sql injection olmaması için parametre ile ekleme yaparsak sql açığına karşı önlem alırız...
            // @ işaretleri sutun karşılığıdır...
            command.Parameters.AddWithValue("@UrunAdi",product.urunadi); // değerler ile ekleme yap deriz...  
            command.Parameters.AddWithValue("@UrunFiyati", product.urunfiyati);
            command.Parameters.AddWithValue("@StokMiktari", product.stokmiktari); // biz aslında "@StokMiktari" product.stokmiktarı olsun dedik... 

            // komutlar hazır bunları çalıştırmak lazım...
            command.ExecuteNonQuery(); // veritabanına veriler işlemek için kullanılır...
            _connection.Close(); // bağlantıyı kapatır bunun nedeni şudur belleği yormasın sistem açığı oluşturmasın...


        }

        
        public List<Product> GetAll()
        {
            List<Product> products = new List<Product>();
            connectionKontrol(); // bağlantının kesin açılması için kullanırız...
            SqlCommand command = new SqlCommand("select * from products", _connection); // sql komutu göndericez demektir...    bağlantı ve komut gönderdik...
            // sql büyük küçük harfe duyarlı değil o yüzden sorun yok... büyük küçük yazabilirsiniz...
            SqlDataReader reader = command.ExecuteReader(); // okuma işlemi yapacağız gönderdiğimiz sorgu ile.
            while (reader.Read()) // null olana kadar dönecek tüm satırları gezecek... imleç mantığı ile çalışır...
            {

                products.Add(new Product(Convert.ToInt32(reader["id"]), reader["UrunAdi"].ToString(), Convert.ToDecimal(reader["UrunFiyati"]), Convert.ToInt32(reader["StokMiktari"]) )); // reader bir json string mantığı ile çalışır... verileri kendi üzerine çeker her seferinde...

                
            }

            reader.Close(); // readeri kapattık bellekte yer kaplamasın diye...
            _connection.Close (); // bağlantıyı kestik...


            return products; // referans return eder...


        }

        public DataTable GetTable() // bir collection değil tablo return edecek sistem...
        {

            connectionKontrol(); // bağlantının kesin açılması için kullanırız...
            SqlCommand command = new SqlCommand("select * from products", _connection); // sql komutu göndericez demektir...    bağlantı ve komut gönderdik...
            // sql büyük küçük harfe duyarlı değil o yüzden sorun yok... büyük küçük yazabilirsiniz...
            SqlDataReader reader = command.ExecuteReader(); // okuma işlemi yapacağız gönderdiğimiz sorgu ile.
            DataTable table = new DataTable(); // tıpkı bir tablo oluşturmak gibi... excel gibi düşünebiliriz satırlar sutunlar ve elimizdeki veriler ile dolduracağız... bir excel dosyası gibi... 


            table.Load(reader); // reader'ı alır yani içinde verilerin saklı olduğu o cursor'u ve ona göre doldurur...

            reader.Close();
            _connection.Close();

            return table;

        }


        public void Update(Product product) // Product nesnesi gelecek demektir...
        {

            connectionKontrol(); // bağlantının kesin açılması için kullanırız...
            SqlCommand command = new SqlCommand("update products set UrunAdi = @UrunAdi, UrunFiyati = @UrunFiyati,StokMiktari = @StokMiktari where id = @id", _connection); // sql komutu göndericez demektir...    bağlantı ve komut gönderdik...
            // sql injection olmaması için parametre ile ekleme yaparsak sql açığına karşı önlem alırız...
            // @ işaretleri sutun karşılığıdır...
            command.Parameters.AddWithValue("@UrunAdi", product.urunadi); // değerler ile ekleme yap deriz...  
            command.Parameters.AddWithValue("@UrunFiyati", product.urunfiyati);
            command.Parameters.AddWithValue("@StokMiktari", product.stokmiktari); // biz aslında "@StokMiktari" product.stokmiktarı olsun dedik... 
            command.Parameters.AddWithValue("@id", product.id);

            // komutlar hazır bunları çalıştırmak lazım...
            command.ExecuteNonQuery(); // veritabanına veriler işlemek için kullanılır...
            _connection.Close(); // bağlantıyı kapatır bunun nedeni şudur belleği yormasın sistem açığı oluşturmasın...


        }


        public void Delete(int id) // Product nesnesi gelecek demektir...
        {

            connectionKontrol(); // bağlantının kesin açılması için kullanırız...
            SqlCommand command = new SqlCommand("delete from products where id = @id", _connection); // sql komutu göndericez demektir...    bağlantı ve komut gönderdik...

            command.Parameters.AddWithValue("@id", id);

            // komutlar hazır bunları çalıştırmak lazım...
            command.ExecuteNonQuery(); // veritabanına veriler işlemek için kullanılır...
            _connection.Close(); // bağlantıyı kapatır bunun nedeni şudur belleği yormasın sistem açığı oluşturmasın...


        }



    }


}

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ado.net
{

    // dgvUrunListesi.DataSource = productDAL.GetTable(); // yeni veri gelince sıfırdan tüm ürünleri getirir böylece güncel görebiliriz verileri...    içi verilerle dolu tabloyu verdik ve o bizde bunu ekrana bastırdı...


    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }
        ProductDAL productDAL = new ProductDAL();

        private void Form1_Load(object sender, EventArgs e) //form yüklenirken çalışır veri tabanından verileri çekip yazdıracağız...
        {
            
            dgvUrunListesi.DataSource = productDAL.GetAll(); // verileri sana bir liste içeriside vereceğim sen bunları yazdır dedik... Product nesnesi hepsi ama o verileri alabilir sorun yok.


        }

        private void label1_Click(object sender, EventArgs e)
        {

        }

        private void label1_Click_1(object sender, EventArgs e)
        {

        }

        private void label3_Click(object sender, EventArgs e)
        {

        }

        private void textBox3_TextChanged(object sender, EventArgs e)
        {

        }

        private void button1_Click(object sender, EventArgs e) // butona tıklanınca çalışır ama events kısmındaki yapıları kullanarak değişik değişik işlemler yapabiliriz...
        {
            productDAL.addProduct(new Product(1,textBox1.Text.Trim(),Convert.ToDecimal(textBox2.Text),Convert.ToInt32(textBox3.Text))) ;
            dgvUrunListesi.DataSource = productDAL.GetAll(); // yeni veri gelince sıfırdan tüm ürünleri getirir böylece güncel görebiliriz verileri...

            MessageBox.Show("ÜRÜN EKLENDİ","SQL");



        }

        private void dataGridView1_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {

        }

        private void btnGuncelle_Click(object sender, EventArgs e)
        {
            int deger = Convert.ToInt32(dgvUrunListesi.CurrentRow.Cells[0].Value.ToString());
            productDAL.Update(new Product(deger, textBox1.Text.Trim(), Convert.ToDecimal(textBox2.Text), Convert.ToInt32(textBox3.Text)));
            dgvUrunListesi.DataSource = productDAL.GetTable(); // yeni veri gelince sıfırdan tüm ürünleri getirir böylece güncel görebiliriz verileri...    içi verilerle dolu tabloyu verdik ve o bizde bunu ekrana bastırdı...
             
            MessageBox.Show("ÜRÜN GUNCELLENDİ", "SQL");






        }


        private void dgvUrunListesi_CellClick(object sender, DataGridViewCellEventArgs e) // cellClick eventi...
        {
            lblid.Text = dgvUrunListesi.CurrentRow.Cells[0].Value.ToString();
            textBox1.Text = dgvUrunListesi.CurrentRow.Cells[1].Value.ToString(); // Cells bir dizi dönderir sırası ile kolonlar...
            textBox2.Text = dgvUrunListesi.CurrentRow.Cells[2].Value.ToString(); // Value ile o dizideki istenen indexteki değeri alırız...
            textBox3.Text = dgvUrunListesi.CurrentRow.Cells[3].Value.ToString();






        }

        private void btnSil_Click(object sender, EventArgs e)
        {
            
            int deger = Convert.ToInt32(dgvUrunListesi.CurrentRow.Cells[0].Value.ToString());
            if (deger > 0)
            {

                if (MessageBox.Show("SİLMEK İSTEDİĞİNİZE EMİN MİSİNİZ?","SİLME UYARISI",MessageBoxButtons.OKCancel,MessageBoxIcon.Warning) == DialogResult.OK)  // MessageBoxButtons.OKCancel  ile ok ve  cancel butonları çıkarırız...
                {
                    
                    productDAL.Delete(deger);
                    dgvUrunListesi.DataSource = productDAL.GetAll();
                    MessageBox.Show("ÜRÜN SİLİNDİ", "SQL");


                }



            }



        }
    }
}

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

Entity framework kullanacaksak eğer sonradan nuggetten indiririz web masaüstü vs vs entity kullanılan uygulamalar için     mobilde entity kullanılmaz mesela... 
Manage nuget Packages'ten indiririz...

Entity Framework 6 (EF6) is a tried and tested object-relational mapper for .NET with many years of feature development and stabilization.

her projede ihtiyaçlara göre indiririz bunları...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

Çözüm Gezgini'nde Başlangıç Projesini Kontrol Edin: Visual Studio'da, çözümünüzde birden fazla proje varsa, çözüm gezgini panelinde varsayılan olarak çalışacak olan başlangıç projesini belirleyebilirsiniz. Başlangıç projesini değiştirmek için, sağ tıklayarak projeyi seçin ve "Set as Startup Project" (Başlangıç Projesi Olarak Ayarla) seçeneğini kullanın.
Proje Yapılandırma Ayarlarını Kontrol Edin: Projelerinizi açtıktan sonra, menü çubuğundaki "Proje" menüsünden "Proje Yapılandırması" (Project Configuration) seçeneğine gidin. Burada, hangi projenin varsayılan olarak başlangıç projesi olarak ayarlandığını kontrol edebilirsiniz.
Visual Studio Ayarlarını Sıfırlayın: Eğer yukarıdaki adımlar herhangi bir sonuç vermezse, Visual Studio ayarlarını sıfırlamak sorunu çözebilir. Bunun için, "Tools" (Araçlar) menüsünden "Import and Export Settings" (Ayarları İçe ve Dışa Aktar) seçeneğini seçerek, "Reset all settings" (Tüm Ayarları Sıfırla) seçeneğini kullanabilirsiniz.
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

Entity framework aslında elde olan tablolara göre classlar oluşturur ve o nesneler üzerinden işlemler yaparız... önce model sonra entity sayesinde controller sistemini kurarız...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

diziler statictir bellekte oluşur ve bellekte kapladığı alan sabittir. arraylistler vs gibi yapılar ise dinamiktir.. bellekteki kapladığı alan değişse bile değerleri kaybolmaz... arrayde ise new'lersek veriler kaybolur...

........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

 enable-migrations   nuget manager'de package manager console'ye yazdık... ve default project seçtik yoksa sıkıntı olur...
update-database     // böylece 
            AutomaticMigrationsEnabled = true; yaparız false olursa update-database'ı kullanamayız...
update-database yazarız eğer verdiğimz isimde db yoksa oluşturur...

.........................................................................
mvc =  model view controller...
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................