Install-Package System.Data.SQLite   console manager kısmına yazarak SQLite kullanabiliriz... masaüstü uygulamaları için harika entity framework'te kullanabiliriz orm olarak destekler...
        SQLite NuGet Paketini Yükleme:
        Projenize SQLite ile çalışmak için System.Data.SQLite NuGet paketini ekleyin. Visual Studio kullanıyorsanız, "NuGet Package Manager Console" penceresini açıp aşağıdaki komutu kullanarak paketi yükleyebilirsiniz:

        bash
        Copy code
        Install-Package System.Data.SQLite
******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Form1 ff = new Form1();
         ff.ShowDialog();


          Console.WriteLine("merhababaaaaaa");
c# dilinde showDialog ile form açılıyor ama ben açıldıktan sonra alltaki yazıyıda yazdırsın istiyorum yani programın okuması orada takılı kalıyor ne yapmam lazım
ChatGPT
ShowDialog metodu, ilgili form kapatılana kadar kontrolü ele geçirir. Bu nedenle, ShowDialog metodundan sonra gelen kodlar, form kapandığında çalışır. Eğer formun üzerindeki işlemler tamamlandıktan sonra bir şeyler yapmak istiyorsanız, Form1 sınıfınızda bir olay (event) tanımlayarak bu olayı uygun bir durumda tetikleyebilirsiniz. Örneğin, formunuz kapatıldığında bir olay tetikleyerek ardından gelen kodları çalıştırabilirsiniz.

c#'da from uygulaması showDialog ile açıldıktan sonra o panel açık olduğu sürece alt satıra geçmez programın okuma imleci orada takılı kalır taki kapanana kadar...


************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
C# dilini daha ileri seviyede öğrenmek için aşağıdaki konulara odaklanabilirsiniz. Bu konular, C# programlamadaki ileri seviye konseptlere ve geliştirme tekniklerine odaklanmaktadır:

Nesne Yönelimli Programlama (OOP):
    C#'da nesne yönelimli programlama temel bir konsepttir. Sınıflar, nesneler, miras, soyut sınıflar, arayüzler, çoklu kalıtım gibi OOP konularını öğrenmek önemlidir.

İleri Seviye Dil Özellikleri:
    C#'daki en yeni dil özelliklerini anlamak ve kullanmak için çalışın. Örneğin, C# 8 ve sonraki sürümlerdeki özellikler arasında nullable reference types, pattern matching, switch expressions gibi konular bulunmaktadır.

LINQ (Language Integrated Query):
    LINQ, veri sorgulama ve manipülasyonu için kullanılan güçlü bir dil entegre sorgu aracıdır. LINQ kullanarak veri tabanlarına, koleksiyonlara ve diğer veri kaynaklarına sorgular yazmayı öğrenmek önemlidir.
Asenkron ve Paralel Programlama:
    Modern uygulamalar genellikle asenkron ve paralel programlama tekniklerini kullanır. async ve await anahtar kelimelerini kullanarak asenkron programlamayı, paralel programlamayı da inceleyerek çoklu iş parçacığı (multithreading) konularını anlamak önemlidir.

Exception Handling (İstisna Yönetimi):
    Hata işleme konusunu daha iyi anlamak için try, catch, finally bloklarını kullanma becerisi geliştirmek önemlidir.
Veri Tabanı Programlaması:
    Entity Framework veya Dapper gibi C# ile entegre veri tabanı erişim araçlarını öğrenmek ve kullanmak.
    
ASP.NET MVC veya ASP.NET Core:
    Web uygulamaları geliştirmek için ASP.NET MVC veya ASP.NET Core framework'ünü öğrenmek. MVC tasarım deseni, routing, middleware kavramlarına hakim olmak önemlidir.

Unit Testing (Birim Testleri):
    NUnit, xUnit veya MSTest gibi birim testi çerçeveleri kullanarak uygulamalarınızı test etmeyi öğrenmek. Test yazma, test odaklı geliştirme ve test otomasyonu konularına hakim olmak önemlidir.
Dependency Injection ve IoC (Inversion of Control):
    Uygulama bağımlılıklarını yönetmek için Dependency Injection (Bağımlılık Enjeksiyonu) ve IoC konularını anlamak ve uygulamak.

Git ve Source Control Sistemleri:

Git gibi versiyon kontrol sistemlerini kullanarak kodunuzu yönetmeyi öğrenmek.
Bu konuları öğrenmek ve uygulamak, C# dilindeki yeteneklerinizi daha da geliştirmenize yardımcı olacaktır. Ayrıca, projeler üzerinde çalışmak ve gerçek dünya uygulamaları geliştirmek de öğrenme sürecinizi hızlandıracaktır.

......................................................................................................................................................................................................................................................................................................................................................................................................





// blank solution boş bir çözüm ekranı açar...
// existing project ile projelerin benzer kısımlarını çekebiliriz...
// bazen framework sürüm farklılığından dolayı projeler çalışmayabilir buna dikkat etmek lazım...
// Sürümlerde üst olan hepsini kapsar ama 4.7.2   4.8 ile yazılmış olanı desteklemeyebilir. ama 4.8 kendinden alt olanları destekler.  
// nuget ile biz istersek dependies ekleyebiliriz entity framework gibi...
// c#da her veri wrapper classtır yani her ver bir nesnedir. bu yüzden her verinin metotlarını kullanabiliriz. mesela int a = 8; deriz a.equals vs kullanabiliriz...  eğer bir metotta yollayıp değerinin değişmesini falan istersek o zaman ref ile yollarız...
// static metot static main içinde çalışabilir static olmayan değer static içinde çalışmaz... static-static veya non-static - non-static olmalı...
// mesela bir class'ın oluşması için önce onun superclass'ı oluşmalı oluşurken default constructor çalışır....
degistir(ref a)
public void degisttir(ref int b) gibi...

c#da ilkel yapılar yoktur. her şey nesnedir... wrapper classtır aslında veriler.
            Console.WriteLine(int.MinValue);   // mesela direkt olarak int class'ının içindeki static MinValue değerini çağırabiliriz...  static olan değerleri ve metotları direkt olarak class ile kullanabiliriz...
            Console.WriteLine(int.MaxValue);

Console.WriteLine(int.MinValue + " EMRE"+ byte.MinValue+" FORD"+byte.MaxValue);
     + demek String'de ekleme yap demektir. böylece tüm değerler string'e döner ve işlem yapabiliriz...



            double say11 = 12.2;
            Console.WriteLine(say11);
            float say12 = (float)12.33;  // her noktalı değer aslında double'dir bizim atama yaparken float'a tip dönüşümü yapmamız lazım uppercasting yapmamız gerekiyor...
            Console.WriteLine(say12);




c#tada diğer dillerde olduğu gibi tüm veriler tanımlanır bir metot eğer bir değer dönderiyorsa o zaman tipinde karşılanır int sayi1 = sayigetir(); gibi.

Tam Sayı Veri Tipleri:

int: 32 bitlik işaretli tam sayı.
long: 64 bitlik işaretli tam sayı.
short: 16 bitlik işaretli tam sayı.
byte: 8 bitlik işaretli tam sayı.
sbyte: 8 bitlik işaretli tam sayı.

Ondalıklı Sayı Veri Tipleri:

float: 32 bitlik ondalıklı sayı.
double: 64 bitlik ondalıklı sayı.
decimal: 128 bitlik ondalıklı sayı.

Karakter Veri Tipleri:

char: 16 bitlik Unicode karakter.

Boolean Veri Tipi:

bool: Mantıksal (true veya false) değeri temsil eder.

Metinsel Veri Tipleri:

string: Metin verilerini tutan veri tipi.

Object Veri Tipi:

object: Tüm diğer türlerin temel türüdür. Her türden bir nesneyi temsil edebilir.
Diziler:

int[], string[], vb.: Belirli bir türdeki elemanları içeren diziler.
Nullable Veri Tipleri:

int?, bool?, vb.: Nullable türler, değerlerin null olabileceği anlamına gelir.
Enumerations (Enum):

enum: Belirli bir türdeki sabit değerlerin adlarını içeren bir türdür.
Yapılar (Structures):

struct: Değer türleri olan, ancak sınıflar gibi davranabilen türler.
Sınıflar (Classes):

class: Referans türleri olan ve nesne tabanlı programlamanın temelini oluşturan türler.
Interface ve Arayüzler:

interface: Bir sınıfın uygulamasını zorlayan bir sözleşme sağlayan tür.

// oop demek encapsulation,polymorphism and inheritance demektir aslında...
// interfaceler aslında birer sözleşmelerdir böylece içerisindeki metotları override etmek zorunlu olur implement eden class tarafından...

################################################################################################################################################################################################################################################


            Console.WriteLine(Byte.MaxValue); // 255    256 vermeye çalışırsan Byte değere o zaman hata verir...
            Console.WriteLine(Byte.MinValue); // 0
            Console.WriteLine(long.MinValue); // -9223372036854775808
            Console.WriteLine(long.MaxValue); //   9223372036854775807
            Console.WriteLine(int.MaxValue); // 2147483647    32 bit 4 byte 2^^32 değer alır.
            Console.WriteLine(int.MinValue); // - 2147483648
            Console.WriteLine(long.MaxValue / int.MaxValue); // 4294967298
            Console.WriteLine(double.MinValue); //-1,79769313486232E+308
            Console.WriteLine(double.MaxValue); // 1,79769313486232E+308
            Console.WriteLine(ulong.MaxValue); // 18446744073709551615
            Console.WriteLine(ulong.MinValue); // 0
            Console.WriteLine(sbyte.MaxValue); // 127
            Console.WriteLine(sbyte.MinValue); // - 128
            Console.WriteLine(short.MaxValue); // 32767
            Console.WriteLine(short.MinValue); //-32768
            Console.WriteLine(ushort.MaxValue); //65535
            Console.WriteLine(ushort.MinValue); //0
            Console.WriteLine(uint.MaxValue); // 4294967295
            Console.WriteLine(uint.MinValue); // 0
            Console.WriteLine(decimal.MaxValue); // 79228162514264337593543950335     // 12 byte'dır noktadan sonra 28-29 basamak duyarı vardır...  doublede 15 16 basamak iken decimalde 28 29 böylece hassaslık çok artar...
            Console.WriteLine(decimal.MinValue); // -79228162514264337593543950335  
            Console.WriteLine(char.MinValue); // nulldan başlar
            Console.WriteLine(char.MaxValue); // ?'e kadar gider çok fazla karakterleri tutabilir. tüm dillerin alfabelerindeki harfleri tutabilir. 2 bytedir 16 bit...

bool true veya false alır mantıksal veridir... a == b demek (a == b)   bize true veya false döndürecek demektir    return a == b diyebiliriz a == b 'de true veya false dönecek zaten...

internal bir erişim belirleyicisidir ve C# dilinde bir sınıfın veya bir üyenin, yalnızca bulunduğu proje içinde erişilebilir olmasını sağlar. internal olarak işaretlenen bir sınıf veya üye, aynı derleme içindeki diğer sınıflar tarafından erişilebilir, ancak başka bir derleme tarafından erişilemez.

    "Aynı derleme" ifadesi, bir C# projesinde bir araya getirilen tüm kodun toplandığı ve derlendiği yapıyı ifade eder. Bir C# projesi, bir veya birden fazla sınıf ve dosyanın bir araya getirildiği bir "derleme" üretir. Bu derleme genellikle bir .dll (dinamik bağlantı kitaplığı) veya .exe (yürütülebilir dosya) uzantısına sahiptir.

    Bir C# projesindeki tüm sınıflar, yapılar, enum'lar, metotlar ve diğer üyeler, projenin derlenmiş çıktısı içinde bir araya getirilir. Bu çıktıya "derleme" denir. Eğer tüm bu kodlar aynı proje içinde yer alıyorsa, bu kodlar aynı derleme içindedir.

    Eğer bir sınıf veya üye internal olarak işaretlenmişse, bu, bu sınıfın veya üyenin sadece aynı derleme içindeki diğer kodlar tarafından erişilebileceği anlamına gelir. Yani, internal olarak işaretlenen bir sınıf veya üyenin erişilebilir olması için, bu sınıf veya üyenin bulunduğu proje içinde olması gerekmektedir.

    Aynı derleme içinde olmak, bir C# projesinin sınıflarının, üyelerinin ve diğer yapılarının bir araya getirildiği ve derlendiği fiziksel sınırları ifade eder. Eğer farklı projeler arasında kod paylaşımı yapmak istiyorsanız, bu durumu public veya başka bir erişim belirleyici ile yönetmeniz gerekir.


// her kesirli sayı doubledir float vs yapmak istersek o zaman tip dönüşümü yapmak lazım (float) 5.6   veya 5.6f  olarak
double sayi1 = 5/4;  1.0 olur   5 int 4 int spnuç int 1 olur double olunca 1.0 olur....    (double) 5 / 4 olsa 5.0 / 4 olur  o zaman 1.25 çıkar direkt olarak...

bölümde falan kesirli sayılarda kayıplar olabilir bunun için decimal kullanılır... hassas hesaplar için decimal kullanırız. bunu e ticaret sitelerinde vs kullanabiliriz...
     tip dönüşümlerinde kayıplar vs olabilir kesirlerden kaynaklı kayıplar olabilir bunun için decimal kullanırız hassas hesaplarda...

karakterler '' içeriisnde stringler ise "" içerisinde belirtilmelidir. pythona böyle bir fark yoktur mesela...
'' içerisinde tek bir karakter belirtilebilir.
"" olursa karakter dizisi içerebilir.

\ demek benden sonra gelecek olan bilgisayarın program komutu değil demektir.
          ana \n alt satır \t ise bir tab boşluk demektir.

c# büyük harf küçük harf ayrımı yapar int sayi1,Sayi1; yapabiliriz... yani farklı olacaktir ikiside...

*******CASTİNG büyük alandaki veri küçük alana geçemez geçecek olursa kayıplar olur ancak casting ile kayıplarla beraber yapmak mümkün. küçük veriyi büyük veri tipine sorunsuz dönüştürebiliriz. 
  mesela floatı doubleye sorunsuz atabiliriz.  ama doubleyi dönüşüm yapmadan atamayız atarsakta kayıplar olur veri kaybı olur.
  long inti sorunsuz alır veri kaybı olmadan ama tam tersi zor.
  intin long'a atanması implicit(istemsiz) dönüşümdür bir hata vermez.     
  longun int olması ise explicit döünüşümdür dönüşümü belirtmek lazım downcasting yapmak gerekir. 
  longu int yapmak için derleyiciyi ikna etmemiz lazım....
  c#da java gibi önce derlenir sonra yorumlanır.
  explicit yaparsak manuel yapmalıyız  double sayi1 = 18.8;    int sayi2 = (int)sayi1; gibi...


            Console.WriteLine(Convert.ToString(3.43));
            Console.WriteLine(Convert.ToInt64(3.43));
            int sayi12 = Convert.ToInt32("12");
            long sayi13 = Convert.ToInt64("1221");

Convert.ToTip   ile biz içerisine attığımız değeri istenen değere çeviririz. ve bu yapı isteneni return eder... int'e atama yapacaksak Convert.ToInt32(); kullanmamız lazım 
Convert.ToInt32() bu bize değer return edecek ve kullanacağız.



################################################################################################################################################################################################################################################

dizilerde veri tipleri aynı olur;
Array bir sınıftır

            int[] array = { 1, 2, 3, 4, 5, }; // burada direkt atama yapabiliriz... 
            int[] array2 = new int[10]; // burada ise 10 tane int değer alacak yer ayırırız ve otomatik olarak hepsi sıfır olur sayılarda ilk atama otomatik sıfırdır string ve class'larda ise nulldır.

Arraylerde referancelerla çalışır yani 
        public static void degistir(int[] a)
        {

            a[0] = 11;


        }   // buraya bir array gelirse ilk değeri 11 olacak kalıcı şekilde...  bunun nedeni arrayler aslında referancedir.

int[][] ab = new int[10][];  // burada 10 tane int dizisi olacak diyoruz... ikinci [] atamaya gerek yok ama atarsak sabit olarak onlarda o sayı kadar değer taşıyan int arrayler olacak... 
yani ab 10 tane int array taşıyan bir array'dir.  ab.length dersek 10 alırız...
int[][] ab = new int[10][6]; dersek eğer 10 tane 6 tane int değer taşıyan aarray vardır 6,6,6,6,6,6,6,6,6,6,6 olacak şekilde...

            int[][] ab = new int[10][];
            for (int i = 0; i < ab.Length; i++)
            {
                ab[i] = new int[9];
            }
            // bu şekilde ise 10 kere çalışır for ve her arraye bellekte yer ayırır her arrya 9 tane değer alabilir hale gelir.  bu yapı ile kapasiteleri farklı arraylerden oluşan matrisler kurabiliriz.

ab[1][1] = 100; diyerek direkt atama yapabiliriz...

mesela 10 kapasiteli bir array var 11.ciye atama yapmak istersek hata alırız.

string[] ise string değer taşıyan bir arraydir bu bir referancedir.

array[index]  ile istenen elemana ulaşırız. indexin arrayin boyutuna göre olması gerekir bu önemlidir.  yoksa hata verebilir.

int[,] demekte 2 boyutlu bir dizidir.
int[,,] ise 3 boyutlu demektir...

..........................................................................................

            int[][] aa = new int[10][];
            for (int i = 0; i < aa.Length; i++) {
                aa[i] = new int[9];
            }

            for (int i = 0;i < aa.Length; i++) { 
            for (int j = 0; j < aa[i].Length; j++)
                {
                    Console.Write(aa[i][j]);  // aa[i,j] de olabilir fark etmez... 

                }
                Console.WriteLine();

            }

int[,] aa = new int[2,3] yapabiliriz  3,3 eleman taşıyan bir matris olur böylece.
veya aa = {{1,1,1},{1,1,1}} yapabiliriz.


..........................................................................................
    internal class Program
    {
        static void Main(string[] args)
        {

            class1 cl1 = new class1("w","w",11);
            cl1 = new class1("w", "a", 11);
            Console.WriteLine(cl1);
            degistir(ref cl1);
            Console.WriteLine(cl1);



        }
        public static void degistir(ref class1 a)
        {

            a = new class1("ff","aa",11);



        }

    }  // array değilse bir değerin değişimi biz metot vs ile yapmak istersek ref kullanırız stringler için class'lar için vs vs...

..................................................................................................

################################################################################################################################################################################################################################################


// struct tanımlama ve kullanımı

struct node 
{
    public int deger;
    public String name;

}

public static void Main(String[] args){
            node node1 = new node();

            node1.name = "emre";
            node1.deger = 15;
}

################################################################################################################################################################################################################################################

// Main sadece bir tane olur ve programın çalışması için gerekli olan o metottur ana metottur...
// String ile string arasında bir fark yoktur... ikiside aynıdır referans bilmem ne vs vs... 

            bool dogrumu = false;

            while (dogrumu)
            {





            }
            if (dogrumu)
            {

                    
            }else if (dogrumu) { 
            
            
            }else { Console.WriteLine("FORD ");
            }

// değişkenler verileri tutan yapılardır. her sınıf bir blok içerisindedir.
// bir class içerisinde tanımlananlar aslında o class'a özgüdür...
// c#da değişkenler rakamla vs başlayamaz... metinsel ifadeler falan mantıklıdır. ve dikkat etmemiz gerekn bir nokta  class isimleri büyükle başlar fonkisyonlar vve değişkenler ise küçükle başlar yeni kelimede o kelimenin baş harfi büyür.
class: EmreAraba   metot: gitAraba() değişken: arabaMotor = 12; gibi...
// değişken bir class içerisinde kullanıldı ise tüm class ona erişebilir.

// stack ve heap dene iki bölge var bellekte ana bölgede ramle bellek arasında fark var stack ve heap olarak. değer tipliler stackte tutulur referance tipliler ise heap alanında tutulur sınıflara ait nesneler heapte tutulur.
// string dışındakiler stack'te tutulur. string ise heapte.

// sabit ve değişken farkı nedir... const mesela değişmez ve değeri tanımlanırken atanmalı.
          const int deger2 = 11;  gibi.
          int deger1 = 11; 
          deger1 = 12; // sabit değildir değişkendir const değilse... porgramda zamanla değişebilir.

// c# dilinde bir veriye double int float vs değer verilmediyse eğer o zaman 0 olur string ise null olur vs vs mesela class ürettik emre diye emre emre1; dedik emre1 nulldır. default olarak 0 veya null ataması yapılır...
//             int[] matris1 = new int[100]; dizi oluşturma böyle yapılır.

// string bir referans türüdür, yani değer tipleri gibi doğrudan değeri saklamaz. Bunun yerine bellekte bir referans saklar ve bu referans, metni içeren bellek bölgesini gösterir.
     

        public static int toplama(int a)
        {
            return a;
        }
        public static int toplama(int a,int b)
        {
            
            return a + b; 
        }
        // ikisinide aynı anda kullanabiliriz gönderilen verilere göre hangi metotun çalışacağını ise c# belirler buna method overloading denir...
        mesela toplama(5) dersem en üstteki çalışır toplama(10,8) dersen alttaki çalışır...



class isimler
{


    private int deger;
    private String name;
    private isimler isimlersonraki = null;  // burada mesela her nesne oluştuğunda otomatik olarak null olacak...

    
    public isimler(int deger, string name)
    {   
        this.deger = deger;
        this.name = name;
    }
         public isimler() // default constructor'dur bu mesela...   iki tane constructor var bunada constructor overloading denir... parametrelere göre hangisi çlaışacak c# belirler bunu
    {   
        
    }
     

}


// c# dilinde veri tipleri ilkel değildir. hepsi bir nesnedir.
// her sınıf soyut bir veri yapısıdır.
// /**/  buda uzun veri sistemi.
// common type sistem = ortak veri modeli.
// import yerine using kullanırız...

/*
            Console.Write("Kullanici adi giriniz: ");
            string isim = Console.ReadLine();
            Console.WriteLine(isim);

*/ consoldan veri alma böyle yapılır string için... 

// c# dilinde global değişken yoktur her veri bir class'a özgü olmalıdır. her metot her değişken bir class'a bağlı olmalıdır.
// değişkenler rakamlarla başlamaz arada boşluk olamaz para simgeleri olabilir ! & vs gibi karakterler olmaz.
// değişkenlerde iki tip vardır değer ve referance tipleri.  stack ve heap bölgeleri vardır bellekte.   ramda stack ve heap vardır.  referance tipleri heapte tutulur.   classla başlayan yapılar heapte tutulur string dışı değerler stackte tutulut değer tiplidir çünkü...
// charda aslında sayısal olarak tutar ama biz onu karakterlere çeviririz dil ile.

            Console.Write("");  // yazar ve alt satıra geçirmez...
            Console.WriteLine(""); // yazar ve alt satıra geçirir otomatik olarak \n eklenir...

            Console.Write( 14 + " " +  4); demek aslında append demek...  tüm değerleri string yapar eğer +'nın içerisinde string varsa ve sırası ile hepsini append eder...

string yazi1 = "emre" + 15; hata vermez... 15 string'e çevrilir ve + ile append edilir..
string yazi2 = 15; hata verir...   

// encapsulation demek nesnenin vcerilerine nesne.  şeklinde ulaşmayı private ile kısıtlamak demektir...     nesnenin verilerine nesnenin metotları ile ulaşmak kontrollü şekilde... getter setter kullanırız genel olarak. 



ctrl + class'ın üstüne tık ile içerisine gidebilir bilgileri görebiliriz...












